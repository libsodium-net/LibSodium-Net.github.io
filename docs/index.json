{
  "api/LibSodium.Aegis128L.html": {
    "href": "api/LibSodium.Aegis128L.html",
    "title": "Class Aegis128L | LibSodium.Net",
    "summary": "Class Aegis128L Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the AEGIS-128L AEAD construction from Libsodium. public static class Aegis128L Inheritance object Aegis128L Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (32). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (16). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AEGIS-128L. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key SecureMemory<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (16 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AEGIS-128L. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (16 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AEGIS-128L. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key SecureMemory<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (16 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AEGIS-128L. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (16 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.Aegis256.html": {
    "href": "api/LibSodium.Aegis256.html",
    "title": "Class Aegis256 | LibSodium.Net",
    "summary": "Class Aegis256 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the AEGIS-256 AEAD construction from Libsodium. public static class Aegis256 Inheritance object Aegis256 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (32). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (32). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AEGIS-256. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key SecureMemory<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (32 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AEGIS-256. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (32 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AEGIS-256. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key SecureMemory<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (32 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AEGIS-256. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (32 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.Aes256Gcm.html": {
    "href": "api/LibSodium.Aes256Gcm.html",
    "title": "Class Aes256Gcm | LibSodium.Net",
    "summary": "Class Aes256Gcm Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the AES256-GCM AEAD construction from Libsodium. public static class Aes256Gcm Inheritance object Aes256Gcm Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (12). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AES256-GCM. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key SecureMemory<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AES256-GCM. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AES256-GCM. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key SecureMemory<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AES256-GCM. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.Base64Encoding.html": {
    "href": "api/LibSodium.Base64Encoding.html",
    "title": "Class Base64Encoding | LibSodium.Net",
    "summary": "Class Base64Encoding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for Base64 encoding and decoding. public static class Base64Encoding Inheritance object Base64Encoding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Base64ToBin(ReadOnlySpan<char>, Span<byte>, Base64Variant, string?) Decodes a Base64 string into a binary representation. public static Span<byte> Base64ToBin(ReadOnlySpan<char> b64, Span<byte> bin, Base64Variant variant, string? ignore = null) Parameters b64 ReadOnlySpan<char> The Base64 string to decode as a ReadOnlySpan. bin Span<byte> The span to store the decoded binary data. variant Base64Variant The Base64 variant to use. ignore string Characters to ignore during decoding. Returns Span<byte> A span containing the decoded binary data. Base64ToBin(string, Span<byte>, Base64Variant, string?) Decodes a Base64 string into a binary representation. public static Span<byte> Base64ToBin(string b64, Span<byte> bin, Base64Variant variant, string? ignore = null) Parameters b64 string The Base64 string to decode. bin Span<byte> The span to store the decoded binary data. variant Base64Variant The Base64 variant to use. ignore string Characters to ignore during decoding. Returns Span<byte> A span containing the decoded binary data. BinToBase64(ReadOnlySpan<byte>, Base64Variant) Encodes binary data into a Base64 string. public static string BinToBase64(ReadOnlySpan<byte> bin, Base64Variant variant) Parameters bin ReadOnlySpan<byte> The binary data to encode. variant Base64Variant The Base64 variant to use. Returns string A Base64 encoded string. BinToBase64(ReadOnlySpan<byte>, Span<char>, Base64Variant) Encodes binary data into a Base64 representation and stores it in a character span. public static Span<char> BinToBase64(ReadOnlySpan<byte> bin, Span<char> b64, Base64Variant variant) Parameters bin ReadOnlySpan<byte> The binary data to encode. b64 Span<char> The span to store the Base64 encoded data. variant Base64Variant The Base64 variant to use. Returns Span<char> A span containing the Base64 encoded data. GetBase64DecodedMaxLen(int) Calculates the maximum length of the decoded binary data from a Base64 string. public static int GetBase64DecodedMaxLen(int base64Len) Parameters base64Len int The length of the Base64 string. Returns int The maximum length of the decoded binary data. GetBase64EncodedLen(int, Base64Variant, bool) Calculates the length of the Base64 encoded string for a given binary length. public static int GetBase64EncodedLen(int binLen, Base64Variant variant, bool includeNullTerminator = true) Parameters binLen int The length of the binary data. variant Base64Variant The Base64 variant to use. includeNullTerminator bool Indicates whether to include a null terminator in the length calculation. Returns int The length of the Base64 encoded string."
  },
  "api/LibSodium.Base64Variant.html": {
    "href": "api/LibSodium.Base64Variant.html",
    "title": "Enum Base64Variant | LibSodium.Net",
    "summary": "Enum Base64Variant Namespace LibSodium Assembly LibSodium.Net.dll Represents Base64 encoding variants. public enum Base64Variant Fields Original = 1 Original Base64 encoding variant. OriginalNoPadding = 3 Original Base64 encoding variant with no padding. UrlSafe = 5 URL safe Base64 encoding variant. UrlSafeNoPadding = 7 URL safe Base64 encoding variant with no padding."
  },
  "api/LibSodium.ChaCha20Poly1305.html": {
    "href": "api/LibSodium.ChaCha20Poly1305.html",
    "title": "Class ChaCha20Poly1305 | LibSodium.Net",
    "summary": "Class ChaCha20Poly1305 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the ChaCha20-Poly1305 AEAD construction from Libsodium. public static class ChaCha20Poly1305 Inheritance object ChaCha20Poly1305 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (8). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key SecureMemory<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (8 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (8 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key SecureMemory<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (8 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (8 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.ChaCha20Poly1305Ietf.html": {
    "href": "api/LibSodium.ChaCha20Poly1305Ietf.html",
    "title": "Class ChaCha20Poly1305Ietf | LibSodium.Net",
    "summary": "Class ChaCha20Poly1305Ietf Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the IETF variant of the ChaCha20-Poly1305 AEAD construction from Libsodium. public static class ChaCha20Poly1305Ietf Inheritance object ChaCha20Poly1305Ietf Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (12). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key SecureMemory<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key SecureMemory<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.CryptoAuth.html": {
    "href": "api/LibSodium.CryptoAuth.html",
    "title": "Class CryptoAuth | LibSodium.Net",
    "summary": "Class CryptoAuth Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for message authentication using the crypto_auth API from libsodium. [Obsolete(\"Use CryptoHmacSha512_256 instead. CryptoAuth is deprecated and will be removed in future versions.\")] public static class CryptoAuth Inheritance object CryptoAuth Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class wraps the crypto_auth functions from libsodium's secret-key authentication API, which uses the HMAC-SHA-512-256 algorithm to generate and verify message authentication codes (MACs). Fields KeyLen The length, in bytes, of a valid secret key for HMAC-SHA-512-256. public const int KeyLen = 32 Field Value int MacLen The length, in bytes, of the MAC produced by HMAC-SHA-512-256. public const int MacLen = 32 Field Value int Methods ComputeMac(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Computes a message authentication code (MAC) for the given input using HMAC-SHA-512-256. public static void ComputeMac(Span<byte> mac, ReadOnlySpan<byte> input, SecureMemory<byte> key) Parameters mac Span<byte> A writable buffer with a length of MacLen bytes that will receive the computed MAC. input ReadOnlySpan<byte> The message data to authenticate. key SecureMemory<byte> The secret key to use for authentication, must be KeyLen bytes long. Remarks This method is a wrapper around libsodium's crypto_auth function. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when the underlying libsodium operation fails unexpectedly. ComputeMac(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Computes a message authentication code (MAC) for the given input using HMAC-SHA-512-256. public static void ComputeMac(Span<byte> mac, ReadOnlySpan<byte> input, ReadOnlySpan<byte> key) Parameters mac Span<byte> A writable buffer with a length of MacLen bytes that will receive the computed MAC. input ReadOnlySpan<byte> The message data to authenticate. key ReadOnlySpan<byte> The secret key to use for authentication, must be KeyLen bytes long. Remarks This method is a wrapper around libsodium's crypto_auth function. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when the underlying libsodium operation fails unexpectedly. GenerateKey(Span<byte>) Generates a new random secret key for use with HMAC-SHA-512-256. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> A writable buffer with a length of KeyLen bytes that will be filled with the generated key. Remarks This function uses a cryptographically secure random number generator to produce a secret key. Internally calls crypto_auth_keygen from libsodium. Exceptions ArgumentException Thrown when the buffer length is not equal to KeyLen. TryVerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Attempts to verify that a given MAC is valid for the specified input and key using HMAC-SHA-512-256. public static bool TryVerifyMac(ReadOnlySpan<byte> mac, ReadOnlySpan<byte> input, SecureMemory<byte> key) Parameters mac ReadOnlySpan<byte> The message authentication code to verify. Must be MacLen bytes long. input ReadOnlySpan<byte> The original message data that the MAC should authenticate. key SecureMemory<byte> The secret key that was used to generate the MAC. Must be KeyLen bytes long. Returns bool true if the MAC is valid; otherwise, false. Remarks This method wraps the crypto_auth_verify function from libsodium. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when an unexpected error occurs during verification. TryVerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Attempts to verify that a given MAC is valid for the specified input and key using HMAC-SHA-512-256. public static bool TryVerifyMac(ReadOnlySpan<byte> mac, ReadOnlySpan<byte> input, ReadOnlySpan<byte> key) Parameters mac ReadOnlySpan<byte> The message authentication code to verify. Must be MacLen bytes long. input ReadOnlySpan<byte> The original message data that the MAC should authenticate. key ReadOnlySpan<byte> The secret key that was used to generate the MAC. Must be KeyLen bytes long. Returns bool true if the MAC is valid; otherwise, false. Remarks This method wraps the crypto_auth_verify function from libsodium. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when an unexpected error occurs during verification. VerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Verifies that a given MAC is valid for the specified input and key using HMAC-SHA-512-256. public static void VerifyMac(ReadOnlySpan<byte> mac, ReadOnlySpan<byte> input, SecureMemory<byte> key) Parameters mac ReadOnlySpan<byte> The message authentication code to verify. Must be MacLen bytes long. input ReadOnlySpan<byte> The original message data that the MAC should authenticate. key SecureMemory<byte> The secret key that was used to generate the MAC. Must be KeyLen bytes long. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when the MAC verification fails or an unexpected error occurs. VerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies that a given MAC is valid for the specified input and key using HMAC-SHA-512-256. public static void VerifyMac(ReadOnlySpan<byte> mac, ReadOnlySpan<byte> input, ReadOnlySpan<byte> key) Parameters mac ReadOnlySpan<byte> The message authentication code to verify. Must be MacLen bytes long. input ReadOnlySpan<byte> The original message data that the MAC should authenticate. key ReadOnlySpan<byte> The secret key that was used to generate the MAC. Must be KeyLen bytes long. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when the MAC verification fails or an unexpected error occurs."
  },
  "api/LibSodium.CryptoBox.html": {
    "href": "api/LibSodium.CryptoBox.html",
    "title": "Class CryptoBox | LibSodium.Net",
    "summary": "Class CryptoBox Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the Curve25519-based public-key authenticated encryption (crypto_box) from Libsodium. public static class CryptoBox Inheritance object CryptoBox Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes, auto nonce, as well as encryption using precomputed shared keys. Properties MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (24). public static int NonceLen { get; } Property Value int PrivateKeyLen Private key length in bytes (32). public static int PrivateKeyLen { get; } Property Value int PublicKeyLen Public key length in bytes (32). public static int PublicKeyLen { get; } Property Value int SealOverheadLen Length of the ciphertext overhead (48) when using EncryptWithPublicKey and DecryptWithPrivateKey. public static int SealOverheadLen { get; } Property Value int SeedLen Seed length in bytes (32). public static int SeedLen { get; } Property Value int SharedKeyLen Shared key length in bytes (32). public static int SharedKeyLen { get; } Property Value int Methods CalculatePublicKey(Span<byte>, SecureMemory<byte>) Calculates the Curve25519 public key from a given private key. public static void CalculatePublicKey(Span<byte> publicKey, SecureMemory<byte> privateKey) Parameters publicKey Span<byte> The buffer where the calculated public key (32 bytes) will be written. privateKey SecureMemory<byte> The private key to derive from (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if public key calculation fails. CalculatePublicKey(Span<byte>, ReadOnlySpan<byte>) Calculates the Curve25519 public key from a given private key. public static void CalculatePublicKey(Span<byte> publicKey, ReadOnlySpan<byte> privateKey) Parameters publicKey Span<byte> The buffer where the calculated public key (32 bytes) will be written. privateKey ReadOnlySpan<byte> The private key to derive from (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if public key calculation fails. CalculateSharedKey(SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Calculates a shared secret using a peer's public key and the local private key. public static void CalculateSharedKey(SecureMemory<byte> sharedKey, ReadOnlySpan<byte> peerPublicKey, SecureMemory<byte> localPrivateKey) Parameters sharedKey SecureMemory<byte> The buffer where the shared key (32 bytes) will be written. peerPublicKey ReadOnlySpan<byte> The peer's public key (32 bytes). localPrivateKey SecureMemory<byte> The local private key (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if shared key calculation fails. CalculateSharedKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Calculates a shared secret using a peer's public key and the local private key. public static void CalculateSharedKey(Span<byte> sharedKey, ReadOnlySpan<byte> peerPublicKey, ReadOnlySpan<byte> localPrivateKey) Parameters sharedKey Span<byte> The buffer where the shared key (32 bytes) will be written. peerPublicKey ReadOnlySpan<byte> The peer's public key (32 bytes). localPrivateKey ReadOnlySpan<byte> The local private key (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if shared key calculation fails. DecryptWithKeypair(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using the recipient's private key and the sender's public key. Supports both combined and detached modes, with optional nonce. public static Span<byte> DecryptWithKeypair(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> senderPublicKey, SecureMemory<byte> recipientPrivateKey, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). senderPublicKey ReadOnlySpan<byte> The sender's public key (32 bytes). recipientPrivateKey SecureMemory<byte> The recipient's private key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided it is taken from the beginning of the ciphertext. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. DecryptWithKeypair(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using the recipient's private key and the sender's public key. Supports both combined and detached modes, with optional nonce. public static Span<byte> DecryptWithKeypair(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> senderPublicKey, ReadOnlySpan<byte> recipientPrivateKey, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). senderPublicKey ReadOnlySpan<byte> The sender's public key (32 bytes). recipientPrivateKey ReadOnlySpan<byte> The recipient's private key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided it is taken from the beginning of the ciphertext. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. DecryptWithPrivateKey(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Decrypts a sealed message using the recipient's private key. This method uses libsodium's crypto_box_seal_open internally and automatically derives the recipient's public key from the given private key. The ciphertext must have been produced using EncryptWithPublicKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>). public static Span<byte> DecryptWithPrivateKey(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> recipientPrivateKey) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. Must be at least ciphertext.Length - SealOverheadLen bytes long. ciphertext ReadOnlySpan<byte> The sealed ciphertext, including a 32-byte ephemeral public key and a 16-byte MAC. Must be at least SealOverheadLen bytes long. recipientPrivateKey SecureMemory<byte> The recipient's private key (32 bytes). Returns Span<byte> A slice of the plaintext buffer containing the decrypted message. Exceptions ArgumentException Thrown when buffer sizes are invalid or the private key is not 32 bytes long. LibSodiumException Thrown when the ciphertext cannot be decrypted or the MAC verification fails. DecryptWithPrivateKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a sealed message using the recipient's private key. This method uses libsodium's crypto_box_seal_open internally and automatically derives the recipient's public key from the given private key. The ciphertext must have been produced using EncryptWithPublicKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>). public static Span<byte> DecryptWithPrivateKey(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> recipientPrivateKey) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. Must be at least ciphertext.Length - SealOverheadLen bytes long. ciphertext ReadOnlySpan<byte> The sealed ciphertext, including a 32-byte ephemeral public key and a 16-byte MAC. Must be at least SealOverheadLen bytes long. recipientPrivateKey ReadOnlySpan<byte> The recipient's private key (32 bytes). Returns Span<byte> A slice of the plaintext buffer containing the decrypted message. Exceptions ArgumentException Thrown when buffer sizes are invalid or the private key is not 32 bytes long. LibSodiumException Thrown when the ciphertext cannot be decrypted or the MAC verification fails. DecryptWithSharedKey(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using a precomputed shared key. Supports both combined and detached modes, with optional nonce. public static Span<byte> DecryptWithSharedKey(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> sharedKey, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). sharedKey SecureMemory<byte> The shared key (32 bytes) previously computed using CalculateSharedKey. mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, it is taken from the beginning of the ciphertext Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. DecryptWithSharedKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using a precomputed shared key. Supports both combined and detached modes, with optional nonce. public static Span<byte> DecryptWithSharedKey(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> sharedKey, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). sharedKey ReadOnlySpan<byte> The shared key (32 bytes) previously computed using CalculateSharedKey. mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, it is taken from the beginning of the ciphertext Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. EncryptWithKeypair(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using the recipient's public key and the sender's private key. Supports both combined and detached modes, with optional nonce. public static Span<byte> EncryptWithKeypair(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> recipientPublicKey, SecureMemory<byte> senderPrivateKey, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. Must be large enough to hold the output (plaintext + 16 bytes MAC [+ 24 bytes nonce if auto-generated]). plaintext ReadOnlySpan<byte> The message to encrypt. recipientPublicKey ReadOnlySpan<byte> The recipient's public key (32 bytes). senderPrivateKey SecureMemory<byte> The sender's private key (32 bytes). mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. EncryptWithKeypair(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using the recipient's public key and the sender's private key. Supports both combined and detached modes, with optional nonce. public static Span<byte> EncryptWithKeypair(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> recipientPublicKey, ReadOnlySpan<byte> senderPrivateKey, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. Must be large enough to hold the output (plaintext + 16 bytes MAC [+ 24 bytes nonce if auto-generated]). plaintext ReadOnlySpan<byte> The message to encrypt. recipientPublicKey ReadOnlySpan<byte> The recipient's public key (32 bytes). senderPrivateKey ReadOnlySpan<byte> The sender's private key (32 bytes). mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. EncryptWithPublicKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message anonymously using the recipient's public key. This method uses Libsodium's crypto_box_seal function internally, and does not require a sender key. The resulting ciphertext includes an ephemeral public key and a MAC, adding a constant overhead of SealOverheadLen bytes. public static Span<byte> EncryptWithPublicKey(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> recipientPublicKey) Parameters ciphertext Span<byte> The buffer where the sealed ciphertext will be written. Must be at least plaintext.Length + SealOverheadLen bytes long. plaintext ReadOnlySpan<byte> The message to encrypt. recipientPublicKey ReadOnlySpan<byte> The recipient's public key (32 bytes). Returns Span<byte> A slice of the ciphertext buffer containing the full sealed ciphertext. Exceptions ArgumentException Thrown when the recipient's public key is not 32 bytes long, or when the ciphertext buffer is too small. LibSodiumException Thrown when the underlying Libsodium encryption operation fails. EncryptWithSharedKey(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using a precomputed shared key. Supports both combined and detached modes, with optional nonce. public static Span<byte> EncryptWithSharedKey(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> sharedKey, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. Must be large enough to hold the output (plaintext + 16 bytes MAC [+ 24 bytes nonce if auto-generated]). plaintext ReadOnlySpan<byte> The message to encrypt. sharedKey SecureMemory<byte> The shared key (32 bytes) previously computed using CalculateSharedKey. mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. EncryptWithSharedKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using a precomputed shared key. Supports both combined and detached modes, with optional nonce. public static Span<byte> EncryptWithSharedKey(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> sharedKey, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. Must be large enough to hold the output (plaintext + 16 bytes MAC [+ 24 bytes nonce if auto-generated]). plaintext ReadOnlySpan<byte> The message to encrypt. sharedKey ReadOnlySpan<byte> The shared key (32 bytes) previously computed using CalculateSharedKey. mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. GenerateKeypair(Span<byte>, SecureMemory<byte>) Generates a new Curve25519 key pair for use with crypto_box. public static void GenerateKeypair(Span<byte> publicKey, SecureMemory<byte> privateKey) Parameters publicKey Span<byte> The buffer where the generated public key (32 bytes) will be written. privateKey SecureMemory<byte> The buffer where the generated private key (32 bytes) will be written. Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key generation fails. GenerateKeypair(Span<byte>, Span<byte>) Generates a new Curve25519 key pair for use with crypto_box. public static void GenerateKeypair(Span<byte> publicKey, Span<byte> privateKey) Parameters publicKey Span<byte> The buffer where the generated public key (32 bytes) will be written. privateKey Span<byte> The buffer where the generated private key (32 bytes) will be written. Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key generation fails. GenerateKeypairDeterministically(Span<byte>, SecureMemory<byte>, ReadOnlySpan<byte>) Generates a Curve25519 key pair deterministically from a seed. public static void GenerateKeypairDeterministically(Span<byte> publicKey, SecureMemory<byte> privateKey, ReadOnlySpan<byte> seed) Parameters publicKey Span<byte> The buffer where the generated public key (32 bytes) will be written. privateKey SecureMemory<byte> The buffer where the generated private key (32 bytes) will be written. seed ReadOnlySpan<byte> The seed to use for deterministic key generation (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key generation fails. GenerateKeypairDeterministically(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Generates a Curve25519 key pair deterministically from a seed. public static void GenerateKeypairDeterministically(Span<byte> publicKey, Span<byte> privateKey, ReadOnlySpan<byte> seed) Parameters publicKey Span<byte> The buffer where the generated public key (32 bytes) will be written. privateKey Span<byte> The buffer where the generated private key (32 bytes) will be written. seed ReadOnlySpan<byte> The seed to use for deterministic key generation (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key generation fails."
  },
  "api/LibSodium.CryptoGenericHash.html": {
    "href": "api/LibSodium.CryptoGenericHash.html",
    "title": "Class CryptoGenericHash | LibSodium.Net",
    "summary": "Class CryptoGenericHash Namespace LibSodium Assembly LibSodium.Net.dll Provides a high-level interface to the libsodium generic hash function, based on BLAKE2b. public static class CryptoGenericHash Inheritance object CryptoGenericHash Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class wraps the crypto_generichash functions from libsodium, offering both one-shot and streaming hash computations. The output length and key length can be customized within defined bounds. The hash can be computed over a byte span or a stream, synchronously or asynchronously. For additional details, see the official libsodium documentation: \uD83E\uDDC2 https://libsodium.gitbook.io/doc/hashing/generic_hashing Fields HashLen Default hash length in bytes (32). public const int HashLen = 32 Field Value int KeyLen Default key length in bytes (32). public const int KeyLen = 32 Field Value int MaxHashLen Maximum allowed length in bytes for the hash (64). public const int MaxHashLen = 64 Field Value int MaxKeyLen Maximum allowed key length in bytes (64 bytes). public const int MaxKeyLen = 64 Field Value int MinHashLen Minimum allowed length in bytes for the hash (16). public const int MinHashLen = 16 Field Value int MinKeyLen Minimum length in bytes for secret keys (16). public const int MinKeyLen = 16 Field Value int Methods ComputeHash(Span<byte>, Stream, SecureMemory<byte>?) Computes a generic hash from the contents of a stream. public static void ComputeHash(Span<byte> hash, Stream input, SecureMemory<byte>? key = null) Parameters hash Span<byte> The buffer where the computed hash will be written. Its length defines the output size. input Stream The input stream to read and hash. key SecureMemory<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. ComputeHash(Span<byte>, Stream, ReadOnlySpan<byte>) Computes a generic hash from the contents of a stream. public static void ComputeHash(Span<byte> hash, Stream input, ReadOnlySpan<byte> key = default) Parameters hash Span<byte> The buffer where the computed hash will be written. Its length defines the output size. input Stream The input stream to read and hash. key ReadOnlySpan<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. ComputeHash(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>?) Computes a generic hash of the specified message. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message, SecureMemory<byte>? key = null) Parameters hash Span<byte> The buffer where the computed hash will be written. Its length defines the output size. message ReadOnlySpan<byte> The input message to hash. key SecureMemory<byte> An optional key for keyed hashing (HMAC-like). May be null for unkeyed mode. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. ComputeHash(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Computes a generic hash of the specified message. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message, ReadOnlySpan<byte> key = default) Parameters hash Span<byte> The buffer where the computed hash will be written. Its length defines the output size. message ReadOnlySpan<byte> The input message to hash. key ReadOnlySpan<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. ComputeHashAsync(Memory<byte>, Stream, SecureMemory<byte>?, CancellationToken) Asynchronously computes a generic hash from the contents of a stream. public static Task ComputeHashAsync(Memory<byte> hash, Stream input, SecureMemory<byte>? key = null, CancellationToken cancellationToken = default) Parameters hash Memory<byte> The memory buffer where the computed hash will be written. Its length defines the output size. input Stream The input stream to read and hash. key SecureMemory<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task A task representing the asynchronous hash computation. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. ComputeHashAsync(Memory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously computes a generic hash from the contents of a stream. public static Task ComputeHashAsync(Memory<byte> hash, Stream input, ReadOnlyMemory<byte> key = default, CancellationToken cancellationToken = default) Parameters hash Memory<byte> The memory buffer where the computed hash will be written. Its length defines the output size. input Stream The input stream to read and hash. key ReadOnlyMemory<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task A task representing the asynchronous hash computation. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. CreateIncrementalHash(SecureMemory<byte>?, int) public static ICryptoIncrementalHash CreateIncrementalHash(SecureMemory<byte>? key = null, int hashLen = 32) Parameters key SecureMemory<byte> hashLen int Returns ICryptoIncrementalHash CreateIncrementalHash(ReadOnlySpan<byte>, int) public static ICryptoIncrementalHash CreateIncrementalHash(ReadOnlySpan<byte> key = default, int hashLen = 32) Parameters key ReadOnlySpan<byte> hashLen int Returns ICryptoIncrementalHash"
  },
  "api/LibSodium.CryptoHChaCha20.html": {
    "href": "api/LibSodium.CryptoHChaCha20.html",
    "title": "Class CryptoHChaCha20 | LibSodium.Net",
    "summary": "Class CryptoHChaCha20 Namespace LibSodium Assembly LibSodium.Net.dll Deterministically derives 32-byte subkeys using the HChaCha20 core function from a key, a salt-like input and optional domain context. public static class CryptoHChaCha20 Inheritance object CryptoHChaCha20 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields ContextLen Length of the context (16 bytes), used for domain separation. public const int ContextLen = 16 Field Value int InputLen Length of the input (16 bytes). public const int InputLen = 16 Field Value int KeyLen Length of the master key (32 bytes). public const int KeyLen = 32 Field Value int SubKeyLen Length of the derived subkey (32 bytes). public const int SubKeyLen = 32 Field Value int Methods DeriveSubkey(SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives a 32-byte subkey from a master key using the HChaCha20 function. This function is suitable for fast, deterministic key derivation with domain separation. public static void DeriveSubkey(SecureMemory<byte> masterKey, SecureMemory<byte> subKey, ReadOnlySpan<byte> input, ReadOnlySpan<byte> context = default) Parameters masterKey SecureMemory<byte> The 32-byte master key stored in secure memory. subKey SecureMemory<byte> The secure memory output buffer for the derived subkey (must be exactly 32 bytes). input ReadOnlySpan<byte> A 16-byte salt-like input used to calculate the subkey. context ReadOnlySpan<byte> An optional 16-byte context used for domain separation. If not provided, libsodium uses an internal default. Exceptions ArgumentException Thrown if any parameter has an invalid length. LibSodiumException Thrown if the native function fails. DeriveSubkey(SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, string) Derives a 32-byte subkey from a master key using the HChaCha20 function. This function is suitable for fast, deterministic key derivation with domain separation. public static void DeriveSubkey(SecureMemory<byte> masterKey, SecureMemory<byte> subKey, ReadOnlySpan<byte> input, string context) Parameters masterKey SecureMemory<byte> The 32-byte master key stored in secure memory. subKey SecureMemory<byte> The secure memory output buffer for the derived subkey (must be exactly 32 bytes). input ReadOnlySpan<byte> A 16-byte salt-like input used to calculate the subkey. context string A string whose UTF-8 representation must not exceed 16 bytes. This is used for domain separation. Exceptions ArgumentException Thrown if any parameter has an invalid length. LibSodiumException Thrown if the native function fails. DeriveSubkey(ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives a 32-byte subkey from a master key using the HChaCha20 function. This function is suitable for fast, deterministic key derivation with domain separation. public static void DeriveSubkey(ReadOnlySpan<byte> masterKey, Span<byte> subKey, ReadOnlySpan<byte> input, ReadOnlySpan<byte> context = default) Parameters masterKey ReadOnlySpan<byte> The 32-byte master key. subKey Span<byte> The output buffer for the derived subkey (must be exactly 32 bytes). input ReadOnlySpan<byte> A 16-byte salt-like input used to calculate the subkey. context ReadOnlySpan<byte> An optional 16-byte context used for domain separation. If not provided, libsodium uses an internal default. Exceptions ArgumentException Thrown if any parameter has an invalid length. LibSodiumException Thrown if the native function fails. DeriveSubkey(ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, string) Derives a 32-byte subkey from a master key using the HChaCha20 function. This function is suitable for fast, deterministic key derivation with domain separation. public static void DeriveSubkey(ReadOnlySpan<byte> masterKey, Span<byte> subKey, ReadOnlySpan<byte> input, string context) Parameters masterKey ReadOnlySpan<byte> The 32-byte master key. subKey Span<byte> The output buffer for the derived subkey (must be exactly 32 bytes). input ReadOnlySpan<byte> A 16-byte salt-like input used to calculate the subkey. context string A string whose UTF-8 representation must not exceed 16 bytes. This is used for domain separation. Exceptions ArgumentException Thrown if any parameter has an invalid length. LibSodiumException Thrown if the native function fails."
  },
  "api/LibSodium.CryptoHkdf.html": {
    "href": "api/LibSodium.CryptoHkdf.html",
    "title": "Class CryptoHkdf | LibSodium.Net",
    "summary": "Class CryptoHkdf Namespace LibSodium Assembly LibSodium.Net.dll Provides HKDF key derivation (RFC 5869) using SHA-256 or SHA-512. public static class CryptoHkdf Inheritance object CryptoHkdf Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields MinOkmLen Minimum length of output key material (OKM) in bytes (4). public const int MinOkmLen = 4 Field Value int Sha256MaxOkmLen Maximum length of output key material (OKM) for SHA256 in bytes (8160 = 32 * 255). public const int Sha256MaxOkmLen = 8160 Field Value int Sha256PrkLen Length of the pseudorandom key (PRK) for SHA256 in bytes (32). public const int Sha256PrkLen = 32 Field Value int Sha512MaxOkmLen Maximum length of output key material (OKM) for SHA512 in bytes (8160 = 64 * 255). public const int Sha512MaxOkmLen = 16320 Field Value int Sha512PrkLen Length of the pseudorandom key (PRK) for SHA256 in bytes (32). public const int Sha512PrkLen = 64 Field Value int Methods DeriveKey(HashAlgorithmName, SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives key material from input key material in one step using HKDF (RFC 5869). public static void DeriveKey(HashAlgorithmName hashAlgorithmName, SecureMemory<byte> ikm, SecureMemory<byte> okm, ReadOnlySpan<byte> salt, ReadOnlySpan<byte> info) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm SecureMemory<byte> Input keying material. okm SecureMemory<byte> Output buffer to receive the derived keying material (16–64 bytes). salt ReadOnlySpan<byte> Optional salt value (can be empty). info ReadOnlySpan<byte> Optional context and application-specific information. Exceptions ArgumentException Thrown if okm or internal buffers have invalid lengths. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. DeriveKey(HashAlgorithmName, Stream, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives key material from input key material in one step using HKDF (RFC 5869) from a stream. public static void DeriveKey(HashAlgorithmName hashAlgorithmName, Stream ikm, SecureMemory<byte> okm, ReadOnlySpan<byte> salt, ReadOnlySpan<byte> info) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material. okm SecureMemory<byte> Buffer to receive the output keying material. salt ReadOnlySpan<byte> Optional salt value. info ReadOnlySpan<byte> Optional application-specific information. Exceptions NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. DeriveKey(HashAlgorithmName, Stream, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives key material from input key material in one step using HKDF (RFC 5869) from a stream. public static void DeriveKey(HashAlgorithmName hashAlgorithmName, Stream ikm, Span<byte> okm, ReadOnlySpan<byte> salt, ReadOnlySpan<byte> info) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material. okm Span<byte> Buffer to receive the output keying material. salt ReadOnlySpan<byte> Optional salt value. info ReadOnlySpan<byte> Optional application-specific information. Exceptions NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. DeriveKey(HashAlgorithmName, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives key material from input key material in one step using HKDF (RFC 5869). public static void DeriveKey(HashAlgorithmName hashAlgorithmName, ReadOnlySpan<byte> ikm, Span<byte> okm, ReadOnlySpan<byte> salt, ReadOnlySpan<byte> info) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm ReadOnlySpan<byte> Input keying material. okm Span<byte> Output buffer to receive the derived keying material (16–64 bytes). salt ReadOnlySpan<byte> Optional salt value (can be empty). info ReadOnlySpan<byte> Optional context and application-specific information. Exceptions ArgumentException Thrown if okm or internal buffers have invalid lengths. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. DeriveKeyAsync(HashAlgorithmName, Stream, SecureMemory<byte>, ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, CancellationToken) Asynchronously derives key material from input key material in one step using HKDF (RFC 5869) from a stream. public static Task DeriveKeyAsync(HashAlgorithmName hashAlgorithmName, Stream ikm, SecureMemory<byte> okm, ReadOnlyMemory<byte> salt, ReadOnlyMemory<byte> info, CancellationToken cancellationToken = default) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material. okm SecureMemory<byte> Buffer to receive the output keying material. salt ReadOnlyMemory<byte> Optional salt value. info ReadOnlyMemory<byte> Optional application-specific information. cancellationToken CancellationToken Cancellation token. Returns Task Exceptions NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. DeriveKeyAsync(HashAlgorithmName, Stream, Memory<byte>, ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, CancellationToken) Asynchronously derives key material from input key material in one step using HKDF (RFC 5869) from a stream. public static Task DeriveKeyAsync(HashAlgorithmName hashAlgorithmName, Stream ikm, Memory<byte> okm, ReadOnlyMemory<byte> salt, ReadOnlyMemory<byte> info, CancellationToken cancellationToken = default) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material. okm Memory<byte> Buffer to receive the output keying material. salt ReadOnlyMemory<byte> Optional salt value. info ReadOnlyMemory<byte> Optional application-specific information. cancellationToken CancellationToken Cancellation token. Returns Task Exceptions NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. Expand(HashAlgorithmName, SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>) Performs the expand step of HKDF (RFC 5869), using the specified hash algorithm. public static void Expand(HashAlgorithmName hashAlgorithmName, SecureMemory<byte> prk, SecureMemory<byte> okm, ReadOnlySpan<byte> info) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). prk SecureMemory<byte> Pseudorandom key obtained from the extract step (32 or 64 bytes). okm SecureMemory<byte> Output buffer to receive the derived keying material (4–8160 or 16320 bytes). info ReadOnlySpan<byte> Optional context and application-specific information. Exceptions ArgumentOutOfRangeException Thrown if okm is not in valid range. ArgumentException Thrown if prk is not valid size for the selected hash. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. Expand(HashAlgorithmName, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Performs the expand step of HKDF (RFC 5869), using the specified hash algorithm. public static void Expand(HashAlgorithmName hashAlgorithmName, ReadOnlySpan<byte> prk, Span<byte> okm, ReadOnlySpan<byte> info) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). prk ReadOnlySpan<byte> Pseudorandom key obtained from the extract step (32 or 64 bytes). okm Span<byte> Output buffer to receive the derived keying material (4–8160 or 16320 bytes). info ReadOnlySpan<byte> Optional context and application-specific information. Exceptions ArgumentOutOfRangeException Thrown if okm is not in valid range. ArgumentException Thrown if prk is not valid size for the selected hash. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. Extract(HashAlgorithmName, SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Performs the extract step of HKDF (RFC 5869), using the specified hash algorithm. public static void Extract(HashAlgorithmName hashAlgorithmName, SecureMemory<byte> ikm, ReadOnlySpan<byte> salt, SecureMemory<byte> prk) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm SecureMemory<byte> Input keying material. salt ReadOnlySpan<byte> Optional salt value (can be empty). prk SecureMemory<byte> Buffer to receive the pseudorandom key (32 bytes for SHA256 and 64 bytes for SHA512). Exceptions ArgumentException Thrown if prk is not exactly the required size. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. Extract(HashAlgorithmName, Stream, ReadOnlySpan<byte>, SecureMemory<byte>) Performs the extract step of HKDF (RFC 5869) using a stream as input keying material. public static void Extract(HashAlgorithmName hashAlgorithmName, Stream ikm, ReadOnlySpan<byte> salt, SecureMemory<byte> prk) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material (IKM). salt ReadOnlySpan<byte> Optional salt value (can be empty). prk SecureMemory<byte> Buffer to receive the pseudorandom key (32 bytes for SHA256 and 64 bytes for SHA512). Exceptions ArgumentNullException Thrown if ikm is null. ArgumentException Thrown if prk length is incorrect. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. Extract(HashAlgorithmName, Stream, ReadOnlySpan<byte>, Span<byte>) Performs the extract step of HKDF (RFC 5869) using a stream as input keying material. public static void Extract(HashAlgorithmName hashAlgorithmName, Stream ikm, ReadOnlySpan<byte> salt, Span<byte> prk) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material (IKM). salt ReadOnlySpan<byte> Optional salt value (can be empty). prk Span<byte> Buffer to receive the pseudorandom key (32 bytes for SHA256 and 64 bytes for SHA512). Exceptions ArgumentNullException Thrown if ikm is null. ArgumentException Thrown if prk length is incorrect. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. Extract(HashAlgorithmName, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>) Performs the extract step of HKDF (RFC 5869), using the specified hash algorithm. public static void Extract(HashAlgorithmName hashAlgorithmName, ReadOnlySpan<byte> ikm, ReadOnlySpan<byte> salt, Span<byte> prk) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm ReadOnlySpan<byte> Input keying material. salt ReadOnlySpan<byte> Optional salt value (can be empty). prk Span<byte> Buffer to receive the pseudorandom key (32 bytes for SHA256 and 64 bytes for SHA512). Exceptions ArgumentException Thrown if prk is not exactly the required size. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. ExtractAsync(HashAlgorithmName, Stream, ReadOnlyMemory<byte>, SecureMemory<byte>, CancellationToken) Asynchronously performs the extract step of HKDF (RFC 5869) using a stream as input keying material. public static Task ExtractAsync(HashAlgorithmName hashAlgorithmName, Stream ikm, ReadOnlyMemory<byte> salt, SecureMemory<byte> prk, CancellationToken cancellationToken = default) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material (IKM). salt ReadOnlyMemory<byte> Optional salt value (can be empty). prk SecureMemory<byte> Buffer to receive the pseudorandom key (32 bytes for SHA256 and 64 bytes for SHA512). cancellationToken CancellationToken Cancellation token. Returns Task Exceptions ArgumentNullException Thrown if ikm is null. ArgumentException Thrown if prk length is incorrect. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails. ExtractAsync(HashAlgorithmName, Stream, ReadOnlyMemory<byte>, Memory<byte>, CancellationToken) Asynchronously performs the extract step of HKDF (RFC 5869) using a stream as input keying material. public static Task ExtractAsync(HashAlgorithmName hashAlgorithmName, Stream ikm, ReadOnlyMemory<byte> salt, Memory<byte> prk, CancellationToken cancellationToken = default) Parameters hashAlgorithmName HashAlgorithmName Hash algorithm to use (SHA-256 or SHA-512). ikm Stream Stream of input keying material (IKM). salt ReadOnlyMemory<byte> Optional salt value (can be empty). prk Memory<byte> Buffer to receive the pseudorandom key (32 bytes for SHA256 and 64 bytes for SHA512). cancellationToken CancellationToken Cancellation token. Returns Task Exceptions ArgumentNullException Thrown if ikm is null. ArgumentException Thrown if prk length is incorrect. NotSupportedException Thrown if the hash algorithm is unsupported. LibSodiumException Thrown if the underlying native call fails."
  },
  "api/LibSodium.CryptoHmacSha256.html": {
    "href": "api/LibSodium.CryptoHmacSha256.html",
    "title": "Class CryptoHmacSha256 | LibSodium.Net",
    "summary": "Class CryptoHmacSha256 Namespace LibSodium Assembly LibSodium.Net.dll Computes and verifies HMAC-SHA-256 message authentication codes. public static class CryptoHmacSha256 Inheritance object CryptoHmacSha256 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int MacLen Length of the HMAC output in bytes (32). public static readonly int MacLen Field Value int Methods ComputeMac(SecureMemory<byte>, Stream, Span<byte>) Computes an HMAC-SHA-256 authentication code from a stream. public static void ComputeMac(SecureMemory<byte> key, Stream messageStream, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 32-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(SecureMemory<byte>, ReadOnlySpan<byte>, Span<byte>) Computes an HMAC-SHA-256 authentication code for the given message. public static int ComputeMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 32-byte MAC. Returns int The length of the MAC written (always 32). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, Stream, Span<byte>) Computes an HMAC-SHA-256 authentication code from a stream. public static void ComputeMac(ReadOnlySpan<byte> key, Stream messageStream, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 32-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>) Computes an HMAC-SHA-256 authentication code for the given message. public static int ComputeMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 32-byte MAC. Returns int The length of the MAC written (always 32). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(SecureMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes an HMAC-SHA-256 authentication code from a stream. public static Task ComputeMacAsync(SecureMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(ReadOnlyMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes an HMAC-SHA-256 authentication code from a stream. public static Task ComputeMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. CreateIncrementalMac(SecureMemory<byte>) Creates an incremental hash object using the HMAC-SHA256 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(SecureMemory<byte> key) Parameters key SecureMemory<byte> The cryptographic key (32 bytes) to use for the HMAC-SHA256 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the HMAC-SHA256 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the HMAC-SHA256 hash incrementally by processing data in chunks. This is useful for scenarios where the data to be hashed is too large to fit in memory or is received in a streaming fashion. CreateIncrementalMac(ReadOnlySpan<byte>) Creates an incremental hash object using the HMAC-SHA256 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(ReadOnlySpan<byte> key) Parameters key ReadOnlySpan<byte> The cryptographic key (32 bytes) to use for the HMAC-SHA256 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the HMAC-SHA256 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the HMAC-SHA256 hash incrementally by processing data in chunks. This is useful for scenarios where the data to be hashed is too large to fit in memory or is received in a streaming fashion. GenerateKey(SecureMemory<byte>) Generates a random 32-byte key suitable for HMAC-SHA-256. public static void GenerateKey(SecureMemory<byte> key) Parameters key SecureMemory<byte> A buffer to receive the generated key (must be 32 bytes). GenerateKey(Span<byte>) Generates a random 32-byte key suitable for HMAC-SHA-256. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> A buffer to receive the generated key (must be 32 bytes). VerifyMac(SecureMemory<byte>, Stream, ReadOnlySpan<byte>) Verifies an HMAC-SHA-256 authentication code from a stream. public static bool VerifyMac(SecureMemory<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies an HMAC-SHA-256 authentication code against a given message. public static bool VerifyMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, Stream, ReadOnlySpan<byte>) Verifies an HMAC-SHA-256 authentication code from a stream. public static bool VerifyMac(ReadOnlySpan<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies an HMAC-SHA-256 authentication code against a given message. public static bool VerifyMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. ArgumentException Thrown if key or mac has an invalid length. VerifyMacAsync(SecureMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies an HMAC-SHA-256 authentication code from a stream. public static Task<bool> VerifyMacAsync(SecureMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false. VerifyMacAsync(ReadOnlyMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies an HMAC-SHA-256 authentication code from a stream. public static Task<bool> VerifyMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false."
  },
  "api/LibSodium.CryptoHmacSha512.html": {
    "href": "api/LibSodium.CryptoHmacSha512.html",
    "title": "Class CryptoHmacSha512 | LibSodium.Net",
    "summary": "Class CryptoHmacSha512 Namespace LibSodium Assembly LibSodium.Net.dll Computes and verifies HMAC-SHA-512 message authentication codes. public static class CryptoHmacSha512 Inheritance object CryptoHmacSha512 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int MacLen Length of the HMAC output in bytes (64). public static readonly int MacLen Field Value int Methods ComputeMac(SecureMemory<byte>, Stream, Span<byte>) Computes an HMAC-SHA-512 authentication code from a stream. public static void ComputeMac(SecureMemory<byte> key, Stream messageStream, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 64-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(SecureMemory<byte>, ReadOnlySpan<byte>, Span<byte>) Computes an HMAC-SHA-512 authentication code for the given message. public static int ComputeMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 64-byte MAC. Returns int The length of the MAC written (always 64). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, Stream, Span<byte>) Computes an HMAC-SHA-512 authentication code from a stream. public static void ComputeMac(ReadOnlySpan<byte> key, Stream messageStream, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 64-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>) Computes an HMAC-SHA-512 authentication code for the given message. public static int ComputeMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 64-byte MAC. Returns int The length of the MAC written (always 64). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(SecureMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes an HMAC-SHA-512 authentication code from a stream. public static Task ComputeMacAsync(SecureMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 64-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(ReadOnlyMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes an HMAC-SHA-512 authentication code from a stream. public static Task ComputeMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 64-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. CreateIncrementalMac(SecureMemory<byte>) Creates an incremental hash object using the HMAC-SHA512 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(SecureMemory<byte> key) Parameters key SecureMemory<byte> The cryptographic key (64 bytes) to use for the HMAC-SHA512 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the HMAC-SHA512 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the HMAC-SHA512 hash incrementally by processing data in chunks. CreateIncrementalMac(ReadOnlySpan<byte>) Creates an incremental hash object using the HMAC-SHA512 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(ReadOnlySpan<byte> key) Parameters key ReadOnlySpan<byte> The cryptographic key (64 bytes) to use for the HMAC-SHA512 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the HMAC-SHA512 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the HMAC-SHA512 hash incrementally by processing data in chunks. GenerateKey(SecureMemory<byte>) Generates a random 32-byte key suitable for HMAC-SHA-512. public static void GenerateKey(SecureMemory<byte> key) Parameters key SecureMemory<byte> A buffer to receive the generated key (must be 32 bytes). GenerateKey(Span<byte>) Generates a random 32-byte key suitable for HMAC-SHA-512. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> A buffer to receive the generated key (must be 32 bytes). VerifyMac(SecureMemory<byte>, Stream, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512 authentication code from a stream. public static bool VerifyMac(SecureMemory<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 64-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512 authentication code against a given message. public static bool VerifyMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 64-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, Stream, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512 authentication code from a stream. public static bool VerifyMac(ReadOnlySpan<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 64-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512 authentication code against a given message. public static bool VerifyMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 64-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMacAsync(SecureMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies an HMAC-SHA-512 authentication code from a stream. public static Task<bool> VerifyMacAsync(SecureMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 64-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMacAsync(ReadOnlyMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies an HMAC-SHA-512 authentication code from a stream. public static Task<bool> VerifyMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 64-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length."
  },
  "api/LibSodium.CryptoHmacSha512_256.html": {
    "href": "api/LibSodium.CryptoHmacSha512_256.html",
    "title": "Class CryptoHmacSha512_256 | LibSodium.Net",
    "summary": "Class CryptoHmacSha512_256 Namespace LibSodium Assembly LibSodium.Net.dll Computes and verifies HMAC-SHA-512/256 message authentication codes. public static class CryptoHmacSha512_256 Inheritance object CryptoHmacSha512_256 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int MacLen Length of the HMAC output in bytes (32). public static readonly int MacLen Field Value int Methods ComputeMac(SecureMemory<byte>, Stream, Span<byte>) Computes an HMAC-SHA-512/256 authentication code from a stream. public static void ComputeMac(SecureMemory<byte> key, Stream messageStream, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 32-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(SecureMemory<byte>, ReadOnlySpan<byte>, Span<byte>) Computes an HMAC-SHA-512/256 authentication code for the given message. public static int ComputeMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 32-byte MAC. Returns int The length of the MAC written (always 32). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, Stream, Span<byte>) Computes an HMAC-SHA-512/256 authentication code from a stream. public static void ComputeMac(ReadOnlySpan<byte> key, Stream messageStream, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 32-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>) Computes an HMAC-SHA-512/256 authentication code for the given message. public static int ComputeMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 32-byte MAC. Returns int The length of the MAC written (always 32). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(SecureMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes an HMAC-SHA-512/256 authentication code from a stream. public static Task ComputeMacAsync(SecureMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(ReadOnlyMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes an HMAC-SHA-512/256 authentication code from a stream. public static Task ComputeMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. CreateIncrementalMac(SecureMemory<byte>) Creates an incremental hash object using the HMAC-SHA512/256 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(SecureMemory<byte> key) Parameters key SecureMemory<byte> The cryptographic key (64 bytes) to use for the HMAC-SHA512/256 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the HMAC-SHA512/256 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the HMAC-SHA512/256 hash incrementally by processing data in chunks. CreateIncrementalMac(ReadOnlySpan<byte>) Creates an incremental hash object using the HMAC-SHA512/256 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(ReadOnlySpan<byte> key) Parameters key ReadOnlySpan<byte> The cryptographic key (64 bytes) to use for the HMAC-SHA512/256 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the HMAC-SHA512/256 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the HMAC-SHA512/256 hash incrementally by processing data in chunks. GenerateKey(SecureMemory<byte>) Generates a random 32-byte key suitable for HMAC-SHA-512/256. public static void GenerateKey(SecureMemory<byte> key) Parameters key SecureMemory<byte> A buffer to receive the generated key (must be 32 bytes). GenerateKey(Span<byte>) Generates a random 32-byte key suitable for HMAC-SHA-512/256. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> A buffer to receive the generated key (must be 32 bytes). VerifyMac(SecureMemory<byte>, Stream, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512/256 authentication code from a stream. public static bool VerifyMac(SecureMemory<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512/256 authentication code against a given message. public static bool VerifyMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, Stream, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512/256 authentication code from a stream. public static bool VerifyMac(ReadOnlySpan<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies an HMAC-SHA-512/256 authentication code against a given message. public static bool VerifyMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 32-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMacAsync(SecureMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies an HMAC-SHA-512/256 authentication code from a stream. public static Task<bool> VerifyMacAsync(SecureMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMacAsync(ReadOnlyMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies an HMAC-SHA-512/256 authentication code from a stream. public static Task<bool> VerifyMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 32-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length."
  },
  "api/LibSodium.CryptoKeyDerivation.html": {
    "href": "api/LibSodium.CryptoKeyDerivation.html",
    "title": "Class CryptoKeyDerivation | LibSodium.Net",
    "summary": "Class CryptoKeyDerivation Namespace LibSodium Assembly LibSodium.Net.dll Provides deterministic key derivation using libsodium's crypto_kdf_* API, based on the BLAKE2b hash function. public static class CryptoKeyDerivation Inheritance object CryptoKeyDerivation Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields ContextLen Length of the context in bytes (8). public const int ContextLen = 8 Field Value int MasterKeyLen Length of the master key in bytes (32). public const int MasterKeyLen = 32 Field Value int MaxSubkeyLen Maximum length of a derived subkey (64). public const int MaxSubkeyLen = 64 Field Value int MinSubkeyLen Minimum length of a derived subkey (16). public const int MinSubkeyLen = 16 Field Value int Methods DeriveSubkey(SecureMemory<byte>, SecureMemory<byte>, ulong, ReadOnlySpan<byte>) Deterministically derives a subkey from a master key, context, and subkey ID. Uses the BLAKE2b hash function internally. public static void DeriveSubkey(SecureMemory<byte> masterKey, SecureMemory<byte> subkey, ulong subkeyId, ReadOnlySpan<byte> context) Parameters masterKey SecureMemory<byte> The master key (32 bytes). subkey SecureMemory<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context ReadOnlySpan<byte> 8-byte context describing the usage. Exceptions ArgumentException Thrown when subkey is out of bounds, context is not 8 bytes, or masterKey is not 32 bytes. LibSodiumException Thrown if the native key derivation fails. DeriveSubkey(SecureMemory<byte>, SecureMemory<byte>, ulong, string) Deterministically derives a subkey from a master key, using a context string whose UTF-8 representation is at most 8 bytes, and a subkey ID. If the string is shorter, it is padded with zeros. Uses the BLAKE2b hash function internally. public static void DeriveSubkey(SecureMemory<byte> masterKey, SecureMemory<byte> subkey, ulong subkeyId, string context) Parameters masterKey SecureMemory<byte> The master key (32 bytes). subkey SecureMemory<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context string A string whose UTF-8 representation must be at most 8 bytes and describes the usage context. Exceptions ArgumentNullException Thrown when context is null. ArgumentException Thrown when context exceeds 8 UTF-8 bytes, or subkey or masterKey are of invalid length. LibSodiumException Thrown if the native key derivation fails. DeriveSubkey(SecureMemory<byte>, ulong, ReadOnlySpan<byte>, SecureMemory<byte>) Deterministically derives a subkey from a master key, context, and subkey ID. Uses the BLAKE2b hash function internally. [Obsolete(\"Use the other overload instead. This will be removed in a future version.\")] public static void DeriveSubkey(SecureMemory<byte> subkey, ulong subkeyId, ReadOnlySpan<byte> context, SecureMemory<byte> masterKey) Parameters subkey SecureMemory<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context ReadOnlySpan<byte> 8-byte context describing the usage. masterKey SecureMemory<byte> The master key (32 bytes). Exceptions ArgumentException Thrown when subkey is out of bounds, context is not 8 bytes, or masterKey is not 32 bytes. LibSodiumException Thrown if the native key derivation fails. DeriveSubkey(SecureMemory<byte>, ulong, string, SecureMemory<byte>) Deterministically derives a subkey from a master key, using a context string whose UTF-8 representation is at most 8 bytes, and a subkey ID. If the string is shorter, it is padded with zeros. Uses the BLAKE2b hash function internally. [Obsolete(\"Use the other overload instead. This will be removed in a future version.\")] public static void DeriveSubkey(SecureMemory<byte> subkey, ulong subkeyId, string context, SecureMemory<byte> masterKey) Parameters subkey SecureMemory<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context string A string whose UTF-8 representation must be at most 8 bytes and describes the usage context. masterKey SecureMemory<byte> The master key (32 bytes). Exceptions ArgumentNullException Thrown when context is null. ArgumentException Thrown when context exceeds 8 UTF-8 bytes, or subkey or masterKey are of invalid length. LibSodiumException Thrown if the native key derivation fails. DeriveSubkey(ReadOnlySpan<byte>, Span<byte>, ulong, ReadOnlySpan<byte>) Deterministically derives a subkey from a master key, context, and subkey ID. Uses the BLAKE2b hash function internally. public static void DeriveSubkey(ReadOnlySpan<byte> masterKey, Span<byte> subkey, ulong subkeyId, ReadOnlySpan<byte> context) Parameters masterKey ReadOnlySpan<byte> The master key (32 bytes). subkey Span<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context ReadOnlySpan<byte> 8-byte context describing the usage. Exceptions ArgumentException Thrown when subkey is out of bounds, context is not 8 bytes, or masterKey is not 32 bytes. LibSodiumException Thrown if the native key derivation fails. DeriveSubkey(ReadOnlySpan<byte>, Span<byte>, ulong, string) Deterministically derives a subkey from a master key, using a context string whose UTF-8 representation is at most 8 bytes, and a subkey ID. If the string is shorter, it is padded with zeros. Uses the BLAKE2b hash function internally. public static void DeriveSubkey(ReadOnlySpan<byte> masterKey, Span<byte> subkey, ulong subkeyId, string context) Parameters masterKey ReadOnlySpan<byte> The master key (32 bytes). subkey Span<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context string A string whose UTF-8 representation must be at most 8 bytes and describes the usage context. Exceptions ArgumentNullException Thrown when context is null. ArgumentException Thrown when context exceeds 8 UTF-8 bytes, or subkey or masterKey are of invalid length. LibSodiumException Thrown if the native key derivation fails. DeriveSubkey(Span<byte>, ulong, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Deterministically derives a subkey from a master key, context, and subkey ID. Uses the BLAKE2b hash function internally. [Obsolete(\"Use the other overload instead. This will be removed in a future version.\")] public static void DeriveSubkey(Span<byte> subkey, ulong subkeyId, ReadOnlySpan<byte> context, ReadOnlySpan<byte> masterKey) Parameters subkey Span<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context ReadOnlySpan<byte> 8-byte context describing the usage. masterKey ReadOnlySpan<byte> The master key (32 bytes). Exceptions ArgumentException Thrown when subkey is out of bounds, context is not 8 bytes, or masterKey is not 32 bytes. LibSodiumException Thrown if the native key derivation fails. DeriveSubkey(Span<byte>, ulong, string, ReadOnlySpan<byte>) Deterministically derives a subkey from a master key, using a context string whose UTF-8 representation is at most 8 bytes, and a subkey ID. If the string is shorter, it is padded with zeros. Uses the BLAKE2b hash function internally. [Obsolete(\"Use the other overload instead. This will be removed in a future version.\")] public static void DeriveSubkey(Span<byte> subkey, ulong subkeyId, string context, ReadOnlySpan<byte> masterKey) Parameters subkey Span<byte> The buffer where the derived subkey will be written. Its length must be between 16 and 64 bytes. subkeyId ulong The identifier for the subkey (application-defined). context string A string whose UTF-8 representation must be at most 8 bytes and describes the usage context. masterKey ReadOnlySpan<byte> The master key (32 bytes). Exceptions ArgumentNullException Thrown when context is null. ArgumentException Thrown when context exceeds 8 UTF-8 bytes, or subkey or masterKey are of invalid length. LibSodiumException Thrown if the native key derivation fails. GenerateMasterKey(SecureMemory<byte>) Fills the given buffer with a new random master key (32 bytes). public static void GenerateMasterKey(SecureMemory<byte> masterKey) Parameters masterKey SecureMemory<byte> The buffer to fill. Must be 32 bytes. Exceptions ArgumentException Thrown when masterKey is not 32 bytes. GenerateMasterKey(Span<byte>) Fills the given buffer with a new random master key (32 bytes). public static void GenerateMasterKey(Span<byte> masterKey) Parameters masterKey Span<byte> The buffer to fill. Must be 32 bytes. Exceptions ArgumentException Thrown when masterKey is not 32 bytes."
  },
  "api/LibSodium.CryptoKeyExchange.html": {
    "href": "api/LibSodium.CryptoKeyExchange.html",
    "title": "Class CryptoKeyExchange | LibSodium.Net",
    "summary": "Class CryptoKeyExchange Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for secure, fast, and simple key exchange using libsodium's crypto_kx API. Allows two parties to derive shared session keys securely. public static class CryptoKeyExchange Inheritance object CryptoKeyExchange Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks \uD83E\uDDC2 Based on libsodium's crypto_kx API: https://doc.libsodium.org/key_exchange Fields PublicKeyLen Length of the public key in bytes (32). public const int PublicKeyLen = 32 Field Value int SecretKeyLen Length of the secret (private) key in bytes (32). public const int SecretKeyLen = 32 Field Value int SeedLen Length of the seed used for deterministic key pair generation (32 bytes). public const int SeedLen = 32 Field Value int SessionKeyLen Length of derived session keys in bytes (32). public const int SessionKeyLen = 32 Field Value int Methods DeriveClientSessionKeys(SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>) Derives client-side session keys for secure communication with a server. The generated keys allow secure and authenticated data exchange. public static void DeriveClientSessionKeys(SecureMemory<byte> rx, SecureMemory<byte> tx, ReadOnlySpan<byte> clientPk, SecureMemory<byte> clientSk, ReadOnlySpan<byte> serverPk) Parameters rx SecureMemory<byte> Buffer to receive the client's receiving key (used to decrypt data from server). Must be exactly 32 bytes. tx SecureMemory<byte> Buffer to receive the client's transmitting key (used to encrypt data sent to server). Must be exactly 32 bytes. clientPk ReadOnlySpan<byte> Client's public key (32 bytes). clientSk SecureMemory<byte> Client's secret key (32 bytes). serverPk ReadOnlySpan<byte> Server's public key (32 bytes). Exceptions ArgumentException Thrown if any provided buffer (rx, tx, clientPk, clientSk, serverPk) is not exactly 32 bytes. LibSodiumException Thrown if client-side session key derivation fails internally. DeriveClientSessionKeys(Span<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives client-side session keys for secure communication with a server. The generated keys allow secure and authenticated data exchange. public static void DeriveClientSessionKeys(Span<byte> rx, Span<byte> tx, ReadOnlySpan<byte> clientPk, ReadOnlySpan<byte> clientSk, ReadOnlySpan<byte> serverPk) Parameters rx Span<byte> Buffer to receive the client's receiving key (used to decrypt data from server). Must be exactly 32 bytes. tx Span<byte> Buffer to receive the client's transmitting key (used to encrypt data sent to server). Must be exactly 32 bytes. clientPk ReadOnlySpan<byte> Client's public key (32 bytes). clientSk ReadOnlySpan<byte> Client's secret key (32 bytes). serverPk ReadOnlySpan<byte> Server's public key (32 bytes). Exceptions ArgumentException Thrown if any provided buffer (rx, tx, clientPk, clientSk, serverPk) is not exactly 32 bytes. LibSodiumException Thrown if client-side session key derivation fails internally. DeriveServerSessionKeys(SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>) Derives server-side session keys for secure communication with a client. The generated keys allow secure and authenticated data exchange. public static void DeriveServerSessionKeys(SecureMemory<byte> rx, SecureMemory<byte> tx, ReadOnlySpan<byte> serverPk, SecureMemory<byte> serverSk, ReadOnlySpan<byte> clientPk) Parameters rx SecureMemory<byte> Buffer to receive the server's receiving key (used to decrypt data from client). Must be exactly 32 bytes. tx SecureMemory<byte> Buffer to receive the server's transmitting key (used to encrypt data sent to client). Must be exactly 32 bytes. serverPk ReadOnlySpan<byte> Server's public key (32 bytes). serverSk SecureMemory<byte> Server's secret key (32 bytes). clientPk ReadOnlySpan<byte> Client's public key (32 bytes). Exceptions ArgumentException Thrown if any provided buffer (rx, tx, serverPk, serverSk, clientPk) is not exactly 32 bytes. LibSodiumException Thrown if server-side session key derivation fails internally. DeriveServerSessionKeys(Span<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Derives server-side session keys for secure communication with a client. The generated keys allow secure and authenticated data exchange. public static void DeriveServerSessionKeys(Span<byte> rx, Span<byte> tx, ReadOnlySpan<byte> serverPk, ReadOnlySpan<byte> serverSk, ReadOnlySpan<byte> clientPk) Parameters rx Span<byte> Buffer to receive the server's receiving key (used to decrypt data from client). Must be exactly 32 bytes. tx Span<byte> Buffer to receive the server's transmitting key (used to encrypt data sent to client). Must be exactly 32 bytes. serverPk ReadOnlySpan<byte> Server's public key (32 bytes). serverSk ReadOnlySpan<byte> Server's secret key (32 bytes). clientPk ReadOnlySpan<byte> Client's public key (32 bytes). Exceptions ArgumentException Thrown if any provided buffer (rx, tx, serverPk, serverSk, clientPk) is not exactly 32 bytes. LibSodiumException Thrown if server-side session key derivation fails internally. GenerateKeyPair(Span<byte>, SecureMemory<byte>) Generates a new random key pair suitable for key exchange (crypto_kx). public static void GenerateKeyPair(Span<byte> publicKey, SecureMemory<byte> secretKey) Parameters publicKey Span<byte> Buffer to receive the generated public key. Must be exactly 32 bytes. secretKey SecureMemory<byte> Buffer to receive the generated secret key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if publicKey or secretKey are not exactly 32 bytes. LibSodiumException Thrown if key pair generation fails internally. GenerateKeyPair(Span<byte>, Span<byte>) Generates a new random key pair suitable for key exchange (crypto_kx). public static void GenerateKeyPair(Span<byte> publicKey, Span<byte> secretKey) Parameters publicKey Span<byte> Buffer to receive the generated public key. Must be exactly 32 bytes. secretKey Span<byte> Buffer to receive the generated secret key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if publicKey or secretKey are not exactly 32 bytes. LibSodiumException Thrown if key pair generation fails internally. GenerateKeyPairDeterministically(Span<byte>, SecureMemory<byte>, SecureMemory<byte>) Deterministically generates a key pair from a provided seed. This method always produces the same key pair for the same seed. public static void GenerateKeyPairDeterministically(Span<byte> publicKey, SecureMemory<byte> secretKey, SecureMemory<byte> seed) Parameters publicKey Span<byte> Buffer to receive the derived public key. Must be exactly 32 bytes. secretKey SecureMemory<byte> Buffer to receive the derived secret key. Must be exactly 32 bytes. seed SecureMemory<byte> Seed used for deterministic generation. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if publicKey, secretKey, or seed are not exactly 32 bytes. LibSodiumException Thrown if deterministic key pair generation fails internally. GenerateKeyPairDeterministically(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Deterministically generates a key pair from a provided seed. This method always produces the same key pair for the same seed. public static void GenerateKeyPairDeterministically(Span<byte> publicKey, Span<byte> secretKey, ReadOnlySpan<byte> seed) Parameters publicKey Span<byte> Buffer to receive the derived public key. Must be exactly 32 bytes. secretKey Span<byte> Buffer to receive the derived secret key. Must be exactly 32 bytes. seed ReadOnlySpan<byte> Seed used for deterministic generation. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if publicKey, secretKey, or seed are not exactly 32 bytes. LibSodiumException Thrown if deterministic key pair generation fails internally."
  },
  "api/LibSodium.CryptoOneTimeAuth.html": {
    "href": "api/LibSodium.CryptoOneTimeAuth.html",
    "title": "Class CryptoOneTimeAuth | LibSodium.Net",
    "summary": "Class CryptoOneTimeAuth Namespace LibSodium Assembly LibSodium.Net.dll Computes and verifies Poly1305 one-time authentication codes. public static class CryptoOneTimeAuth Inheritance object CryptoOneTimeAuth Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Based on libsodium's crypto_onetimeauth API: https://doc.libsodium.org/advanced/poly1305 Fields KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int MacLen Length of the MAC output in bytes (16). public static readonly int MacLen Field Value int Methods ComputeMac(SecureMemory<byte>, Stream, Span<byte>) Computes a Poly1305 authentication tag from a stream. public static void ComputeMac(SecureMemory<byte> key, Stream messageStream, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 16-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(SecureMemory<byte>, ReadOnlySpan<byte>, Span<byte>) Computes a Poly1305 authentication tag for the given message. public static int ComputeMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 16-byte MAC. Returns int The number of bytes written to mac (always 16). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, Stream, Span<byte>) Computes a Poly1305 authentication tag from a stream. public static void ComputeMac(ReadOnlySpan<byte> key, Stream messageStream, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Span<byte> A buffer to receive the 16-byte MAC. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>) Computes a Poly1305 authentication tag for the given message. public static int ComputeMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, Span<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to authenticate. mac Span<byte> A buffer to receive the 16-byte MAC. Returns int The number of bytes written to mac (always 16). Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(SecureMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes a Poly1305 authentication tag from a stream. public static Task ComputeMacAsync(SecureMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 16-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. ComputeMacAsync(ReadOnlyMemory<byte>, Stream, Memory<byte>, CancellationToken) Asynchronously computes a Poly1305 authentication tag from a stream. public static Task ComputeMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, Memory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac Memory<byte> A buffer to receive the 16-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task A task that represents the asynchronous operation. Exceptions ArgumentException Thrown if key or mac has an invalid length. LibSodiumException Thrown if the MAC computation fails internally. CreateIncrementalMac(SecureMemory<byte>) Creates an incremental hash object using the Poly1305 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(SecureMemory<byte> key) Parameters key SecureMemory<byte> The cryptographic key (32 bytes) to use for the Poly1305 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the Poly1305 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the Poly1305 hash incrementally by processing data in chunks. CreateIncrementalMac(ReadOnlySpan<byte>) Creates an incremental hash object using the Poly1305 algorithm. public static ICryptoIncrementalHash CreateIncrementalMac(ReadOnlySpan<byte> key) Parameters key ReadOnlySpan<byte> The cryptographic key (32 bytes) to use for the Poly1305 computation. Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of the Poly1305 hash. Remarks The returned ICryptoIncrementalHash can be used to compute the Poly1305 hash incrementally by processing data in chunks. GenerateKey(SecureMemory<byte>) Generates a random 32-byte key suitable for Poly1305. public static void GenerateKey(SecureMemory<byte> key) Parameters key SecureMemory<byte> A buffer to receive the generated key (must be 32 bytes). GenerateKey(Span<byte>) Generates a random 32-byte key suitable for Poly1305. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> A buffer to receive the generated key (must be 32 bytes). VerifyMac(SecureMemory<byte>, Stream, ReadOnlySpan<byte>) Verifies a Poly1305 authentication tag from a stream. public static bool VerifyMac(SecureMemory<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 16-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies a Poly1305 authentication tag against a given message. public static bool VerifyMac(SecureMemory<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key SecureMemory<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 16-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, Stream, ReadOnlySpan<byte>) Verifies a Poly1305 authentication tag from a stream. public static bool VerifyMac(ReadOnlySpan<byte> key, Stream messageStream, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlySpan<byte> The expected 16-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies a Poly1305 authentication tag against a given message. public static bool VerifyMac(ReadOnlySpan<byte> key, ReadOnlySpan<byte> message, ReadOnlySpan<byte> mac) Parameters key ReadOnlySpan<byte> A 32-byte secret key. message ReadOnlySpan<byte> The message to verify. mac ReadOnlySpan<byte> The expected 16-byte MAC. Returns bool true if the MAC is valid; otherwise, false. Exceptions ArgumentException Thrown if key or mac has an invalid length. VerifyMacAsync(SecureMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies a Poly1305 authentication tag from a stream. public static Task<bool> VerifyMacAsync(SecureMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 16-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false. VerifyMacAsync(ReadOnlyMemory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously verifies a Poly1305 authentication tag from a stream. public static Task<bool> VerifyMacAsync(ReadOnlyMemory<byte> key, Stream messageStream, ReadOnlyMemory<byte> mac, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> A 32-byte secret key. messageStream Stream A stream containing the message. mac ReadOnlyMemory<byte> The expected 16-byte MAC. cancellationToken CancellationToken A token to cancel the operation. Returns Task<bool> true if the MAC is valid; otherwise, false."
  },
  "api/LibSodium.CryptoPasswordHashArgon.html": {
    "href": "api/LibSodium.CryptoPasswordHashArgon.html",
    "title": "Class CryptoPasswordHashArgon | LibSodium.Net",
    "summary": "Class CryptoPasswordHashArgon Namespace LibSodium Assembly LibSodium.Net.dll Provides password hashing and key derivation using Argon2. public static class CryptoPasswordHashArgon Inheritance object CryptoPasswordHashArgon Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Based on libsodium's crypto_pwhash API: https://doc.libsodium.org/password_hashing Fields EncodedLen Maximum length of the encoded hash string (includes null terminator) (128). public const int EncodedLen = 128 Field Value int InteractiveIterations Recommended iterations for interactive use (2). public const int InteractiveIterations = 2 Field Value int InteractiveMemoryLen Recommended memory usage for interactive use (64Mb). public const int InteractiveMemoryLen = 67108864 Field Value int MinIterations Minimum number of iterations for key derivation (1). public const int MinIterations = 1 Field Value int MinKeyLen Minimum allowed length in bytes for the derived key (16). public const int MinKeyLen = 16 Field Value int MinMemoryLen Minimum memory usage in bytes (8k). public const int MinMemoryLen = 8192 Field Value int MinPasswordLen Minimum allowed password length in bytes (0). public const int MinPasswordLen = 0 Field Value int ModerateIterations Recommended iterations for moderate use (3). public const int ModerateIterations = 3 Field Value int ModerateMemoryLen Recommended memory usage for moderate use (256Mb). public const int ModerateMemoryLen = 268435456 Field Value int Prefix Prefix for the encoded hash string (e.g. \"\\(argon2id\\)\"). public const string Prefix = \"$argon2id$\" Field Value string SaltLen Length of the salt in bytes (16). public const int SaltLen = 16 Field Value int SensitiveIterations Recommended iterations for sensitive use (4). public const int SensitiveIterations = 4 Field Value int SensitiveMemoryLen Recommended memory usage for sensitive use (1Gb). public const int SensitiveMemoryLen = 1073741824 Field Value int Methods DeriveKey(SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, int, int, PasswordHashArgonAlgorithm) Derives a secret key from a password and salt using Argon2. public static void DeriveKey(SecureMemory<byte> key, SecureMemory<byte> password, ReadOnlySpan<byte> salt, int iterations = 2, int requiredMemoryLen = 67108864, PasswordHashArgonAlgorithm algorithm = PasswordHashArgonAlgorithm.Argon2id13) Parameters key SecureMemory<byte> Buffer to receive the derived key (recommended: 32 bytes). password SecureMemory<byte> The password to hash. salt ReadOnlySpan<byte> The salt (must be 16 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). algorithm PasswordHashArgonAlgorithm Hash algorithm to use (default: Argon2id13). Exceptions ArgumentException If arguments are invalid. LibSodiumException If hashing fails. DeriveKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, int, int, PasswordHashArgonAlgorithm) Derives a secret key from a password and salt using Argon2. public static void DeriveKey(Span<byte> key, ReadOnlySpan<byte> password, ReadOnlySpan<byte> salt, int iterations = 2, int requiredMemoryLen = 67108864, PasswordHashArgonAlgorithm algorithm = PasswordHashArgonAlgorithm.Argon2id13) Parameters key Span<byte> Buffer to receive the derived key (recommended: 32 bytes). password ReadOnlySpan<byte> The password to hash. salt ReadOnlySpan<byte> The salt (must be 16 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). algorithm PasswordHashArgonAlgorithm Hash algorithm to use (default: Argon2id13). Exceptions ArgumentException If arguments are invalid. LibSodiumException If hashing fails. DeriveKey(Span<byte>, string, ReadOnlySpan<byte>, int, int, PasswordHashArgonAlgorithm) Derives a secret key from a password string and salt using Argon2. public static void DeriveKey(Span<byte> key, string password, ReadOnlySpan<byte> salt, int iterations = 2, int requiredMemoryLen = 67108864, PasswordHashArgonAlgorithm algorithm = PasswordHashArgonAlgorithm.Argon2id13) Parameters key Span<byte> Buffer to receive the derived key (recommended: 32 bytes). password string The password string to hash. salt ReadOnlySpan<byte> The salt (must be 16 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). algorithm PasswordHashArgonAlgorithm Hash algorithm to use (default: Argon2id13). Exceptions ArgumentNullException If the password is null. LibSodiumException If hashing fails. HashPassword(SecureMemory<byte>, int, int) Hashes a password into a human-readable string (including algorithm and parameters). public static string HashPassword(SecureMemory<byte> password, int iterations = 2, int requiredMemoryLen = 67108864) Parameters password SecureMemory<byte> The password to hash (in UTF-8). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentOutOfRangeException If password is too short or parameters are invalid. LibSodiumException If hashing fails. HashPassword(ReadOnlySpan<byte>, int, int) Hashes a password into a human-readable string (including algorithm and parameters). public static string HashPassword(ReadOnlySpan<byte> password, int iterations = 2, int requiredMemoryLen = 67108864) Parameters password ReadOnlySpan<byte> The password to hash (in UTF-8). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentOutOfRangeException If password is too short or parameters are invalid. LibSodiumException If hashing fails. HashPassword(string, int, int) Hashes a password string into a human-readable string (including algorithm and parameters). public static string HashPassword(string password, int iterations = 2, int requiredMemoryLen = 67108864) Parameters password string The password to hash (as string). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentNullException If the password is null. ArgumentOutOfRangeException If parameters are invalid. LibSodiumException If hashing fails. VerifyPassword(string, SecureMemory<byte>) Verifies a password against a previously hashed string. public static bool VerifyPassword(string hashedPassword, SecureMemory<byte> password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password SecureMemory<byte> The password to verify. Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If hashedPassword is null. ArgumentException If hashedPassword is too long. VerifyPassword(string, ReadOnlySpan<byte>) Verifies a password against a previously hashed string. public static bool VerifyPassword(string hashedPassword, ReadOnlySpan<byte> password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password ReadOnlySpan<byte> The password to verify. Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If hashedPassword is null. ArgumentException If hashedPassword is too long. VerifyPassword(string, string) Verifies a password string against a previously hashed string. public static bool VerifyPassword(string hashedPassword, string password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password string The password to verify (as string). Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If password is null."
  },
  "api/LibSodium.CryptoPasswordHashScrypt.html": {
    "href": "api/LibSodium.CryptoPasswordHashScrypt.html",
    "title": "Class CryptoPasswordHashScrypt | LibSodium.Net",
    "summary": "Class CryptoPasswordHashScrypt Namespace LibSodium Assembly LibSodium.Net.dll Provides password hashing and key derivation using the Scrypt algorithm. public static class CryptoPasswordHashScrypt Inheritance object CryptoPasswordHashScrypt Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Based on libsodium's crypto_pwhash_scryptsalsa208sha256 API: https://doc.libsodium.org/advanced/scrypt Fields EncodedLen Maximum length of the encoded hash string (includes null terminator) (102). public const int EncodedLen = 102 Field Value int InteractiveIterations Recommended iterations for login or general use (2^19 = 421Mi). public const int InteractiveIterations = 524288 Field Value int InteractiveMemoryLen Recommended memory usage for interactive scenarios (2^24 = 16 MiB). public const int InteractiveMemoryLen = 16777216 Field Value int MinIterations Minimum recommended iterations for dual-phase scenarios (2^10 = 1Ki). public const int MinIterations = 1024 Field Value int MinKeyLen Minimum allowed length in bytes for the derived key (16). public const int MinKeyLen = 16 Field Value int MinMemoryLen Minimum recommended memory usage (2^15 = 32 KiB). public const int MinMemoryLen = 32768 Field Value int MinPasswordLen Minimum allowed password length in bytes (0). public const int MinPasswordLen = 0 Field Value int ModerateIterations Recommended iterations for moderate-strength secrets (2^22 = 4Gi). public const int ModerateIterations = 4194304 Field Value int ModerateMemoryLen Recommended memory usage for moderate-strength secrets (2^27 = 128 MiB). public const int ModerateMemoryLen = 134217728 Field Value int Prefix Prefix for the encoded hash string (e.g. \"\\(7\\)\"). public const string Prefix = \"$7$\" Field Value string SaltLen Length of the salt in bytes (32). public const int SaltLen = 32 Field Value int SensitiveIterations Recommended iterations for high-value secrets (2^25 = 32Gi). public const int SensitiveIterations = 33554432 Field Value int SensitiveMemoryLen Recommended memory usage for high-value secrets (2^30 = 1 GiB). public const int SensitiveMemoryLen = 1073741824 Field Value int Methods DeriveKey(SecureMemory<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, int, int) Derives a secret key from a password and salt using scrypt. public static void DeriveKey(SecureMemory<byte> key, SecureMemory<byte> password, ReadOnlySpan<byte> salt, int iterations = 524288, int requiredMemoryLen = 16777216) Parameters key SecureMemory<byte> Buffer to receive the derived key (recommended: 32 bytes). password SecureMemory<byte> The password to hash. salt ReadOnlySpan<byte> The salt (must be 32 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Exceptions ArgumentException If arguments are invalid. LibSodiumException If hashing fails. DeriveKey(SecureMemory<byte>, string, ReadOnlySpan<byte>, int, int) Derives a secret key from a password string and salt using scrypt. public static void DeriveKey(SecureMemory<byte> key, string password, ReadOnlySpan<byte> salt, int iterations = 524288, int requiredMemoryLen = 16777216) Parameters key SecureMemory<byte> Buffer to receive the derived key (recommended: 32 bytes). password string The password string to hash. salt ReadOnlySpan<byte> The salt (must be 32 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Exceptions ArgumentNullException If the password is null. LibSodiumException If hashing fails. DeriveKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, int, int) Derives a secret key from a password and salt using scrypt. public static void DeriveKey(Span<byte> key, ReadOnlySpan<byte> password, ReadOnlySpan<byte> salt, int iterations = 524288, int requiredMemoryLen = 16777216) Parameters key Span<byte> Buffer to receive the derived key (recommended: 32 bytes). password ReadOnlySpan<byte> The password to hash. salt ReadOnlySpan<byte> The salt (must be 32 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Exceptions ArgumentException If arguments are invalid. LibSodiumException If hashing fails. DeriveKey(Span<byte>, string, ReadOnlySpan<byte>, int, int) Derives a secret key from a password string and salt using scrypt. public static void DeriveKey(Span<byte> key, string password, ReadOnlySpan<byte> salt, int iterations = 524288, int requiredMemoryLen = 16777216) Parameters key Span<byte> Buffer to receive the derived key (recommended: 32 bytes). password string The password string to hash. salt ReadOnlySpan<byte> The salt (must be 32 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Exceptions ArgumentNullException If the password is null. LibSodiumException If hashing fails. HashPassword(SecureMemory<byte>, int, int) Hashes a password into a human-readable string (including algorithm and parameters). public static string HashPassword(SecureMemory<byte> password, int iterations = 524288, int requiredMemoryLen = 16777216) Parameters password SecureMemory<byte> The password to hash (in UTF-8). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentOutOfRangeException If password is too short or parameters are invalid. LibSodiumException If hashing fails. HashPassword(ReadOnlySpan<byte>, int, int) Hashes a password into a human-readable string (including algorithm and parameters). public static string HashPassword(ReadOnlySpan<byte> password, int iterations = 524288, int requiredMemoryLen = 16777216) Parameters password ReadOnlySpan<byte> The password to hash (in UTF-8). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentOutOfRangeException If password is too short or parameters are invalid. LibSodiumException If hashing fails. HashPassword(string, int, int) Hashes a password string into a human-readable string (including algorithm and parameters). public static string HashPassword(string password, int iterations = 524288, int requiredMemoryLen = 16777216) Parameters password string The password to hash (as string). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentNullException If the password is null. ArgumentOutOfRangeException If parameters are invalid. LibSodiumException If hashing fails. VerifyPassword(string, SecureMemory<byte>) Verifies a password against a previously hashed string. public static bool VerifyPassword(string hashedPassword, SecureMemory<byte> password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password SecureMemory<byte> The password to verify. Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If hashedPassword is null. ArgumentException If hashedPassword is too long. VerifyPassword(string, ReadOnlySpan<byte>) Verifies a password against a previously hashed string. public static bool VerifyPassword(string hashedPassword, ReadOnlySpan<byte> password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password ReadOnlySpan<byte> The password to verify. Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If hashedPassword is null. ArgumentException If hashedPassword is too long. VerifyPassword(string, string) Verifies a password string against a previously hashed string. public static bool VerifyPassword(string hashedPassword, string password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password string The password to verify (as string). Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If password is null."
  },
  "api/LibSodium.CryptoScalarMult.html": {
    "href": "api/LibSodium.CryptoScalarMult.html",
    "title": "Class CryptoScalarMult | LibSodium.Net",
    "summary": "Class CryptoScalarMult Namespace LibSodium Assembly LibSodium.Net.dll Provides low-level scalar multiplication on Curve25519. This class exposes the crypto_scalarmult and crypto_scalarmult_base functions from libsodium. public static class CryptoScalarMult Inheritance object CryptoScalarMult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PrivateKeyLen Length of a Curve25519 private key (scalar) in bytes (32). public const int PrivateKeyLen = 32 Field Value int PublicKeyLen Length of a Curve25519 public key (point) in bytes (32). public const int PublicKeyLen = 32 Field Value int Methods CalculatePublicKey(Span<byte>, SecureMemory<byte>) Computes the public key corresponding to a private scalar on Curve25519. public static void CalculatePublicKey(Span<byte> publicKey, SecureMemory<byte> privateKey) Parameters publicKey Span<byte> The output buffer where the public key (32 bytes) will be stored. privateKey SecureMemory<byte> The private scalar (32 bytes). Remarks This method wraps crypto_scalarmult_base. Exceptions ArgumentException Thrown if any buffer has incorrect length. LibSodiumException Thrown if the operation fails. CalculatePublicKey(Span<byte>, ReadOnlySpan<byte>) Computes the public key corresponding to a private scalar on Curve25519. public static void CalculatePublicKey(Span<byte> publicKey, ReadOnlySpan<byte> privateKey) Parameters publicKey Span<byte> The output buffer where the public key (32 bytes) will be stored. privateKey ReadOnlySpan<byte> The private scalar (32 bytes). Remarks This method wraps crypto_scalarmult_base. Exceptions ArgumentException Thrown if any buffer has incorrect length. LibSodiumException Thrown if the operation fails. Compute(Span<byte>, SecureMemory<byte>, ReadOnlySpan<byte>) Computes the scalar multiplication of a private scalar and a public point on Curve25519. public static void Compute(Span<byte> sharedPoint, SecureMemory<byte> privateKey, ReadOnlySpan<byte> publicKey) Parameters sharedPoint Span<byte> The output buffer where the result (32 bytes) will be stored. privateKey SecureMemory<byte> The private scalar (32 bytes). publicKey ReadOnlySpan<byte> The public point (32 bytes). Remarks This method wraps crypto_scalarmult. Do not use the output directly as a symmetric key. Exceptions ArgumentException Thrown if any input or output buffer has incorrect length. LibSodiumException Thrown if the operation fails. Compute(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Computes the scalar multiplication of a private scalar and a public point on Curve25519. public static void Compute(Span<byte> sharedPoint, ReadOnlySpan<byte> privateKey, ReadOnlySpan<byte> publicKey) Parameters sharedPoint Span<byte> The output buffer where the result (32 bytes) will be stored. privateKey ReadOnlySpan<byte> The private scalar (32 bytes). publicKey ReadOnlySpan<byte> The public point (32 bytes). Remarks This method wraps crypto_scalarmult. Do not use the output directly as a symmetric key. Exceptions ArgumentException Thrown if any input or output buffer has incorrect length. LibSodiumException Thrown if the operation fails."
  },
  "api/LibSodium.CryptoSecretStream.html": {
    "href": "api/LibSodium.CryptoSecretStream.html",
    "title": "Class CryptoSecretStream | LibSodium.Net",
    "summary": "Class CryptoSecretStream Namespace LibSodium Assembly LibSodium.Net.dll The CryptoSecretStream class provides methods for performing authenticated encryption and decryption of data streams, with optional additional authenticated data. It is based on the XChaCha20-Poly1305 algorithm. public static class CryptoSecretStream Inheritance object CryptoSecretStream Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields HeaderLen The length of the header used in the secret stream. public const int HeaderLen = 24 Field Value int KeyLen The length of the key used for encryption and decryption. public const int KeyLen = 32 Field Value int OverheadLen The length of the overhead added to each ciphertext message. This includes the authentication tag and any necessary metadata for the stream. public static int OverheadLen Field Value int StateLen The length of the state used in the secret stream. public static int StateLen Field Value int Methods DecryptChunk(SecureMemory<byte>, Span<byte>, out CryptoSecretStreamTag, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts and verifies the authenticity of a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> DecryptChunk(SecureMemory<byte> state, Span<byte> cleartext, out CryptoSecretStreamTag tag, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> additionalData = default) Parameters state SecureMemory<byte> The current state of the secret stream. Must be StateLen bytes long. cleartext Span<byte> The span to write the decrypted data to. Must have a length of at least ciphertext.Length - OverheadLen. tag CryptoSecretStreamTag When this method returns, contains the tag associated with the decrypted message. ciphertext ReadOnlySpan<byte> The encrypted and authenticated data to decrypt. additionalData ReadOnlySpan<byte> Additional authenticated data that was cryptographically incorporated during the calculation of the authentication tag for the corresponding ciphertext. This value must be identical to the one used during the EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) call for authentication to succeed. Returns Span<byte> A Span<T> representing the decrypted data written to cleartext. Exceptions ArgumentException If the length of the state or cleartext spans are incorrect. LibSodiumException If the decryption or authentication of the chunk fails, likely due to tampered ciphertext or incorrect AAD. DecryptChunk(Span<byte>, Span<byte>, out CryptoSecretStreamTag, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts and verifies the authenticity of a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> DecryptChunk(Span<byte> state, Span<byte> cleartext, out CryptoSecretStreamTag tag, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> additionalData = default) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. cleartext Span<byte> The span to write the decrypted data to. Must have a length of at least ciphertext.Length - OverheadLen. tag CryptoSecretStreamTag When this method returns, contains the tag associated with the decrypted message. ciphertext ReadOnlySpan<byte> The encrypted and authenticated data to decrypt. additionalData ReadOnlySpan<byte> Additional authenticated data that was cryptographically incorporated during the calculation of the authentication tag for the corresponding ciphertext. This value must be identical to the one used during the EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) call for authentication to succeed. Returns Span<byte> A Span<T> representing the decrypted data written to cleartext. Exceptions ArgumentException If the length of the state or cleartext spans are incorrect. LibSodiumException If the decryption or authentication of the chunk fails, likely due to tampered ciphertext or incorrect AAD. EncryptChunk(SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) Encrypts and authenticates a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> EncryptChunk(SecureMemory<byte> state, Span<byte> ciphertext, ReadOnlySpan<byte> cleartext, CryptoSecretStreamTag tag, ReadOnlySpan<byte> additionalData = default) Parameters state SecureMemory<byte> The current state of the secret stream. Must be StateLen bytes long. ciphertext Span<byte> The span to write the encrypted and authenticated data to. Must have a length of at least cleartext.Length + OverheadLen. cleartext ReadOnlySpan<byte> The data to encrypt. tag CryptoSecretStreamTag The tag to associate with this message. additionalData ReadOnlySpan<byte> Additional data that is cryptographically incorporated during the calculation of the authentication tag for the ciphertext. This data is authenticated but not encrypted. Returns Span<byte> A Span<T> representing the encrypted and authenticated data written to ciphertext. Exceptions ArgumentException If the length of the state or ciphertext spans are incorrect. LibSodiumException If the encryption of the chunk fails. EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) Encrypts and authenticates a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> EncryptChunk(Span<byte> state, Span<byte> ciphertext, ReadOnlySpan<byte> cleartext, CryptoSecretStreamTag tag, ReadOnlySpan<byte> additionalData = default) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. ciphertext Span<byte> The span to write the encrypted and authenticated data to. Must have a length of at least cleartext.Length + OverheadLen. cleartext ReadOnlySpan<byte> The data to encrypt. tag CryptoSecretStreamTag The tag to associate with this message. additionalData ReadOnlySpan<byte> Additional data that is cryptographically incorporated during the calculation of the authentication tag for the ciphertext. This data is authenticated but not encrypted. Returns Span<byte> A Span<T> representing the encrypted and authenticated data written to ciphertext. Exceptions ArgumentException If the length of the state or ciphertext spans are incorrect. LibSodiumException If the encryption of the chunk fails. GenerateKey(SecureMemory<byte>) Generates a random key for use with the secret stream. public static void GenerateKey(SecureMemory<byte> key) Parameters key SecureMemory<byte> The span to write the generated key to. Exceptions ArgumentException If the length of the key span is not equal to KeyLen. GenerateKey(Span<byte>) Generates a random key for use with the secret stream. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> The span to write the generated key to. Exceptions ArgumentException If the length of the key span is not equal to KeyLen. InitializeDecryption(SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Initializes the authenticated decryption process for a secret stream. public static void InitializeDecryption(SecureMemory<byte> state, ReadOnlySpan<byte> header, SecureMemory<byte> key) Parameters state SecureMemory<byte> The span to write the initial state to. Must be StateLen bytes long. header ReadOnlySpan<byte> The stream header received from the sender. Must be HeaderLen bytes long. key SecureMemory<byte> The secret key used for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of decryption fails, likely due to an incorrect header or key. InitializeDecryption(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Initializes the authenticated decryption process for a secret stream. public static void InitializeDecryption(Span<byte> state, ReadOnlySpan<byte> header, ReadOnlySpan<byte> key) Parameters state Span<byte> The span to write the initial state to. Must be StateLen bytes long. header ReadOnlySpan<byte> The stream header received from the sender. Must be HeaderLen bytes long. key ReadOnlySpan<byte> The secret key used for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of decryption fails, likely due to an incorrect header or key. InitializeEncryption(SecureMemory<byte>, Span<byte>, SecureMemory<byte>) Initializes the authenticated encryption process for a secret stream. public static void InitializeEncryption(SecureMemory<byte> state, Span<byte> header, SecureMemory<byte> key) Parameters state SecureMemory<byte> The span to write the initial state to. Must be StateLen bytes long. header Span<byte> The span to write the stream header to. Must be HeaderLen bytes long. key SecureMemory<byte> The secret key to use for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of encryption fails. InitializeEncryption(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Initializes the authenticated encryption process for a secret stream. public static void InitializeEncryption(Span<byte> state, Span<byte> header, ReadOnlySpan<byte> key) Parameters state Span<byte> The span to write the initial state to. Must be StateLen bytes long. header Span<byte> The span to write the stream header to. Must be HeaderLen bytes long. key ReadOnlySpan<byte> The secret key to use for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of encryption fails."
  },
  "api/LibSodium.CryptoSecretStreamTag.html": {
    "href": "api/LibSodium.CryptoSecretStreamTag.html",
    "title": "Enum CryptoSecretStreamTag | LibSodium.Net",
    "summary": "Enum CryptoSecretStreamTag Namespace LibSodium Assembly LibSodium.Net.dll The tags used in the secret stream. public enum CryptoSecretStreamTag Fields Final = 3 The value of the tag corresponding to the final message. Message = 0 The value of the tag corresponding to a regular message. Push = 1 Indicates that the message marks the end of a set of messages, but not the end of the stream Rekey = 2 “forget” the key used to encrypt this message and the previous ones, and derive a new secret key"
  },
  "api/LibSodium.CryptoSha256.html": {
    "href": "api/LibSodium.CryptoSha256.html",
    "title": "Class CryptoSha256 | LibSodium.Net",
    "summary": "Class CryptoSha256 Namespace LibSodium Assembly LibSodium.Net.dll Provides one‑shot and streaming SHA‑256 hashing helpers built on libsodium’s crypto_hash_sha256 API. public static class CryptoSha256 Inheritance object CryptoSha256 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields HashLen Hash length in bytes (32). public const int HashLen = 32 Field Value int Methods ComputeHash(Span<byte>, Stream) Computes a SHA‑256 hash over the entire contents of the supplied Stream. public static void ComputeHash(Span<byte> hash, Stream input) Parameters hash Span<byte> Destination buffer (32 bytes) that receives the final hash. input Stream The input stream to read and hash. The stream is read until its end. Remarks The method processes the stream in buffered chunks of 8 KiB, keeping memory usage low even for very large inputs. Exceptions ArgumentNullException Thrown if input is null. ArgumentException Thrown if hash is not exactly 32 bytes. LibSodiumException Thrown if the underlying libsodium call fails. ComputeHash(Span<byte>, ReadOnlySpan<byte>) Computes a SHA‑256 hash of message and stores the result in hash. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message) Parameters hash Span<byte> Destination buffer (32 bytes). message ReadOnlySpan<byte> Message to hash. Exceptions ArgumentException If hash length ≠ 32. LibSodiumException If the native function returns non‑zero. ComputeHashAsync(Memory<byte>, Stream, CancellationToken) Asynchronously computes a SHA‑256 hash over the supplied Stream, writing the result into hash. public static Task ComputeHashAsync(Memory<byte> hash, Stream input, CancellationToken cancellationToken = default) Parameters hash Memory<byte> Destination memory buffer (32 bytes) that receives the final hash. input Stream The input stream to read and hash. The stream is read until its end. cancellationToken CancellationToken Token that can be used to cancel the asynchronous operation. Returns Task A task that completes when the hash has been fully computed and written. Remarks The method reads the stream in buffered chunks of 8 KiB and is fully asynchronous, making it suitable for hashing network streams or large files without blocking the calling thread. Exceptions ArgumentNullException Thrown if input is null. ArgumentException Thrown if hash is not exactly 32 bytes. LibSodiumException Thrown if the underlying libsodium call fails. CreateIncrementalHash() Creates a new instance of an incremental hash computation object using the SHA-512 algorithm. public static ICryptoIncrementalHash CreateIncrementalHash() Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of a SHA-512 hash. Remarks This method provides an object for computing a hash incrementally, which is useful for processing large data streams or when the data to be hashed is not available all at once. Exceptions LibSodiumException Thrown if the underlying libsodium call fails."
  },
  "api/LibSodium.CryptoSha512.html": {
    "href": "api/LibSodium.CryptoSha512.html",
    "title": "Class CryptoSha512 | LibSodium.Net",
    "summary": "Class CryptoSha512 Namespace LibSodium Assembly LibSodium.Net.dll Provides one‑shot and streaming SHA‑512 hashing helpers built on libsodium’s crypto_hash_sha512 API. public static class CryptoSha512 Inheritance object CryptoSha512 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields HashLen Hash length in bytes (64). public const int HashLen = 64 Field Value int Methods ComputeHash(Span<byte>, Stream) Computes a SHA‑512 hash over the entire contents of the supplied Stream. public static void ComputeHash(Span<byte> hash, Stream input) Parameters hash Span<byte> Destination buffer (64 bytes) that receives the final hash. input Stream The input stream to read and hash. The stream is read until its end. Remarks The method processes the stream in buffered chunks of 8 KiB, keeping memory usage low even for very large inputs. Exceptions ArgumentNullException Thrown if input is null. ArgumentException Thrown if hash is not exactly 64 bytes. LibSodiumException Thrown if the underlying libsodium call fails. ComputeHash(Span<byte>, ReadOnlySpan<byte>) Computes a SHA‑512 hash of message and stores the result in hash. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message) Parameters hash Span<byte> Destination buffer (64 bytes). message ReadOnlySpan<byte> Message to hash. Exceptions ArgumentException If hash length ≠ 64. LibSodiumException If the native function returns non‑zero. ComputeHashAsync(Memory<byte>, Stream, CancellationToken) Asynchronously computes a SHA‑512 hash over the supplied Stream, writing the result into hash. public static Task ComputeHashAsync(Memory<byte> hash, Stream input, CancellationToken cancellationToken = default) Parameters hash Memory<byte> Destination memory buffer (64 bytes) that receives the final hash. input Stream The input stream to read and hash. The stream is read until its end. cancellationToken CancellationToken Token that can be used to cancel the asynchronous operation. Returns Task A task that completes when the hash has been fully computed and written. Remarks The method reads the stream in buffered chunks of 8 KiB and is fully asynchronous, making it suitable for hashing network streams or large files without blocking the calling thread. Exceptions ArgumentNullException Thrown if input is null. ArgumentException Thrown if hash is not exactly 64 bytes. LibSodiumException Thrown if the underlying libsodium call fails. CreateIncrementalHash() Creates a new instance of an incremental hash computation object using the SHA-512 algorithm. public static ICryptoIncrementalHash CreateIncrementalHash() Returns ICryptoIncrementalHash An ICryptoIncrementalHash instance that allows incremental computation of a SHA-512 hash. Remarks This method provides an object for computing a hash incrementally, which is useful for processing large data streams or when the data to be hashed is not available all at once. Exceptions LibSodiumException Thrown if the underlying libsodium call fails."
  },
  "api/LibSodium.CryptoShortHash.html": {
    "href": "api/LibSodium.CryptoShortHash.html",
    "title": "Class CryptoShortHash | LibSodium.Net",
    "summary": "Class CryptoShortHash Namespace LibSodium Assembly LibSodium.Net.dll Provides a high-level interface to the libsodium short-input hash function, based on SipHash-2-4. public static class CryptoShortHash Inheritance object CryptoShortHash Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This function is optimized for short messages and uses a 16-byte secret key to protect against hash-flooding attacks. It is not suitable for general-purpose cryptographic hashing. \uD83E\uDDC2 https://libsodium.gitbook.io/doc/hashing/short-input_hashing Fields HashLen Hash length in bytes (8). public const int HashLen = 8 Field Value int KeyLen Key length in bytes (16). public const int KeyLen = 16 Field Value int Methods ComputeHash(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Computes a short hash (SipHash-2-4) of the given message using the provided 16-byte key. The key must remain secret. This function will not provide any mitigations against DoS attacks if the key is known from attackers. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message, SecureMemory<byte> key) Parameters hash Span<byte> A buffer of exactly 8 bytes to receive the output. message ReadOnlySpan<byte> The message to hash. key SecureMemory<byte> A 16-byte secret key. Exceptions ArgumentException Thrown if the key or hash buffer is not of expected length. LibSodiumException Thrown if the hashing operation fails. ComputeHash(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Computes a short hash (SipHash-2-4) of the given message using the provided 16-byte key. The key must remain secret. This function will not provide any mitigations against DoS attacks if the key is known from attackers. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message, ReadOnlySpan<byte> key) Parameters hash Span<byte> A buffer of exactly 8 bytes to receive the output. message ReadOnlySpan<byte> The message to hash. key ReadOnlySpan<byte> A 16-byte secret key. Exceptions ArgumentException Thrown if the key or hash buffer is not of expected length. LibSodiumException Thrown if the hashing operation fails."
  },
  "api/LibSodium.CryptoSign.html": {
    "href": "api/LibSodium.CryptoSign.html",
    "title": "Class CryptoSign | LibSodium.Net",
    "summary": "Class CryptoSign Namespace LibSodium Assembly LibSodium.Net.dll Provides digital signature functionality using Ed25519, as implemented by libsodium. public static class CryptoSign Inheritance object CryptoSign Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PrivateKeyLen Length in bytes of a private (secret) key (64). public const int PrivateKeyLen = 64 Field Value int PublicKeyLen Length in bytes of a public key (32). public const int PublicKeyLen = 32 Field Value int SeedLen Length in bytes of a seed used to generate key pairs deterministically. public const int SeedLen = 32 Field Value int SignatureLen Length in bytes of a signature (64). public const int SignatureLen = 64 Field Value int Methods GenerateKeyPair(Span<byte>, SecureMemory<byte>) Generates a new Ed25519 public/private key pair. public static void GenerateKeyPair(Span<byte> publicKey, SecureMemory<byte> privateKey) Parameters publicKey Span<byte> A span where the generated public key will be stored (must be PublicKeyLen bytes). privateKey SecureMemory<byte> A span where the generated private key will be stored (must be PrivateKeyLen bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key pair generation fails. GenerateKeyPair(Span<byte>, Span<byte>) Generates a new Ed25519 public/private key pair. public static void GenerateKeyPair(Span<byte> publicKey, Span<byte> privateKey) Parameters publicKey Span<byte> A span where the generated public key will be stored (must be PublicKeyLen bytes). privateKey Span<byte> A span where the generated private key will be stored (must be PrivateKeyLen bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key pair generation fails. GenerateKeyPairDeterministically(Span<byte>, SecureMemory<byte>, SecureMemory<byte>) Generates a Ed25519 public/private key pair from a seed deterministically. public static void GenerateKeyPairDeterministically(Span<byte> publicKey, SecureMemory<byte> secretKey, SecureMemory<byte> seed) Parameters publicKey Span<byte> A span where the generated public key will be stored (must be PublicKeyLen bytes). secretKey SecureMemory<byte> A span where the generated private key will be stored (must be PrivateKeyLen bytes). seed SecureMemory<byte> A seed used for key generation (must be SeedLen bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key pair generation fails. GenerateKeyPairDeterministically(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Generates a Ed25519 public/private key pair from a seed deterministically. public static void GenerateKeyPairDeterministically(Span<byte> publicKey, Span<byte> secretKey, ReadOnlySpan<byte> seed) Parameters publicKey Span<byte> A span where the generated public key will be stored (must be PublicKeyLen bytes). secretKey Span<byte> A span where the generated private key will be stored (must be PrivateKeyLen bytes). seed ReadOnlySpan<byte> A seed used for key generation (must be SeedLen bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key pair generation fails. PrivateKeyToCurve(SecureMemory<byte>, SecureMemory<byte>) Converts an Ed25519 private key (64 bytes) to a Curve25519 private key (32 bytes). public static void PrivateKeyToCurve(SecureMemory<byte> curvePrivateKey, SecureMemory<byte> edPrivateKey) Parameters curvePrivateKey SecureMemory<byte> The buffer where the resulting Curve25519 private key will be written. Must be 32 bytes. edPrivateKey SecureMemory<byte> The source Ed25519 private key. Must be 64 bytes. Remarks The resulting Curve25519 private key can be used with CryptoBox and CryptoKeyExchange APIs. Exceptions ArgumentException Thrown if buffer sizes are incorrect. LibSodiumException Thrown if the conversion fails. PrivateKeyToCurve(Span<byte>, ReadOnlySpan<byte>) Converts an Ed25519 private key (64 bytes) to a Curve25519 private key (32 bytes). public static void PrivateKeyToCurve(Span<byte> curvePrivateKey, ReadOnlySpan<byte> edPrivateKey) Parameters curvePrivateKey Span<byte> The buffer where the resulting Curve25519 private key will be written. Must be 32 bytes. edPrivateKey ReadOnlySpan<byte> The source Ed25519 private key. Must be 64 bytes. Remarks The resulting Curve25519 private key can be used with CryptoBox and CryptoKeyExchange APIs. Exceptions ArgumentException Thrown if buffer sizes are incorrect. LibSodiumException Thrown if the conversion fails. PublicKeyToCurve(Span<byte>, ReadOnlySpan<byte>) Converts an Ed25519 public key (32 bytes) to a Curve25519 public key (32 bytes). public static void PublicKeyToCurve(Span<byte> curvePublicKey, ReadOnlySpan<byte> edPublicKey) Parameters curvePublicKey Span<byte> The buffer where the resulting Curve25519 public key will be written. Must be 32 bytes. edPublicKey ReadOnlySpan<byte> The source Ed25519 public key. Must be 32 bytes. Remarks The resulting Curve25519 public key can be used with CryptoBox and CryptoKeyExchange APIs. Exceptions ArgumentException Thrown if buffer sizes are incorrect. LibSodiumException Thrown if the conversion fails. Sign(ReadOnlySpan<byte>, Span<byte>, SecureMemory<byte>) Creates a signature for the given message using the provided private key. public static Span<byte> Sign(ReadOnlySpan<byte> message, Span<byte> signature, SecureMemory<byte> privateKey) Parameters message ReadOnlySpan<byte> The message to be signed. signature Span<byte> A span to store the signature (must be at least SignatureLen bytes). privateKey SecureMemory<byte> The private key to sign with (must be PrivateKeyLen bytes). Returns Span<byte> A slice of the signature span containing the actual signature. Exceptions ArgumentException Thrown if the signature or private key length is incorrect. LibSodiumException Thrown if the signing operation fails. Sign(ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Creates a signature for the given message using the provided private key. public static Span<byte> Sign(ReadOnlySpan<byte> message, Span<byte> signature, ReadOnlySpan<byte> privateKey) Parameters message ReadOnlySpan<byte> The message to be signed. signature Span<byte> A span to store the signature (must be at least SignatureLen bytes). privateKey ReadOnlySpan<byte> The private key to sign with (must be PrivateKeyLen bytes). Returns Span<byte> A slice of the signature span containing the actual signature. Exceptions ArgumentException Thrown if the signature or private key length is incorrect. LibSodiumException Thrown if the signing operation fails. TryVerify(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies a signature against a given message and public key. public static bool TryVerify(ReadOnlySpan<byte> message, ReadOnlySpan<byte> signature, ReadOnlySpan<byte> publicKey) Parameters message ReadOnlySpan<byte> The original message. signature ReadOnlySpan<byte> The signature to verify (must be SignatureLen bytes). publicKey ReadOnlySpan<byte> The public key used to verify the signature (must be PublicKeyLen bytes). Returns bool true if the signature is valid; otherwise, false. Exceptions ArgumentException Thrown if the signature or public key length is incorrect. Verify(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies a signature against a given message and public key. Throws if the signature is invalid. public static void Verify(ReadOnlySpan<byte> message, ReadOnlySpan<byte> signature, ReadOnlySpan<byte> publicKey) Parameters message ReadOnlySpan<byte> The original message. signature ReadOnlySpan<byte> The signature to verify (must be SignatureLen bytes). publicKey ReadOnlySpan<byte> The public key used to verify the signature (must be PublicKeyLen bytes). Exceptions ArgumentException Thrown if the signature or public key length is incorrect. LibSodiumException Thrown if the signature is invalid."
  },
  "api/LibSodium.CryptoStreamChaCha20.html": {
    "href": "api/LibSodium.CryptoStreamChaCha20.html",
    "title": "Class CryptoStreamChaCha20 | LibSodium.Net",
    "summary": "Class CryptoStreamChaCha20 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the ChaCha20 stream cipher. public static class CryptoStreamChaCha20 Inheritance object CryptoStreamChaCha20 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BlockLen Block size of the keystream in bytes (64). public static readonly int BlockLen Field Value int KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int NonceLen Length of the nonce in bytes (8). public static readonly int NonceLen Field Value int Methods Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the ChaCha20 stream cipher. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the ChaCha20 stream cipher, with the provided key and nonce. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the ChaCha20 stream cipher. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the ChaCha20 stream cipher, with the provided key and nonce. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. DecryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the ChaCha20 stream cipher. public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 8 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. DecryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the ChaCha20 stream cipher. public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 8 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the ChaCha20 stream cipher. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the ChaCha20 stream cipher, with the provided key and nonce. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the ChaCha20 stream cipher. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the ChaCha20 stream cipher, with the provided key and nonce. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. EncryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the ChaCha20 stream cipher. public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 8 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. EncryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the ChaCha20 stream cipher. public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 8 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. GenerateKeystream(SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Generates a keystream of the specified length using the ChaCha20 stream cipher. public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key) Parameters output SecureMemory<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes. key SecureMemory<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid. GenerateKeystream(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Generates a keystream of the specified length using the ChaCha20 stream cipher. public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key) Parameters output Span<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes. key ReadOnlySpan<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid."
  },
  "api/LibSodium.CryptoStreamChaCha20Ietf.html": {
    "href": "api/LibSodium.CryptoStreamChaCha20Ietf.html",
    "title": "Class CryptoStreamChaCha20Ietf | LibSodium.Net",
    "summary": "Class CryptoStreamChaCha20Ietf Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the ChaCha20Ietf stream cipher. public static class CryptoStreamChaCha20Ietf Inheritance object CryptoStreamChaCha20Ietf Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BlockLen Block size of the keystream in bytes (64). public static readonly int BlockLen Field Value int KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int NonceLen Length of the nonce in bytes (12). public static readonly int NonceLen Field Value int Methods Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the ChaCha20Ietf stream cipher. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 12 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the ChaCha20Ietf stream cipher, with the provided key and nonce. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 12 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the ChaCha20Ietf stream cipher. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 12 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the ChaCha20Ietf stream cipher, with the provided key and nonce. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 12 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. DecryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the ChaCha20Ietf stream cipher. public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 12 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. DecryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the ChaCha20Ietf stream cipher. public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 12 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the ChaCha20Ietf stream cipher. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 12 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the ChaCha20Ietf stream cipher, with the provided key and nonce. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 12 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the ChaCha20Ietf stream cipher. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 12 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the ChaCha20Ietf stream cipher, with the provided key and nonce. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 12 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. EncryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the ChaCha20Ietf stream cipher. public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 12 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. EncryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the ChaCha20Ietf stream cipher. public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 12 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. GenerateKeystream(SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Generates a keystream of the specified length using the ChaCha20Ietf stream cipher. public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key) Parameters output SecureMemory<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 12 bytes. key SecureMemory<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid. GenerateKeystream(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Generates a keystream of the specified length using the ChaCha20Ietf stream cipher. public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key) Parameters output Span<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 12 bytes. key ReadOnlySpan<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid."
  },
  "api/LibSodium.CryptoStreamSalsa20.html": {
    "href": "api/LibSodium.CryptoStreamSalsa20.html",
    "title": "Class CryptoStreamSalsa20 | LibSodium.Net",
    "summary": "Class CryptoStreamSalsa20 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the Salsa20 stream cipher. public static class CryptoStreamSalsa20 Inheritance object CryptoStreamSalsa20 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BlockLen Block size of the keystream in bytes (64). public static readonly int BlockLen Field Value int KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int NonceLen Length of the nonce in bytes (8). public static readonly int NonceLen Field Value int Methods Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the Salsa20 stream cipher. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the Salsa20 stream cipher, with the provided key and nonce. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the Salsa20 stream cipher. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the Salsa20 stream cipher, with the provided key and nonce. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 8 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. DecryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the Salsa20 stream cipher. public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 8 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. DecryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the Salsa20 stream cipher. public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 8 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the Salsa20 stream cipher. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the Salsa20 stream cipher, with the provided key and nonce. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the Salsa20 stream cipher. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the Salsa20 stream cipher, with the provided key and nonce. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. EncryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the Salsa20 stream cipher. public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 8 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. EncryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the Salsa20 stream cipher. public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 8 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. GenerateKeystream(SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Generates a keystream of the specified length using the Salsa20 stream cipher. public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key) Parameters output SecureMemory<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes. key SecureMemory<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid. GenerateKeystream(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Generates a keystream of the specified length using the Salsa20 stream cipher. public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key) Parameters output Span<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 8 bytes. key ReadOnlySpan<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid."
  },
  "api/LibSodium.CryptoStreamXChaCha20.html": {
    "href": "api/LibSodium.CryptoStreamXChaCha20.html",
    "title": "Class CryptoStreamXChaCha20 | LibSodium.Net",
    "summary": "Class CryptoStreamXChaCha20 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the XChaCha20 stream cipher. public static class CryptoStreamXChaCha20 Inheritance object CryptoStreamXChaCha20 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BlockLen Block size of the keystream in bytes (64). public static readonly int BlockLen Field Value int KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int NonceLen Length of the nonce in bytes (24). public static readonly int NonceLen Field Value int Methods Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the XChaCha20 stream cipher. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the XChaCha20 stream cipher, with the provided key and nonce. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the XChaCha20 stream cipher. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the XChaCha20 stream cipher, with the provided key and nonce. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. DecryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the XChaCha20 stream cipher. public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 24 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. DecryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the XChaCha20 stream cipher. public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 24 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the XChaCha20 stream cipher. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the XChaCha20 stream cipher, with the provided key and nonce. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the XChaCha20 stream cipher. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the XChaCha20 stream cipher, with the provided key and nonce. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. EncryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the XChaCha20 stream cipher. public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 24 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. EncryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the XChaCha20 stream cipher. public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 24 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. GenerateKeystream(SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Generates a keystream of the specified length using the XChaCha20 stream cipher. public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key) Parameters output SecureMemory<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes. key SecureMemory<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid. GenerateKeystream(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Generates a keystream of the specified length using the XChaCha20 stream cipher. public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key) Parameters output Span<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes. key ReadOnlySpan<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid."
  },
  "api/LibSodium.CryptoStreamXSalsa20.html": {
    "href": "api/LibSodium.CryptoStreamXSalsa20.html",
    "title": "Class CryptoStreamXSalsa20 | LibSodium.Net",
    "summary": "Class CryptoStreamXSalsa20 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the XSalsa20 stream cipher. public static class CryptoStreamXSalsa20 Inheritance object CryptoStreamXSalsa20 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BlockLen Block size of the keystream in bytes (64). public static readonly int BlockLen Field Value int KeyLen Length of the secret key in bytes (32). public static readonly int KeyLen Field Value int NonceLen Length of the nonce in bytes (24). public static readonly int NonceLen Field Value int Methods Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the XSalsa20 stream cipher. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the XSalsa20 stream cipher, with the provided key and nonce. public static void Decrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Decrypts a stream using the XSalsa20 stream cipher. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. input Stream The stream containing ciphertext to decrypt. output Stream The stream to receive the decrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Decrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Decrypts the given ciphertext using the XSalsa20 stream cipher, with the provided key and nonce. public static void Decrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, Span<byte> plaintext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce used during encryption. Must be exactly 24 bytes long. ciphertext ReadOnlySpan<byte> The ciphertext to decrypt (produced by XOR with keystream). plaintext Span<byte> The output buffer to receive the decrypted plaintext. Must be at least as long as ciphertext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks Decryption is symmetric: it re-generates the same keystream and XORs it with the ciphertext. Exceptions ArgumentException Thrown if any input length is invalid. DecryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the XSalsa20 stream cipher. public static Task DecryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 24 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. DecryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously decrypts a stream using the XSalsa20 stream cipher. public static Task DecryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce used during encryption. Must be 24 bytes. input Stream The readable stream with ciphertext. output Stream The writable stream to receive decrypted data. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the XSalsa20 stream cipher. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the XSalsa20 stream cipher, with the provided key and nonce. public static void Encrypt(SecureMemory<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, Stream, Stream) Encrypts a stream using the XSalsa20 stream cipher. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, Stream input, Stream output) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. input Stream The stream containing plaintext data to encrypt. output Stream The stream to receive the encrypted data. Exceptions ArgumentException Thrown if key or nonce are invalid. Encrypt(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ulong) Encrypts the given plaintext using the XSalsa20 stream cipher, with the provided key and nonce. public static void Encrypt(ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, ulong initialCounter = 0) Parameters key ReadOnlySpan<byte> The secret key. Must be exactly 32 bytes long. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes long. Must never be reused with the same key. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. ciphertext Span<byte> The output buffer to receive the encrypted data. Must be at least as long as plaintext. initialCounter ulong The starting block index for the keystream (each block is 64 bytes). Use this to skip blocks, resume encryption, or decrypt from a specific offset. Defaults to 0. Remarks This method XORs the plaintext with a keystream derived from the key and nonce. Exceptions ArgumentException Thrown if any input length is invalid. EncryptAsync(SecureMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the XSalsa20 stream cipher. public static Task EncryptAsync(SecureMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key SecureMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 24 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. EncryptAsync(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, Stream, Stream, CancellationToken) Asynchronously encrypts a stream using the XSalsa20 stream cipher. public static Task EncryptAsync(ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> nonce, Stream input, Stream output, CancellationToken cancellationToken = default) Parameters key ReadOnlyMemory<byte> The secret key. Must be exactly 32 bytes. nonce ReadOnlyMemory<byte> The nonce. Must be exactly 24 bytes. input Stream The readable stream with plaintext data. output Stream The writable stream to receive ciphertext. cancellationToken CancellationToken Optional token to cancel the async operation. Returns Task A task that represents the asynchronous operation. GenerateKeystream(SecureMemory<byte>, ReadOnlySpan<byte>, SecureMemory<byte>) Generates a keystream of the specified length using the XSalsa20 stream cipher. public static void GenerateKeystream(SecureMemory<byte> output, ReadOnlySpan<byte> nonce, SecureMemory<byte> key) Parameters output SecureMemory<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes. key SecureMemory<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid. GenerateKeystream(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Generates a keystream of the specified length using the XSalsa20 stream cipher. public static void GenerateKeystream(Span<byte> output, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> key) Parameters output Span<byte> The buffer to receive the generated keystream. nonce ReadOnlySpan<byte> The nonce. Must be exactly 24 bytes. key ReadOnlySpan<byte> The key. Must be exactly 32 bytes. Exceptions ArgumentException Thrown if output is empty or lengths are invalid."
  },
  "api/LibSodium.HexEncoding.html": {
    "href": "api/LibSodium.HexEncoding.html",
    "title": "Class HexEncoding | LibSodium.Net",
    "summary": "Class HexEncoding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for encoding and decoding hexadecimal strings and byte buffers. public static class HexEncoding Inheritance object HexEncoding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BinToHex(ReadOnlySpan<byte>) Converts a byte buffer to a hexadecimal string in constant time for a given size. public static string BinToHex(ReadOnlySpan<byte> bin) Parameters bin ReadOnlySpan<byte> The byte buffer to convert. Returns string A hexadecimal string representation of the byte buffer. BinToHex(ReadOnlySpan<byte>, Span<char>) Converts a byte buffer to a hexadecimal string using a provided character span. public static Span<char> BinToHex(ReadOnlySpan<byte> bin, Span<char> hex) Parameters bin ReadOnlySpan<byte> The byte buffer to convert. hex Span<char> The span to write the hexadecimal string into. Returns Span<char> A span containing the hexadecimal string representation. HexToBin(ReadOnlySpan<char>, Span<byte>, string?) Converts a span of characters representing a hexadecimal string to a byte buffer. public static Span<byte> HexToBin(ReadOnlySpan<char> hex, Span<byte> bin, string? ignore = null) Parameters hex ReadOnlySpan<char> The span of characters representing the hexadecimal string. bin Span<byte> The span to write the byte buffer into. ignore string Optional characters to ignore during conversion. Returns Span<byte> A span containing the converted byte buffer. HexToBin(string, Span<byte>, string?) Converts a hexadecimal string to a byte buffer. public static Span<byte> HexToBin(string hex, Span<byte> bin, string? ignore = null) Parameters hex string The hexadecimal string to convert. bin Span<byte> The span to write the byte buffer into. ignore string Optional characters to ignore during conversion. Returns Span<byte> A span containing the converted byte buffer."
  },
  "api/LibSodium.ICryptoIncrementalHash.html": {
    "href": "api/LibSodium.ICryptoIncrementalHash.html",
    "title": "Interface ICryptoIncrementalHash | LibSodium.Net",
    "summary": "Interface ICryptoIncrementalHash Namespace LibSodium Assembly LibSodium.Net.dll Represents an incremental hash or MAC calculator that processes data in chunks and produces a fixed-size output. public interface ICryptoIncrementalHash : IDisposable Inherited Members IDisposable.Dispose() Methods Final(Span<byte>) Finalizes the hash or MAC computation and writes the result to the specified buffer. void Final(Span<byte> hash) Parameters hash Span<byte> The buffer where the final result will be written. Must match the expected output length. Exceptions InvalidOperationException Thrown if called more than once. Update(ReadOnlySpan<byte>) Appends data to the ongoing hash or MAC computation. void Update(ReadOnlySpan<byte> data) Parameters data ReadOnlySpan<byte> The input data to append. May be empty."
  },
  "api/LibSodium.LibSodiumException.html": {
    "href": "api/LibSodium.LibSodiumException.html",
    "title": "Class LibSodiumException | LibSodium.Net",
    "summary": "Class LibSodiumException Namespace LibSodium Assembly LibSodium.Net.dll Represents errors that occur during Sodium operations. [Serializable] public class LibSodiumException : CryptographicException, ISerializable Inheritance object Exception SystemException CryptographicException LibSodiumException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors LibSodiumException() Initializes a new instance of the LibSodiumException class. public LibSodiumException() LibSodiumException(string?) Initializes a new instance of the LibSodiumException class with a specified error message. public LibSodiumException(string? message) Parameters message string The error message that explains the reason for the exception. LibSodiumException(string?, Exception?) Initializes a new instance of the LibSodiumException class with a specified error message and a reference to the inner exception that is the cause of this exception. public LibSodiumException(string? message, Exception? innerException) Parameters message string The error message that explains the reason for the exception. innerException Exception The exception that is the cause of the current exception, or a null reference if no inner exception is specified."
  },
  "api/LibSodium.LibraryInitializer.html": {
    "href": "api/LibSodium.LibraryInitializer.html",
    "title": "Class LibraryInitializer | LibSodium.Net",
    "summary": "Class LibraryInitializer Namespace LibSodium Assembly LibSodium.Net.dll Static class that manages the initialization and configuration of libsodium. public static class LibraryInitializer Inheritance object LibraryInitializer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsInitialized Gets a value indicating whether the library has been initialized public static bool IsInitialized { get; } Property Value bool Methods EnsureInitialized() Ensures that the libsodium library is initialized. public static void EnsureInitialized()"
  },
  "api/LibSodium.LibraryVersion.html": {
    "href": "api/LibSodium.LibraryVersion.html",
    "title": "Class LibraryVersion | LibSodium.Net",
    "summary": "Class LibraryVersion Namespace LibSodium Assembly LibSodium.Net.dll Provides methods to retrieve the version information of the Sodium library. public static class LibraryVersion Inheritance object LibraryVersion Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetMajor() Gets the major version number of the Sodium library. public static int GetMajor() Returns int The major version number as an integer. GetMinor() Gets the minor version number of the Sodium library. public static int GetMinor() Returns int The minor version number as an integer. GetString() Gets the version string of the Sodium library. public static string? GetString() Returns string The version string as a string, or null if the string could not be retrieved."
  },
  "api/LibSodium.PasswordHashArgonAlgorithm.html": {
    "href": "api/LibSodium.PasswordHashArgonAlgorithm.html",
    "title": "Enum PasswordHashArgonAlgorithm | LibSodium.Net",
    "summary": "Enum PasswordHashArgonAlgorithm Namespace LibSodium Assembly LibSodium.Net.dll Supported password hashing algorithms. public enum PasswordHashArgonAlgorithm Fields Argon2i13 = 1 Argon2i version 1.3 — optimized for side-channel resistance. Argon2id13 = 2 Argon2id version 1.3 — hybrid mode (default and recommended)."
  },
  "api/LibSodium.RandomGenerator.html": {
    "href": "api/LibSodium.RandomGenerator.html",
    "title": "Class RandomGenerator | LibSodium.Net",
    "summary": "Class RandomGenerator Namespace LibSodium Assembly LibSodium.Net.dll Static class for random number generation. public static class RandomGenerator Inheritance object RandomGenerator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields SeedLen The length of the seed used for deterministic random byte generation. public const int SeedLen = 32 Field Value int Methods Close() Closes the random number generator. public static void Close() Exceptions LibSodiumException Thrown when randombytes_close() fails. Fill(SecureMemory<byte>) Fills the specified secure memory buffer with random bytes. public static void Fill(SecureMemory<byte> buffer) Parameters buffer SecureMemory<byte> The buffer to fill with random bytes. Fill(Span<byte>) Fills the specified buffer with random bytes. public static void Fill(Span<byte> buffer) Parameters buffer Span<byte> The buffer to fill with random bytes. FillDeterministic(SecureMemory<byte>, SecureMemory<byte>) Fills the specified buffer with deterministic random bytes based on the provided seed. It produces the same sequence of random bytes for the same seed. public static void FillDeterministic(SecureMemory<byte> buffer, SecureMemory<byte> seed) Parameters buffer SecureMemory<byte> The buffer to fill with deterministic random bytes. seed SecureMemory<byte> The seed used for deterministic random byte generation. Exceptions ArgumentException Thrown when the seed length is not equal to SeedLen. FillDeterministic(Span<byte>, ReadOnlySpan<byte>) Fills the specified buffer with deterministic random bytes based on the provided seed. It produces the same sequence of random bytes for the same seed. public static void FillDeterministic(Span<byte> buffer, ReadOnlySpan<byte> seed) Parameters buffer Span<byte> The buffer to fill with deterministic random bytes. seed ReadOnlySpan<byte> The seed used for deterministic random byte generation. Exceptions ArgumentException Thrown when the seed length is not equal to SeedLen. GetUInt32() Gets a random unsigned 32-bit integer. public static uint GetUInt32() Returns uint A random unsigned 32-bit integer. GetUInt32(uint) Gets a random unsigned 32-bit integer less than the specified upper bound. public static uint GetUInt32(uint upperBound) Parameters upperBound uint The upper bound (exclusive) for the random number. Returns uint A random unsigned 32-bit integer less than upperBound. Stir() Stirs the random number generator to ensure randomness. public static void Stir()"
  },
  "api/LibSodium.SecretBox.html": {
    "href": "api/LibSodium.SecretBox.html",
    "title": "Class SecretBox | LibSodium.Net",
    "summary": "Class SecretBox Namespace LibSodium Assembly LibSodium.Net.dll Provides static methods for authenticated symmetric encryption and decryption using the Sodium secretbox primitives, specifically the XSalsa20 stream cipher and Poly1305 MAC for authentication. These methods offer combined encryption/authentication and detached encryption/authentication, with variations for handling nonces and Message Authentication Codes (MACs) within or separate from the ciphertext. public static class SecretBox Inheritance object SecretBox Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields KeyLen Represents the length of the encryption key in bytes. public const int KeyLen = 32 Field Value int MacLen represents the length of the Message Authentication Code (MAC) in bytes public const int MacLen = 16 Field Value int NonceLen Represents the length of the nonce (number used once) in bytes. public const int NonceLen = 24 Field Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using XSalsa20-Poly1305. Supports combined and detached modes, with optional manual nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer to receive the decrypted message. Must be at least ciphertext length minus MAC and/or nonce depending on mode. It can be longer than needed. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and/or nonce depending on the mode. key SecureMemory<byte> The secret key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode using this MAC. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, it is extracted from the ciphertext (auto-nonce mode). Returns Span<byte> The span representing the recovered plaintext. Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using XSalsa20-Poly1305. Supports combined and detached modes, with optional manual nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer to receive the decrypted message. Must be at least ciphertext length minus MAC and/or nonce depending on mode. It can be longer than needed. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and/or nonce depending on the mode. key ReadOnlySpan<byte> The secret key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode using this MAC. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, it is extracted from the ciphertext (auto-nonce mode). Returns Span<byte> The span representing the recovered plaintext. Encrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using XSalsa20-Poly1305. Supports combined and detached modes, with optional manual nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The output buffer. In combined mode, it must include space for the MAC and, if auto-nonce is used, also for the nonce. In detached mode with auto-nonce, the nonce is prepended. It can be longer than needed. plaintext ReadOnlySpan<byte> The plaintext to encrypt. key SecureMemory<byte> The secret key (32 bytes). mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC is written to this buffer. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended to the ciphertext. Returns Span<byte> The span representing the encrypted ciphertext, which may include MAC and nonce depending on the mode. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using XSalsa20-Poly1305. Supports combined and detached modes, with optional manual nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The output buffer. In combined mode, it must include space for the MAC and, if auto-nonce is used, also for the nonce. In detached mode with auto-nonce, the nonce is prepended. It can be longer than needed. plaintext ReadOnlySpan<byte> The plaintext to encrypt. key ReadOnlySpan<byte> The secret key (32 bytes). mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC is written to this buffer. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended to the ciphertext. Returns Span<byte> The span representing the encrypted ciphertext, which may include MAC and nonce depending on the mode."
  },
  "api/LibSodium.SecretStream.html": {
    "href": "api/LibSodium.SecretStream.html",
    "title": "Class SecretStream | LibSodium.Net",
    "summary": "Class SecretStream Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level, stream-based authenticated encryption and decryption using the XChaCha20-Poly1305 algorithm. This class abstracts the complexity of securely processing large data streams, including chunking, authentication, and cryptographic state management. public static class SecretStream Inheritance object SecretStream Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class is built on LibSodium’s crypto_secretstream_xChaCha20poly1305 API, using XChaCha20 for encryption and Poly1305 for message authentication. The large 192-bit nonce (24 bytes) virtually eliminates the risk of nonce reuse when generated randomly. The stream is processed in fixed-size chunks (64 KB), each individually encrypted and authenticated. A randomly generated header (nonce and metadata) is prepended to the stream and required for successful decryption. Security Considerations: Key Management: Keys must be generated securely and stored safely. Compromise of the key invalidates confidentiality and integrity guarantees. Nonce Handling: Nonces are generated internally. Do not reuse headers or keys manually unless you know what you're doing. Integrity: Poly1305 tags ensure tampering is detected during decryption. Any modification will result in decryption failure. Fields PlainChunkSize The size of each plaintext chunk processed during encryption (64KB). This chunk size is used to divide the input stream into manageable blocks. public const int PlainChunkSize = 65536 Field Value int Methods Decrypt(Stream, Stream, SecureMemory<byte>, ReadOnlySpan<byte>) Synchronously decrypts data from the input stream using a key stored in secure memory, and writes the plaintext to the output stream. public static void Decrypt(Stream input, Stream output, SecureMemory<byte> key, ReadOnlySpan<byte> aad = default) Parameters input Stream The stream containing encrypted data. It must begin with the secret stream header written during encryption. output Stream The stream where decrypted plaintext will be written. key SecureMemory<byte> A SecureMemory<T> buffer containing the decryption key. This key must match the one used to encrypt the stream. aad ReadOnlySpan<byte> Additional authenticated data Remarks This method behaves identically to Decrypt(Stream, Stream, ReadOnlySpan<byte>, ReadOnlySpan<byte>), but uses a secure memory buffer for enhanced key confidentiality. The decryption header is consumed automatically at the beginning of the stream. Chunks are processed sequentially, and any failure in tag verification will cause decryption to halt with an exception. Internal buffers are cleared and returned to the pool after use. The input and output streams remain open. Exceptions ArgumentNullException Thrown if input, output, or key is null. ObjectDisposedException Thrown if the secure memory key has already been disposed. EndOfStreamException Thrown if the stream ends before the Final tag is encountered. LibSodiumException Thrown if the authentication of a chunk fails, which indicates tampering or a mismatched key. Decrypt(Stream, Stream, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Synchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying each chunk's authenticity using XChaCha20-Poly1305. public static void Decrypt(Stream input, Stream output, ReadOnlySpan<byte> key, ReadOnlySpan<byte> aad = default) Parameters input Stream The readable stream containing encrypted data. The stream must begin with the encryption header produced during the corresponding encryption process. output Stream The writable stream where decrypted plaintext will be written. key ReadOnlySpan<byte> The secret decryption key. It must match the key used to encrypt the stream and be exactly 32 bytes long. aad ReadOnlySpan<byte> Additional authenticated data Remarks This method processes the encrypted stream in chunks, validating each chunk before decrypting it. If authentication fails, a LibSodiumException is thrown and the decrypted output is invalidated. The stream must start with a header containing the nonce and metadata necessary for decryption. This header is automatically consumed at the beginning of the stream. All internal buffers are zeroed after use. The input and output streams are not closed automatically. Exceptions ArgumentException Thrown if the key is invalid. EndOfStreamException Thrown if the stream ends before the Final tag is reached, indicating an incomplete or truncated stream. LibSodiumException Thrown if authentication fails, indicating the ciphertext has been tampered with or the wrong key was used. DecryptAsync(Stream, Stream, SecureMemory<byte>, ReadOnlyMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying integrity using XChaCha20-Poly1305. public static Task DecryptAsync(Stream input, Stream output, SecureMemory<byte> key, ReadOnlyMemory<byte> aad, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing encrypted data. The stream must begin with the header produced during encryption. output Stream The writable stream where decrypted plaintext will be written. key SecureMemory<byte> The secret key used for decryption. It must match the key used during encryption. aad ReadOnlyMemory<byte> Additional authenticated data cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks The decryption process begins by reading the stream header, which includes a nonce required to initialize the decryption state. Each encrypted chunk is then read, authenticated, and decrypted in order. If any chunk fails authentication, a LibSodiumException is thrown and no plaintext is written for that chunk. If the stream ends before encountering a chunk tagged as Final, an EndOfStreamException is thrown. This method uses pooled buffers and zeroes out internal state after use to reduce memory leakage risks. Input and output streams are not closed automatically. Exceptions ArgumentNullException Thrown if any argument is null. EndOfStreamException Thrown if the stream ends unexpectedly or the final tag is never reached. LibSodiumException Thrown if the integrity check fails on any chunk (i.e., authentication tag mismatch). OperationCanceledException Thrown if the operation is canceled. DecryptAsync(Stream, Stream, SecureMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream using a key stored in SecureMemory<T>, and writes the plaintext to the output stream. public static Task DecryptAsync(Stream input, Stream output, SecureMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing the encrypted data. The stream must begin with the encryption header. output Stream The writable stream where the decrypted plaintext will be written. key SecureMemory<byte> A secure memory buffer containing the decryption key. This must match the key used to encrypt the stream. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks This overload behaves identically to DecryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken), but uses a SecureMemory<T> buffer for enhanced runtime key protection. The key is securely wiped from memory once decryption is complete. Stream lifetime is not managed automatically. Exceptions ArgumentNullException Thrown if any argument is null. ObjectDisposedException Thrown if the secure key has already been disposed. EndOfStreamException Thrown if the stream ends before the final tag is reached. LibSodiumException Thrown if the integrity check fails (e.g., if the ciphertext has been tampered with). OperationCanceledException Thrown if the operation is canceled. DecryptAsync(Stream, Stream, ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying integrity using XChaCha20-Poly1305. public static Task DecryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> aad, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing encrypted data. The stream must begin with the header produced during encryption. output Stream The writable stream where decrypted plaintext will be written. key ReadOnlyMemory<byte> The secret key used for decryption. It must match the key used during encryption. aad ReadOnlyMemory<byte> Additional authenticated data cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks The decryption process begins by reading the stream header, which includes a nonce required to initialize the decryption state. Each encrypted chunk is then read, authenticated, and decrypted in order. If any chunk fails authentication, a LibSodiumException is thrown and no plaintext is written for that chunk. If the stream ends before encountering a chunk tagged as Final, an EndOfStreamException is thrown. This method uses pooled buffers and zeroes out internal state after use to reduce memory leakage risks. Input and output streams are not closed automatically. Exceptions ArgumentNullException Thrown if any argument is null. EndOfStreamException Thrown if the stream ends unexpectedly or the final tag is never reached. LibSodiumException Thrown if the integrity check fails on any chunk (i.e., authentication tag mismatch). OperationCanceledException Thrown if the operation is canceled. DecryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying integrity using XChaCha20-Poly1305. public static Task DecryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing encrypted data. The stream must begin with the header produced during encryption. output Stream The writable stream where decrypted plaintext will be written. key ReadOnlyMemory<byte> The secret key used for decryption. It must match the key used during encryption. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks The decryption process begins by reading the stream header, which includes a nonce required to initialize the decryption state. Each encrypted chunk is then read, authenticated, and decrypted in order. If any chunk fails authentication, a LibSodiumException is thrown and no plaintext is written for that chunk. If the stream ends before encountering a chunk tagged as Final, an EndOfStreamException is thrown. This method uses pooled buffers and zeroes out internal state after use to reduce memory leakage risks. Input and output streams are not closed automatically. Exceptions ArgumentNullException Thrown if any argument is null. EndOfStreamException Thrown if the stream ends unexpectedly or the final tag is never reached. LibSodiumException Thrown if the integrity check fails on any chunk (i.e., authentication tag mismatch). OperationCanceledException Thrown if the operation is canceled. Encrypt(Stream, Stream, SecureMemory<byte>, ReadOnlySpan<byte>) Synchronously encrypts data from the input stream using a secure key, and writes the ciphertext to the output stream. public static void Encrypt(Stream input, Stream output, SecureMemory<byte> key, ReadOnlySpan<byte> aad = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key SecureMemory<byte> A SecureMemory<T> buffer containing the encryption key. It must be 32 bytes in size, and will be securely wiped from memory after use. aad ReadOnlySpan<byte> Additional authenticated data Remarks This method is functionally equivalent to Encrypt(Stream, Stream, ReadOnlySpan<byte>, ReadOnlySpan<byte>), but accepts the encryption key wrapped in SecureMemory<T> for added in-memory protection. This improves resistance to key leakage through memory inspection, especially in long-lived processes. Exceptions ArgumentNullException Thrown if key, input, or output is null. ObjectDisposedException Thrown if the key has already been disposed. ArgumentException Thrown if the key is invalid (wrong length). Encrypt(Stream, Stream, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Synchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static void Encrypt(Stream input, Stream output, ReadOnlySpan<byte> key, ReadOnlySpan<byte> aad = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key ReadOnlySpan<byte> The encryption key. Must be securely generated and exactly 32 bytes long for XChaCha20-Poly1305. aad ReadOnlySpan<byte> Additional authenticated data Remarks This method performs stream encryption in-place and blocks the calling thread until completion. It is suitable for scenarios where asynchronous patterns are not required or not supported. The input is processed in chunks of PlainChunkSize bytes. Each chunk is encrypted and authenticated before being written to the output stream. A cryptographic header is written at the beginning, and a final tag is written after the last chunk. All internal buffers are zeroed after use, and pooled memory is returned. The input and output streams are not closed or disposed automatically. Exceptions ArgumentException Thrown if the key is invalid. EndOfStreamException Thrown if the input stream ends unexpectedly. EncryptAsync(Stream, Stream, SecureMemory<byte>, ReadOnlyMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static Task EncryptAsync(Stream input, Stream output, SecureMemory<byte> key, ReadOnlyMemory<byte> aad, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key SecureMemory<byte> The secret key for encryption. Must be securely generated and kept confidential. Typically 32 bytes in length for XChaCha20-Poly1305. aad ReadOnlyMemory<byte> Additional autenticated data cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks The input stream is read in PlainChunkSize blocks. Each block is encrypted and written to the output stream with an authentication tag to ensure integrity. A cryptographic header (including a randomly generated nonce) is prepended to the output. This header is required for successful decryption. The encryption state is maintained internally and finalized when the last chunk is written with the Final tag. Note: The caller is responsible for managing the lifetime of the input/output streams. They are not closed or disposed automatically. Exceptions ArgumentNullException Thrown if any argument is null. OperationCanceledException Thrown if the operation is canceled. EncryptAsync(Stream, Stream, SecureMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static Task EncryptAsync(Stream input, Stream output, SecureMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key SecureMemory<byte> The secret key for encryption. Must be securely generated and kept confidential. Typically 32 bytes in length for XChaCha20-Poly1305. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks The input stream is read in PlainChunkSize blocks. Each block is encrypted and written to the output stream with an authentication tag to ensure integrity. A cryptographic header (including a randomly generated nonce) is prepended to the output. This header is required for successful decryption. The encryption state is maintained internally and finalized when the last chunk is written with the Final tag. Note: The caller is responsible for managing the lifetime of the input/output streams. They are not closed or disposed automatically. Exceptions ArgumentNullException Thrown if any argument is null. OperationCanceledException Thrown if the operation is canceled. EncryptAsync(Stream, Stream, ReadOnlyMemory<byte>, ReadOnlyMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static Task EncryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, ReadOnlyMemory<byte> aad, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key ReadOnlyMemory<byte> The secret key for encryption. Must be securely generated and kept confidential. Typically 32 bytes in length for XChaCha20-Poly1305. aad ReadOnlyMemory<byte> Additional autenticated data cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks The input stream is read in PlainChunkSize blocks. Each block is encrypted and written to the output stream with an authentication tag to ensure integrity. A cryptographic header (including a randomly generated nonce) is prepended to the output. This header is required for successful decryption. The encryption state is maintained internally and finalized when the last chunk is written with the Final tag. Note: The caller is responsible for managing the lifetime of the input/output streams. They are not closed or disposed automatically. Exceptions ArgumentNullException Thrown if any argument is null. OperationCanceledException Thrown if the operation is canceled. EncryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static Task EncryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key ReadOnlyMemory<byte> The secret key for encryption. Must be securely generated and kept confidential. Typically 32 bytes in length for XChaCha20-Poly1305. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks The input stream is read in PlainChunkSize blocks. Each block is encrypted and written to the output stream with an authentication tag to ensure integrity. A cryptographic header (including a randomly generated nonce) is prepended to the output. This header is required for successful decryption. The encryption state is maintained internally and finalized when the last chunk is written with the Final tag. Note: The caller is responsible for managing the lifetime of the input/output streams. They are not closed or disposed automatically. Exceptions ArgumentNullException Thrown if any argument is null. OperationCanceledException Thrown if the operation is canceled."
  },
  "api/LibSodium.SecureBigUnsignedInteger.html": {
    "href": "api/LibSodium.SecureBigUnsignedInteger.html",
    "title": "Class SecureBigUnsignedInteger | LibSodium.Net",
    "summary": "Class SecureBigUnsignedInteger Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for working with arbitrary large little endian big unsigned integers in a secure way (constant time for a given length) public static class SecureBigUnsignedInteger Inheritance object SecureBigUnsignedInteger Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Add(Span<byte>, ReadOnlySpan<byte>) Adds two byte buffers representing big unsigned integers in constant time, storing the result in the second buffer public static void Add(Span<byte> a, ReadOnlySpan<byte> b) Parameters a Span<byte> The first byte buffer representing a big unsigned integer. b ReadOnlySpan<byte> The second byte buffer representing a big unsigned integer. It receives the result. Compare(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers representing big unsigned integers. public static int Compare(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> The first byte buffer. b2 ReadOnlySpan<byte> The second byte buffer. Returns int A negative number if b1 is less than b2, zero if they are equal, and a positive number if b1 is greater than b2. Equals(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers for equality in constant time. public static bool Equals(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> First buffer to compare. b2 ReadOnlySpan<byte> Second buffer to compare. Returns bool True if the buffers are equal, false otherwise. Increment(Span<byte>) Increments the given byte buffer representing a big unsigned integer by 1. public static void Increment(Span<byte> number) Parameters number Span<byte> The byte buffer to increment. Increment(Span<byte>, ulong) Increments the given byte buffer representing a big unsigned integer by a specified value. public static void Increment(Span<byte> number, ulong increment) Parameters number Span<byte> The byte buffer representing a big unsigned integer to increment. increment ulong The value to increment by. IsZero(ReadOnlySpan<byte>) Checks if the given byte buffer is zero. public static bool IsZero(ReadOnlySpan<byte> b) Parameters b ReadOnlySpan<byte> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Subtract(Span<byte>, ReadOnlySpan<byte>) Subtracts one byte buffer from another representing big unsigned integers. public static void Subtract(Span<byte> subtrahend, ReadOnlySpan<byte> minuend) Parameters subtrahend Span<byte> The byte buffer to subtract from. minuend ReadOnlySpan<byte> The byte buffer to subtract."
  },
  "api/LibSodium.SecureMemory-1.html": {
    "href": "api/LibSodium.SecureMemory-1.html",
    "title": "Class SecureMemory<T> | LibSodium.Net",
    "summary": "Class SecureMemory<T> Namespace LibSodium Assembly LibSodium.Net.dll Provides a secure unmanaged memory buffer for unmanaged types, using libsodium for memory protection. This class encapsulates secure memory allocation, read-only protection, and zeroing. public sealed class SecureMemory<T> : IDisposable where T : unmanaged Type Parameters T The unmanaged type of elements in the secure memory buffer. Inheritance object SecureMemory<T> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SecureMemory(int) Initializes a new instance of the SecureMemory<T> class with the specified length. public SecureMemory(int length) Parameters length int The number of elements of type T to allocate. Exceptions LibSodiumException Thrown if memory allocation fails. Properties IsDisposed Gets a value indicating whether the object has been disposed. public bool IsDisposed { get; } Property Value bool IsReadOnly Gets a value indicating whether the memory region is read-only. public bool IsReadOnly { get; } Property Value bool Length Gets the length of the secure unmanaged memory buffer, in number of elements of type T. public int Length { get; } Property Value int Methods AsMemory() Gets a Memory<T> representing the secure unmanaged memory buffer. public Memory<T> AsMemory() Returns Memory<T> Exceptions InvalidOperationException AsReadOnlyMemory() Gets a ReadOnlyMemory<T> representing the secure unmanaged memory buffer. public ReadOnlyMemory<T> AsReadOnlyMemory() Returns ReadOnlyMemory<T> Exceptions ObjectDisposedException AsReadOnlySpan() Gets a ReadOnlySpan<T> representing the secure unmanaged memory buffer. public ReadOnlySpan<T> AsReadOnlySpan() Returns ReadOnlySpan<T> Remarks While this method returns a new ReadOnlySpan<T> instance on each call, all returned spans represent the same underlying memory region. Exceptions ObjectDisposedException Thrown if the object has been disposed. AsSpan() Gets a Span<T> representing the secure unmanaged memory buffer. public Span<T> AsSpan() Returns Span<T> Remarks While this method returns a new Span<T> instance on each call, all returned spans represent the same underlying memory region. Modifications made through one span will be visible through any other span obtained from this instance. Exceptions ObjectDisposedException Thrown if the object has been disposed. InvalidOperationException Thrown if the memory region is read-only. Dispose() Releases all resources used by the SecureMemory<T> object, including the allocated unmanaged secure memory. public void Dispose() ~SecureMemory() Finalizes an instance of the SecureMemory<T> class. protected ~SecureMemory() IsZero() Determines whether the current instance contains only zero values. public bool IsZero() Returns bool true if all bytes in the current instance are zero; otherwise, false. MemZero() Fills the secure unmanaged memory buffer with zeros, effectively erasing its contents. public void MemZero() Exceptions ObjectDisposedException Thrown if the object has been disposed. ProtectReadOnly() Marks the secure unmanaged memory buffer as read-only. public void ProtectReadOnly() Exceptions ObjectDisposedException Thrown if the object has been disposed. LibSodiumException Thrown if setting the memory to read-only fails. ProtectReadWrite() Marks the secure unmanaged memory buffer as read-write. public void ProtectReadWrite() Exceptions ObjectDisposedException Thrown if the object has been disposed. LibSodiumException Thrown if setting the memory to read-write fails."
  },
  "api/LibSodium.SecureMemory.html": {
    "href": "api/LibSodium.SecureMemory.html",
    "title": "Class SecureMemory | LibSodium.Net",
    "summary": "Class SecureMemory Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for secure memory management using libsodium. These methods help protect sensitive data from being swapped to disk or accessed by other processes. public static class SecureMemory Inheritance object SecureMemory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Create<T>(int) Creates a SecureMemory<T> holding the specified number of items of given type public static SecureMemory<T> Create<T>(int length) where T : unmanaged Parameters length int The number of items Returns SecureMemory<T> Type Parameters T The type of items Equals(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers for equality in constant time. public static bool Equals(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> First buffer to compare. b2 ReadOnlySpan<byte> Second buffer to compare. Returns bool True if the buffers are equal, false otherwise. IsZero(ReadOnlySpan<byte>) Checks if the given byte buffer is zero. public static bool IsZero(ReadOnlySpan<byte> b) Parameters b ReadOnlySpan<byte> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. IsZero<T>(ReadOnlySpan<T>) Checks if the given buffer is zero. public static bool IsZero<T>(ReadOnlySpan<T> b) where T : unmanaged Parameters b ReadOnlySpan<T> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Type Parameters T IsZero<T>(Span<T>) Checks if the given buffer is zero. public static bool IsZero<T>(Span<T> b) where T : unmanaged Parameters b Span<T> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Type Parameters T IsZero<T>(T[]) Checks if the given buffer is zero. public static bool IsZero<T>(T[] b) where T : unmanaged Parameters b T[] The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Type Parameters T MemLock(ReadOnlySpan<byte>) Locks an unmanaged memory buffer, preventing it from being swapped to disk. public static void MemLock(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The span representing the unmanaged memory to lock. Exceptions LibSodiumException Thrown if locking the memory fails. MemLock<T>(ReadOnlySpan<T>) Locks an unmanaged memory buffer, preventing it from being swapped to disk. public static void MemLock<T>(ReadOnlySpan<T> buffer) where T : unmanaged Parameters buffer ReadOnlySpan<T> The span representing the unmanaged memory to lock. Type Parameters T Exceptions LibSodiumException Thrown if locking the memory fails. MemUnlock(ReadOnlySpan<byte>) Unlocks an unmanaged memory buffer, allowing it to be swapped to disk if necessary. public static void MemUnlock(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The span of bytes to unlock. Exceptions LibSodiumException Thrown if unlocking the memory fails. MemUnlock<T>(ReadOnlySpan<T>) Unlocks an unmanaged memory buffer, allowing it to be swapped to disk if necessary. public static void MemUnlock<T>(ReadOnlySpan<T> buffer) where T : unmanaged Parameters buffer ReadOnlySpan<T> The span of bytes to unlock. Type Parameters T Exceptions LibSodiumException Thrown if unlocking the memory fails. MemZero(byte[]) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero(byte[] buffer) Parameters buffer byte[] The span of bytes to zero out. MemZero(Span<byte>) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero(Span<byte> buffer) Parameters buffer Span<byte> The span of bytes to zero out. MemZero<T>(Span<T>) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero<T>(Span<T> buffer) where T : unmanaged Parameters buffer Span<T> The span of bytes to zero out. Type Parameters T MemZero<T>(ref T) Overwrites the memory of the specified buffer with zeros. public static void MemZero<T>(ref T buffer) where T : unmanaged Parameters buffer T A reference to the buffer whose memory will be cleared. Type Parameters T The type of the buffer. Must be an unmanaged type. Remarks This method ensures that the memory of the provided buffer is securely overwritten with zeros. It is typically used to clear sensitive data, such as cryptographic keys, from memory. The method requires the library to be initialized before use. MemZero<T>(T[]) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero<T>(T[] buffer) where T : unmanaged Parameters buffer T[] The span of bytes to zero out. Type Parameters T"
  },
  "api/LibSodium.SecurePadding.html": {
    "href": "api/LibSodium.SecurePadding.html",
    "title": "Class SecurePadding | LibSodium.Net",
    "summary": "Class SecurePadding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for padding and unpadding byte buffers to ensure they meet specified block sizes. public static class SecurePadding Inheritance object SecurePadding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pad(Span<byte>, int, int) Pads the given buffer to the specified block size. public static Span<byte> Pad(Span<byte> buffer, int unpaddedLen, int blockLen) Parameters buffer Span<byte> The buffer to pad. unpaddedLen int The length of the data before padding. blockLen int The block size to pad to. Returns Span<byte> A span of the padded buffer. Exceptions ArgumentException Thrown when BlockLen is less than or equal to 0 or unpaddedLen is greater than buffer length. Unpad(Span<byte>, int) Unpads the given buffer that was padded to a specified block size. public static Span<byte> Unpad(Span<byte> buffer, int blockLen) Parameters buffer Span<byte> The buffer to unpad. blockLen int The block size that was used for padding. Returns Span<byte> A span of the unpadded buffer. Exceptions ArgumentException Thrown when BlockLen is less than or equal to 0. LibSodiumException Thrown when unpadding fails."
  },
  "api/LibSodium.UnmanagedMemorySpanHolder-1.html": {
    "href": "api/LibSodium.UnmanagedMemorySpanHolder-1.html",
    "title": "Class UnmanagedMemorySpanHolder<T> | LibSodium.Net",
    "summary": "Class UnmanagedMemorySpanHolder<T> Namespace LibSodium Assembly LibSodium.Net.dll Holds the pointer and length of an unmanaged memory span for later recreation. Use only with unmanaged memory. [Obsolete(\"This class is deprecated and will be removed in a future version. Use SecureMemory<T> instead.\")] public class UnmanagedMemorySpanHolder<T> where T : unmanaged Type Parameters T The unmanaged type of the span elements. Inheritance object UnmanagedMemorySpanHolder<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class stores the pointer and length of an unmanaged memory span, allowing for its later reconstruction. It is critical to use this class only with spans pointing to unmanaged memory. Using it with managed or stack-allocated spans will result in undefined behavior and potential memory corruption. This holder is particularly useful when a span needs to be accessed in asynchronous operations, lambda expressions, anonymous methods or other contexts with limited scope, such as after awaiting a task. Constructors UnmanagedMemorySpanHolder(ReadOnlySpan<T>) Initializes a new instance of the UnmanagedMemorySpanHolder<T> class from a read-only span. Use only with unmanaged memory. public UnmanagedMemorySpanHolder(ReadOnlySpan<T> span) Parameters span ReadOnlySpan<T> The read-only span pointing to unmanaged memory. Exceptions ArgumentException Thrown when the span is empty. UnmanagedMemorySpanHolder(Span<T>) Initializes a new instance of the UnmanagedMemorySpanHolder<T> class from a writable span. Use only with unmanaged memory. public UnmanagedMemorySpanHolder(Span<T> span) Parameters span Span<T> The read-only span pointing to unmanaged memory. Exceptions ArgumentException Thrown when the span is empty. Methods GetOriginalReadOnlySpan() Creates a new ReadOnlySpan<T> from the held unmanaged memory representing the original ReadOnlySpan<T>. public ReadOnlySpan<T> GetOriginalReadOnlySpan() Returns ReadOnlySpan<T> A ReadOnlySpan<T> representing the original ReadOnlySpan<T> GetOriginalSpan() Creates a new Span<T> from the held unmanaged memory representing the original Span<T> public Span<T> GetOriginalSpan() Returns Span<T> A Span<T> representing the original Span<T> Exceptions InvalidOperationException The original span was read-only, you cannot get a writable span."
  },
  "api/LibSodium.XChaCha20Poly1305.html": {
    "href": "api/LibSodium.XChaCha20Poly1305.html",
    "title": "Class XChaCha20Poly1305 | LibSodium.Net",
    "summary": "Class XChaCha20Poly1305 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the XChaCha20-Poly1305 AEAD construction from Libsodium. public static class XChaCha20Poly1305 Inheritance object XChaCha20Poly1305 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (24). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using XChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key SecureMemory<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using XChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, SecureMemory<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using XChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key SecureMemory<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using XChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.html": {
    "href": "api/LibSodium.html",
    "title": "Namespace LibSodium | LibSodium.Net",
    "summary": "Namespace LibSodium Classes Aegis128L Provides high-level access to the AEGIS-128L AEAD construction from Libsodium. Aegis256 Provides high-level access to the AEGIS-256 AEAD construction from Libsodium. Aes256Gcm Provides high-level access to the AES256-GCM AEAD construction from Libsodium. Base64Encoding Provides methods for Base64 encoding and decoding. ChaCha20Poly1305 Provides high-level access to the ChaCha20-Poly1305 AEAD construction from Libsodium. ChaCha20Poly1305Ietf Provides high-level access to the IETF variant of the ChaCha20-Poly1305 AEAD construction from Libsodium. CryptoAuth Provides methods for message authentication using the crypto_auth API from libsodium. CryptoBox Provides high-level access to the Curve25519-based public-key authenticated encryption (crypto_box) from Libsodium. CryptoGenericHash Provides a high-level interface to the libsodium generic hash function, based on BLAKE2b. CryptoHChaCha20 Deterministically derives 32-byte subkeys using the HChaCha20 core function from a key, a salt-like input and optional domain context. CryptoHkdf Provides HKDF key derivation (RFC 5869) using SHA-256 or SHA-512. CryptoHmacSha256 Computes and verifies HMAC-SHA-256 message authentication codes. CryptoHmacSha512 Computes and verifies HMAC-SHA-512 message authentication codes. CryptoHmacSha512_256 Computes and verifies HMAC-SHA-512/256 message authentication codes. CryptoKeyDerivation Provides deterministic key derivation using libsodium's crypto_kdf_* API, based on the BLAKE2b hash function. CryptoKeyExchange Provides methods for secure, fast, and simple key exchange using libsodium's crypto_kx API. Allows two parties to derive shared session keys securely. CryptoOneTimeAuth Computes and verifies Poly1305 one-time authentication codes. CryptoPasswordHashArgon Provides password hashing and key derivation using Argon2. CryptoPasswordHashScrypt Provides password hashing and key derivation using the Scrypt algorithm. CryptoScalarMult Provides low-level scalar multiplication on Curve25519. This class exposes the crypto_scalarmult and crypto_scalarmult_base functions from libsodium. CryptoSecretStream The CryptoSecretStream class provides methods for performing authenticated encryption and decryption of data streams, with optional additional authenticated data. It is based on the XChaCha20-Poly1305 algorithm. CryptoSha256 Provides one‑shot and streaming SHA‑256 hashing helpers built on libsodium’s crypto_hash_sha256 API. CryptoSha512 Provides one‑shot and streaming SHA‑512 hashing helpers built on libsodium’s crypto_hash_sha512 API. CryptoShortHash Provides a high-level interface to the libsodium short-input hash function, based on SipHash-2-4. CryptoSign Provides digital signature functionality using Ed25519, as implemented by libsodium. CryptoStreamChaCha20 Provides high-level access to the ChaCha20 stream cipher. CryptoStreamChaCha20Ietf Provides high-level access to the ChaCha20Ietf stream cipher. CryptoStreamSalsa20 Provides high-level access to the Salsa20 stream cipher. CryptoStreamXChaCha20 Provides high-level access to the XChaCha20 stream cipher. CryptoStreamXSalsa20 Provides high-level access to the XSalsa20 stream cipher. HexEncoding Provides methods for encoding and decoding hexadecimal strings and byte buffers. LibSodiumException Represents errors that occur during Sodium operations. LibraryInitializer Static class that manages the initialization and configuration of libsodium. LibraryVersion Provides methods to retrieve the version information of the Sodium library. RandomGenerator Static class for random number generation. SecretBox Provides static methods for authenticated symmetric encryption and decryption using the Sodium secretbox primitives, specifically the XSalsa20 stream cipher and Poly1305 MAC for authentication. These methods offer combined encryption/authentication and detached encryption/authentication, with variations for handling nonces and Message Authentication Codes (MACs) within or separate from the ciphertext. SecretStream Provides high-level, stream-based authenticated encryption and decryption using the XChaCha20-Poly1305 algorithm. This class abstracts the complexity of securely processing large data streams, including chunking, authentication, and cryptographic state management. SecureBigUnsignedInteger Provides methods for working with arbitrary large little endian big unsigned integers in a secure way (constant time for a given length) SecureMemory Provides methods for secure memory management using libsodium. These methods help protect sensitive data from being swapped to disk or accessed by other processes. SecureMemory<T> Provides a secure unmanaged memory buffer for unmanaged types, using libsodium for memory protection. This class encapsulates secure memory allocation, read-only protection, and zeroing. SecurePadding Provides methods for padding and unpadding byte buffers to ensure they meet specified block sizes. UnmanagedMemorySpanHolder<T> Holds the pointer and length of an unmanaged memory span for later recreation. Use only with unmanaged memory. XChaCha20Poly1305 Provides high-level access to the XChaCha20-Poly1305 AEAD construction from Libsodium. Interfaces ICryptoIncrementalHash Represents an incremental hash or MAC calculator that processes data in chunks and produces a fixed-size output. Enums Base64Variant Represents Base64 encoding variants. CryptoSecretStreamTag The tags used in the secret stream. PasswordHashArgonAlgorithm Supported password hashing algorithms."
  },
  "features.html": {
    "href": "features.html",
    "title": "Features | LibSodium.Net",
    "summary": "Features LibSodium.Bindings.Net is designed to eventually support all of libsodium’s features while offering a modern and efficient approach to cryptographic operations Modern and Efficient Utilizes Span<T> instead of arrays for enhanced performance. Supports Ahead-of-Time (AOT) compilation by leveraging LibraryImport rather than DllImport. Implemented Features Helpers Constant-time equality testing Hexadecimal encoding and decoding. Base64 encoding and decoding Operations for arbitrary-length unsigned numbers. Testing for all-zero values. Pading Pad and unpad data using the ISO/IEC 7816-4 padding algorithm Secure Memory Zeroing memory Locking memory Guarded heap allocations. Generating random data Random UInt32 , including uniform with upper bound. Random buffer generation, including deterministic option. Closing and stirring the random generator Secret-Key Cryptography Authenticated encryption (SecretBox) Encrypted streams and file encryption Additional Features Coming soon"
  },
  "guide.html": {
    "href": "guide.html",
    "title": "\uD83D\uDD10 Introduction to LibSodium.Net | LibSodium.Net",
    "summary": "\uD83D\uDD10 Introduction to LibSodium.Net LibSodium.Net provides .NET developers with easy-to-use bindings for libsodium, a powerful, modern cryptography library widely recognized for its simplicity and security. This makes it straightforward to add robust cryptographic functionality to your .NET applications. ✨ Why LibSodium.Net? Cross-platform: Seamless support across Windows, Linux, and macOS. Modern Cryptography: Includes authenticated encryption, public-key cryptography, hashing, key derivation, and digital signatures. Simple and Secure API: Designed to reduce complexity, helping you implement cryptography correctly and securely. Secure Memory Handling: Sensitive data management to minimize risks like memory leaks or data exposure. Span over Arrays : Optimized for performance and memory efficiency by using Span<T> instead of heap-allocated arrays. AOT Compatible: Uses LibraryImport (source-generated P/Invoke) instead of DllImport, making it fully compatible with AOT compilation environments. \uD83D\uDE80 Getting Started with LibSodium.Net Here's how you can quickly integrate LibSodium.Net into your .NET projects. \uD83D\uDCE6 Install via NuGet You can easily install LibSodium.Net using the NuGet package manager: CLI Using the .NET CLI: dotnet add package LibSodium.Net Visual Studio Right-click your project in Solution Explorer. Choose Manage NuGet Packages. Search for LibSodium.Net and click Install. Package Manager Console Install-Package LibSodium.Net \uD83E\uDDF1 SecretBox The SecretBox API in LibSodium.Net provides a simple and secure way to perform symmetric authenticated encryption using the XSalsa20 stream cipher and Poly1305 MAC. It supports both combined and detached encryption modes. \uD83D\uDD10 SecretBox Features Symmetric authenticated encryption using XSalsa20-Poly1305 Support for combined and detached modes Automatic or manual nonce handling Tamper-proof via MAC verification \uD83D\uDD12 Encrypting and Decrypting Messages ✅ Combined Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Hello, secure world!\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen]; // Encrypt var result = SecretBox.EncryptCombined(ciphertext, plaintext, key, nonce); // Decrypt Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, result, key, nonce); Console.WriteLine(Encoding.UTF8.GetString(recovered)); ✅ Combined Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce mode test\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen + SecretBox.NonceLen]; var encrypted = SecretBox.EncryptCombined(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, encrypted, key); Console.WriteLine(Encoding.UTF8.GetString(recovered)); \uD83E\uDDE9 Detached Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached mode message\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key, nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac, nonce); Console.WriteLine(Encoding.UTF8.GetString(output)); \uD83E\uDDE9 Detached Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce detached mode\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.NonceLen]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac); Console.WriteLine(Encoding.UTF8.GetString(output)); ⚠️ Error Handling SecretBox methods throw: ArgumentException — if inputs are the wrong size. LibSodiumException — if decryption fails due to tampering or incorrect keys. \uD83D\uDCCC Notes Always use a new random nonce for each encryption. Decryption verifies the MAC before returning plaintext. Use RandomGenerator.Fill() to securely fill nonces and keys. SecretStream The SecretStream class in LibSodium.Net provides secure, authenticated stream-based encryption and decryption using the XChaCha20-Poly1305 algorithm. It's designed to handle large streams of data efficiently and securely. Key Features Authenticated encryption ensures data integrity. Automatic chunking and handling of large data streams. Secure random key generation. Protection against nonce reuse. Basic Usage 1. Generating a Secret Key A secret key must be securely generated and managed: byte[] key = new byte[CryptoSecretStream.KeyLen]; CryptoSecretStream.GenerateKey(key); 2. Encrypting Data Encrypting data streams: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); await SecretStream.EncryptAsync(inputFile, encryptedFile, key); Synchronous Encryption: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); SecretStream.Encrypt(inputFile, encryptedFile, key); 3. Decrypting Data Decrypting the encrypted data back to plaintext: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); await SecretStream.DecryptAsync(encryptedFile, decryptedFile, key); Synchronous Decryption: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); SecretStream.Decrypt(encryptedFile, decryptedFile, key); Security Considerations Secure Key Management: Protect your keys; losing them or exposing them compromises security. Nonce Management: Handled internally by SecretStream; avoid manual nonce reuse. Integrity Checks: Automatic using Poly1305 tags; any tampering results in exceptions. Error Handling Encryption and decryption throw specific exceptions for error conditions: ArgumentException: Invalid arguments (wrong key length, null streams). LibSodiumException: Authentication failed, typically from tampered data. Performance Considerations SecretStream processes data in chunks (default: 64KB) for optimal balance between memory usage and performance. Utilize asynchronous methods (EncryptAsync/DecryptAsync) for IO-bound scenarios for better scalability. \uD83D\uDEE1️ SecureMemory When working with cryptographic data, it's essential to ensure that sensitive information doesn't get leaked through memory dumps, swapping, or garbage collection. LibSodium.Net provides SecureMemory and SecureMemory<T> as robust tools to manage sensitive data safely in unmanaged memory. These APIs leverage libsodium's sodium_malloc, sodium_mlock, and related memory protection functions to offer secure, optionally read-only memory regions that are wiped on disposal. \uD83E\uDDE9 SecureMemory<T> SecureMemory<T> is a managed wrapper around unmanaged memory that stores a span of unmanaged type T. It ensures: Memory is allocated using sodium_allocarray. Memory is wiped with sodium_memzero on disposal. Optional read-only protection using ProtectReadOnly(). Optional read-write toggle with ProtectReadWrite(). Safe access through Span<T>, Memory<T>, ReadOnlySpan<T>, and ReadOnlyMemory<T>. ✅ Basic Usage using var secure = SecureMemory.Create<byte>(32); // Allocate secure memory var span = secure.AsSpan(); // Write access RandomGenerator.Fill(span); // Fill with sensitive data secure.ProtectReadOnly(); // Make it read-only var readOnly = secure.AsReadOnlySpan(); // Safe read-only view secure.ProtectReadWrite(); // Allow writing again \uD83D\uDD12 Safety Features Accessing a SecureMemory<T> object after disposal throws ObjectDisposedException. Accessing writable span when read-only throws InvalidOperationException. Any span or memory obtained prior to disposal becomes invalid. Using it after the object is disposed may result in AccessViolationException. Writing through a span obtained before marking the memory as read-only will throw an AccessViolationException. Memory is finalized and securely freed if not explicitly disposed. \uD83D\uDD27 SecureMemory Utilities SecureMemory also provides utility methods for working with unmanaged memory spans directly: \uD83D\uDD10 Allocate Secure Buffers var span = SecureMemory.Allocate<byte>(64); // Use span... SecureMemory.Free(span); // Free when done All allocations are initialized with 0xDB for predictable testing. \uD83D\uDD10 Zeroing Buffers byte[] buffer = { 1, 2, 3 }; SecureMemory.MemZero(buffer); // Zeros array securely \uD83D\uDD10 Lock/Unlock Memory var span = SecureMemory.Allocate<byte>(128); SecureMemory.MemLock(span); // Prevents swapping to disk SecureMemory.MemUnlock(span); SecureMemory.Free(span); \uD83D\uDD10 Read-Only & Read-Write Protections var span = SecureMemory.Allocate<long>(4); var readOnlySpan = SecureMemory.ProtectReadOnly(span); var writableSpan = SecureMemory.ProtectReadWrite(readOnlySpan); ⚠️ Security Considerations Do not pass managed memory (e.g., new byte[1024]) to Free(). Doing so can corrupt memory. Secure memory functions work only with unmanaged memory allocated by SecureMemory.Allocate(). Avoid using spans or memory references after the backing SecureMemory<T> has been disposed; doing so can cause undefined behavior or AccessViolationException. Writing to memory through a previously obtained span after calling ProtectReadOnly() will throw an AccessViolationException. Always dispose SecureMemory<T> when done, or use using to ensure cleanup. ✅ Unit-Tested Reliability The implementation is backed by comprehensive tests ensuring: Memory is initialized to 0xDB for testing predictability Read-only enforcement and write protection Exception safety on misuse Proper finalization and disposal semantics SecureMemory APIs are essential for handling secrets like keys, passwords, or tokens securely. They give you granular control over how and when memory is allocated, accessed, and cleared—adding another layer of defense in your cryptographic applications."
  },
  "guide/AEAD.html": {
    "href": "guide/AEAD.html",
    "title": "\uD83D\uDD10 AEAD Algorithms | LibSodium.Net",
    "summary": "\uD83D\uDD10 AEAD Algorithms LibSodium.Net provides a unified API for all AEAD (Authenticated Encryption with Associated Data) constructions available in libsodium. These algorithms offer both confidentiality and authenticity, and support optional additional data (AAD) for contextual authentication. Each algorithm supports both combined mode (MAC is part of the ciphertext) and detached mode (MAC is separate), and allows automatic or manual nonce handling. \uD83E\uDDC2 Based on libsodium's AEAD constructions ⚖️ Algorithm Comparison (len in bytes) Algorithm KeyLen NonceLen MacLen XChaCha20-Poly1305 32 24 16 ChaCha20-Poly1305-IETF 32 12 16 ChaCha20-Poly1305 32 8 16 AES256-GCM 32 12 16 AEGIS-256 32 32 32 AEGIS-128L 32 16 32 \uD83D\uDDDD️ Encrypting and Decrypting Use the Encrypt and Decrypt methods from any LibSodium.<Algorithm> class. The API automatically chooses combined or detached mode based on the presence of the optional mac parameter. All AEAD algorithms share the same API: // With ReadOnlySpan<byte> key public static Span<byte> Encrypt( Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default); public static Span<byte> Decrypt( Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) // With SecureMemory<byte> key public static Span<byte> Encrypt( Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, SecureMemory<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default); public static Span<byte> Decrypt( Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, SecureMemory<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) ReadOnlySpan<byte>, byte[] and SecureMemory<byte> are accepted as key inputs. Optional parameters allow for ergonomic usage while retaining full control. Using named arguments for optional ones is highly recommended. \uD83D\uDCCB AEGIS-256 example AEGIS-256 (Combined mode with auto nonce and AAD) Span<byte> key = stackalloc byte[Aegis256.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Secret message\"); var aad = Encoding.UTF8.GetBytes(\"authenticated context\"); var ciphertext = new byte[plaintext.Length + Aegis256.MacLen + Aegis256.NonceLen]; Aegis256.Encrypt(ciphertext, plaintext, key, aad: aad); var decrypted = new byte[plaintext.Length]; Aegis256.Decrypt(decrypted, ciphertext, key, aad: aad); SecureMemory.MemZero(key); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB ChaCha20-Poly1305 example ChaCha20-Poly1305 (Combined mode with AAD, incrementing manual nonce to prevent reuse) Span<byte> key = stackalloc byte[ChaCha20Poly1305.KeyLen]; Span<byte> nonce = stackalloc byte[ChaCha20Poly1305.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var aad = Encoding.UTF8.GetBytes(\"v1\"); var message1 = Encoding.UTF8.GetBytes(\"First message\"); var ciphertext1 = new byte[message1.Length + ChaCha20Poly1305.MacLen]; ChaCha20Poly1305.Encrypt(ciphertext1, message1, key, aad: aad, nonce: nonce); SecureBigUnsignedInteger.Increment(nonce); // increment to prevent reuse (nonce is only 8 bytes) var message2 = Encoding.UTF8.GetBytes(\"Second message\"); var ciphertext2 = new byte[message2.Length + ChaCha20Poly1305.MacLen]; ChaCha20Poly1305.Encrypt(ciphertext2, message2, key, aad: aad, nonce: nonce); SecureMemory.MemZero(key); \uD83D\uDCCB AES256-GCM example AES256-GCM (SecureMemory, detached MAC, autononce, no AAD) using var key = new SecureMemory<byte>(Aes256Gcm.KeyLen); Span<byte> nonce = stackalloc byte[Aes256Gcm.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); key.ProtectReadOnly(); Span<byte> ciphertext = new byte[plaintext.Length]; Span<byte> mac = stackalloc byte[Aes256Gcm.MacLen]; Aes256Gcm.Encrypt(ciphertext, plaintext, key, mac: mac); Span<byte> decrypted = new byte[plaintext.Length]; Aes256Gcm.Decrypt(decrypted, ciphertext, key, mac: mac); ⚠️ Error Handling ArgumentException — invalid input lengths or buffer sizes. LibSodiumException — authentication failure (e.g., tampered data). \uD83D\uDCDD Notes All optional parameters (mac, aad, nonce) should be passed using named arguments for clarity and safety (e.g., aad: data). Nonces must match the algorithm's required length. If omitted, a random nonce is generated automatically and prepended to the ciphertext. Buffers must be large enough to hold output. AAD is optional and not a secret. If provided it must the same for both encryption and decryption. Nonce is optional and not a secret. If not provided (automatic nonce) it is randomly generated and prepended to the ciphertext. If provided (manual nonce) it must be the same for both encryption and decryption. MAC is optional and not a secret. If not provided (combined mode) it is included within the ciphertext. If provided (detached mode) it must be the same for both encryption and decryption. Use RandomGenerator.Fill() to generate cryptographically secure random keys and nonces. Alternatively, keys may be securely stored or derived using a key derivation function. Use SecureMemory<byte> for keys. \uD83D\uDC40 See Also libsodium AEAD constructions API Reference"
  },
  "guide/CryptoAuth.html": {
    "href": "guide/CryptoAuth.html",
    "title": "\uD83D\uDCDC CryptoAuth | LibSodium.Net",
    "summary": "\uD83D\uDCDC CryptoAuth The CryptoAuth API in LibSodium.Net provides secure message authentication using HMAC-SHA-512-256. This is useful for ensuring that a message was not altered and comes from a trusted sender who knows the secret key. ⚠️ Warning: CryptoAuth is deprecated use CryptoHmacSha512_256 instead \uD83E\uDDC2 Based on libsodium’s Secret Key Authentication crypto_auth API ℹ️ See also: API Reference for CryptoAuth \uD83C\uDF1F Features Message authentication using HMAC-SHA-512-256. Fixed-length secret keys and MACs. Strong tampering detection. Safe and efficient API using Span<T>. Fully interoperable with libsodium's crypto_auth functions. \uD83D\uDD0D What is Message Authentication? Unlike encryption, authentication doesn't hide the contents of a message. It ensures that the message has not been tampered with and was created by someone who knows the shared secret key. This is useful for protocols that need to validate integrity and authenticity but don't require confidentiality. CryptoAuth uses: HMAC-SHA-512-256: a strong MAC algorithm with 32-byte output. A 32-byte key shared between sender and receiver. ✨Usage Examples \uD83D\uDCCB Key Generation Span<byte> key = stackalloc byte[CryptoAuth.KeyLen]; CryptoAuth.GenerateKey(key); \uD83D\uDCCB MAC Generation Span<byte> mac = stackalloc byte[CryptoAuth.MacLen]; ReadOnlySpan<byte> message = Encoding.UTF8.GetBytes(\"Message to authenticate\"); CryptoAuth.ComputeMac(mac, message, key); \uD83D\uDCCB MAC Verification bool isValid = CryptoAuth.TryVerifyMac(mac, message, key); if (isValid) { Console.WriteLine(\"MAC is valid.\"); } else { Console.WriteLine(\"MAC is invalid!\"); } \uD83D\uDCCB Strict Verification (throws on failure) CryptoAuth.VerifyMac(mac, message, key); // Throws LibSodiumException if verification fails ⚠️ Error Handling ArgumentException — input buffers are incorrect length. LibSodiumException — MAC computation or verification failed unexpectedly. \uD83D\uDCDD Notes The MAC is 32 bytes (CryptoAuth.MacLen). The secret key must be exactly 32 bytes (CryptoAuth.KeyLen). This API does not encrypt your message, only authenticates it. Use RandomGenerator.Fill() or CryptoAuth.GenerateKey() to create secure keys. Never reuse keys across different algorithms or protocols."
  },
  "guide/CryptoBox.html": {
    "href": "guide/CryptoBox.html",
    "title": "\uD83D\uDEE1️ Public-Key Authenticated Encryption with CryptoBox | LibSodium.Net",
    "summary": "\uD83D\uDEE1️ Public-Key Authenticated Encryption with CryptoBox The CryptoBox API securely encrypts messages between two parties using public-key cryptography. The sender and the recipient each have a key pair, and the message is both encrypted and authenticated. Internally, it uses Curve25519 for key exchange, XSalsa20 for encryption, and Poly1305 for authentication. It supports both combined and detached modes, encryption using either a keypair or a precomputed shared key, and offers automatic or manual nonce handling — all through a unified, ergonomic API. \uD83E\uDDC2Based on libsodium's Authenticated encryption using crypto_box ℹ️ See also: API Reference for CryptoBox \uD83C\uDF1F Features Authenticated encryption with public-key cryptography. Curve25519 key exchange + XSalsa20-Poly1305 encryption. Combined and detached modes. Keypair or shared-key based encryption. Manual or automatic nonce handling. Unified API with optional parameters. Fully Span<T>-based, safe and efficient. \uD83D\uDCCF Constants Name Value Description PublicKeyLen 32 Length of a Curve25519 public key PrivateKeyLen 32 Length of a Curve25519 private key SharedKeyLen 32 Length of a precomputed shared key NonceLen 24 Length of the nonce MacLen 16 Length of the authentication tag SeedLen 32 Length of a deterministic seed \uD83D\uDDDD️ Key Management \uD83D\uDCCB Generate Keypair Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(publicKey, privateKey); \uD83D\uDCCB Deterministic Keypair from Seed Span<byte> seed = stackalloc byte[CryptoBox.SeedLen]; Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypairDeterministically(publicKey, privateKey, seed); \uD83D\uDCCB Precompute Shared Key Span<byte> sharedKey = stackalloc byte[CryptoBox.SharedKeyLen]; CryptoBox.CalculateSharedKey(sharedKey, peerPublicKey, myPrivateKey); ✨ Encrypting and Decrypting Messages The API provides two symmetric pairs: EncryptWithKeypair(...) uses the recipient's public key and sender's private key, while DecryptWithKeypair(...) uses the sender's public key and recipient's private key. EncryptWithSharedKey(...) / DecryptWithSharedKey(...) — use a precomputed shared key. Each pair supports combined and detached modes, and optional manual nonce input. \uD83D\uDCCB Combined Mode (Keypair, Auto Nonce) Span<byte> recipientPk = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> recipientSk = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(recipientPk, recipientSk); Span<byte> senderPk = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> senderSk = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(senderPk, senderSk); var message = Encoding.UTF8.GetBytes(\"Hello, world!\"); Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPk, senderSk); Span<byte> decrypted = stackalloc byte[message.Length]; CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPk, recipientSk); \uD83D\uDCCB Detached Mode (Keypair, Manual Nonce) Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPk, senderSk, mac, nonce); CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPk, recipientPk, mac, nonce); \uD83D\uDCCB Combined Mode (Shared Key, Auto Nonce) Span<byte> sharedKey = stackalloc byte[CryptoBox.SharedKeyLen]; // usually calculated with CalculateSharedKey() Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey); \uD83D\uDCCB Detached Mode (Shared Key, Manual Nonce) Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey, mac, nonce); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey, mac, nonce); ⚠️ Error Handling ArgumentException — invalid input sizes. LibSodiumException — authentication failed or encryption/decryption error. \uD83D\uDCDD Notes In combined mode, the MAC is prepended to the ciphertext. In detached mode, the MAC is returned separately. If you omit the nonce, a secure random one is generated and prepended to the ciphertext. Use EncryptWithKeypair / DecryptWithKeypair for sender-recipient encryption. Use EncryptWithSharedKey / DecryptWithSharedKey when a shared key has been derived beforehand. Always check decrypted data — authentication failure throws. \uD83D\uDC40 See Also libsodium crypto_box documentation API Reference"
  },
  "guide/DesignPhilosophy.html": {
    "href": "guide/DesignPhilosophy.html",
    "title": "\uD83E\uDDED Design Philosophy | LibSodium.Net",
    "summary": "\uD83E\uDDED Design Philosophy LibSodium.Net is built around a simple but powerful idea: Expose all of libsodium’s capabilities exactly as they are, without hiding anything, while making them ergonomic for .NET developers. \uD83D\uDD0D Transparent We don’t reinvent cryptographic primitives. We expose them as they are implemented in libsodium, preserving their guarantees, formats, and conventions. ⚙️ Ergonomic Our API is intuitive and natural in .NET: Full support for Span<byte> and ReadOnlySpan<byte> Combined and detached modes Optional automatic nonce generation Additional authenticated data (AAD) Clear exceptions and strict input validation \uD83D\uDD13 No unnecessary abstractions We don’t force you to wrap keys into opaque classes like Key. You decide how to handle secrets: stackalloc, byte[], derived keys, externally injected material, etc. If you need a higher-level abstraction, you’re free to build one on top of our minimal, consistent API. \uD83C\uDFAF Unopinionated by design LibSodium.Net is not opinionated. It doesn’t tell you how to structure your cryptography — it simply gives you the tools to do it right. \uD83E\uDDEA Built for Developers who want to understand and control what’s happening under the hood. Projects that need to interoperate with other libsodium implementations (in C, Rust, Go, etc.). Systems with flexible key management (e.g. key derivation, ephemeral keys, external sources). Teams who value an API that’s simple, secure, and predictable."
  },
  "guide/DualPhasePasswordHashing.html": {
    "href": "guide/DualPhasePasswordHashing.html",
    "title": "\uD83D\uDD10 Dual-Phase Password Hashing | LibSodium.Net",
    "summary": "\uD83D\uDD10 Dual-Phase Password Hashing This guide describes a dual-phase password hashing scheme that shifts most of the computational cost to the client. It is useful when the server must handle many concurrent logins and wishes to avoid resource exhaustion. \uD83E\uDDC2 Based on libsodium's Password Hashing \uD83D\uDC40 See also: CryptoPasswordHashArgon API Reference \uD83C\uDF1F Overview This scheme allows the server to maintain strong control over password registration while shifting the cost of password hashing to the client during login. A deterministic seed is derived from the user's email, and both sides agree on the hashing parameters. During registration, the server derives the preHash from the password and stores a fast-verifiable finalHash. During login, the client derives the preHash from the password using the same process and sends it to the server. This reduces computational load on the server at login time while maintaining server-side control at registration. \uD83D\uDCCB What is Stored in the Database Each user record must contain: Field Description email User identifier finalHash The result of HashPassword(preHash) \uD83D\uDCDD Since the seed is derived deterministically using BLAKE2b(email), there is no need to store it. It can always be recomputed. ✨ Registration Flow During user registration, the server is responsible for generating the preHash. This guarantees that it was derived from the password using agreed parameters (e.g., Argon2id, high memory and iterations). Although this step consumes server resources, registration is a relatively infrequent operation compared to login. This ensures both control and quality of the derived hash, avoiding the risk of clients sending weak or invalid preHash values. // SERVER-SIDE REGISTRATION (C#) (string password, string email) = ReceiveRegistrationRequest(); // (Optional) Evaluate password strength here before proceeding byte[] seed = new byte[CryptoPasswordHashArgon.SaltLen]; CryptoGenericHash.ComputeHash(seed, Encoding.UTF8.GetBytes(email)); byte[] preHash = new byte[32]; CryptoPasswordHashArgon.DeriveKey( preHash, password, seed, iterations: CryptoPasswordHashArgon.InteractiveIterations, requiredMemoryLen: CryptoPasswordHashArgon.InteractiveMemoryLen); string finalHash = CryptoPasswordHashArgon.HashPassword( preHash, iterations: CryptoPasswordHashArgon.MinIterations, requiredMemoryLen: CryptoPasswordHashArgon.MinMemoryLen); StoreUser(email, finalHash); ✨ Login Flow During login, the client derives the preHash from the password and a deterministic seed calculated as BLAKE2b(email). The server performs a fast verification of the preHash against the stored finalHash. // CLIENT-SIDE (C#) string password = \"correct horse battery staple\"; byte[] seed = new byte[CryptoPasswordHashArgon.SaltLen]; CryptoGenericHash.ComputeHash(seed, Encoding.UTF8.GetBytes(email)); byte[] preHash = new byte[32]; CryptoPasswordHashArgon.DeriveKey( preHash, password, seed, iterations: CryptoPasswordHashArgon.InteractiveIterations, requiredMemoryLen: CryptoPasswordHashArgon.InteractiveMemoryLen); SendToServer(email, preHash); // SERVER-SIDE (C#) (string email, byte[] preHash) = ReceiveLoginAttempt(); string storedHash = GetStoredFinalHash(email); bool isValid = CryptoPasswordHashArgon.VerifyPassword(storedHash, preHash); \uD83D\uDCDD The client-side DeriveKey(...) call must use high-cost parameters (e.g., InteractiveIterations), while the server-side HashPassword(...) uses minimal parameters (MinIterations, MinMemoryLen) for fast verification only. \uD83D\uDD0D Design Rationale This implementation differs from the scheme proposed in the libsodium documentation, where the client is always responsible for computing the preHash. That design has a key limitation: during registration, the server cannot validate whether the preHash was correctly derived. The client could submit arbitrary data as preHash with no way for the server to check that strong parameters were used or that the password meets any policy. By contrast, in this variation: The server derives the preHash during registration. The seed is generated deterministically using keyless BLAKE2b(email), avoiding storage or synchronization. During login, the client derives the preHash using the same logic. This ensures the server has full control during registration and avoids the complexity of managing a secret key or exposing a public seed endpoint. \uD83D\uDD01 Why Not Use BLAKE2b(email, key)? Using a keyed hash like BLAKE2b(email, key) seems more secure at first glance, but it requires exposing a public endpoint to return the seed to the client. Since the client cannot compute it alone, the endpoint must be public, meaning an attacker can access it too. This defeats the purpose of using a keyed hash and adds deployment complexity (key rotation, synchronization). \uD83D\uDCCA Comparison with Libsodium's Original Model Aspect Libsodium Documentation This Variation preHash derivation (register) Client Server — allows password strength checks preHash derivation (login) Client Client Seed generation BLAKE2b(email, key) BLAKE2b(email) (keyless, stateless) Seed storage Not stored Not stored (deterministic) Seed delivery Requires public endpoint Not required Server validates preHash? ❌ No ✅ Yes — at registration Complexity Medium (key management, endpoint) Low Server login cost Low Low Server registration control ❌ None ✅ Full Server registration cost Low High — expensive Argon2id on server \uD83D\uDEA8 Preventing DoS in Registration Since registration requires the server to compute an expensive Argon2id derivation, it is essential to protect this endpoint from abuse. Without mitigations, an attacker could issue a large number of fake registrations to exhaust CPU or memory. ✅ Recommended defenses Mitigation Purpose CAPTCHA Blocks automated/bot-driven registration attempts before they start Rate limiting per IP Prevents rapid bursts of expensive registrations You can combine these strategies depending on your threat model and system constraints. For most public-facing systems, using CAPTCHA and rate limiting is often sufficient. ⚠️ Security Considerations ✅ Pros Offloads CPU/memory-intensive hash to the client. Reduces server-side DoS risk from mass login attempts. Compatible with libsodium.js on the web. ❌ Cons If preHash is intercepted, it can be used to login (it's equivalent to a password). If the database is compromised, brute-forcing preHash is easier than brute-forcing the original password. \uD83E\uDDE0 Implications Use HTTPS strictly to protect preHash in transit. Treat preHash as a password: never store or reuse it elsewhere. Consider binding preHash to device context or ephemeral session to mitigate token theft. \uD83D\uDCDD Summary This scheme is not a security upgrade over traditional Argon2-on-server. It is a performance optimization that trades some security margin for scalability. Only use it if server resource exhaustion is a real concern. For most applications, prefer the traditional approach unless you: Trust the client device. Require high throughput authentication. Accept the risks of treating preHash as a reusable login token. \uD83D\uDC40 See Also \uD83E\uDDC2 libsodium password hashing \uD83E\uDDC2 libsodium.js ℹ️ API Reference: CryptoPasswordHashArgon"
  },
  "guide/Encoding.html": {
    "href": "guide/Encoding.html",
    "title": "✏️ Encoding | LibSodium.Net",
    "summary": "✏️ Encoding LibSodium.Net provides high-performance, secure encoding utilities to convert binary data to and from human-readable formats. The library currently supports two types of encoding: Hexadecimal via HexEncoding Base64 via Base64Encoding These classes are wrappers around libsodium's encoding utilities, providing constant-time and safe operations using spans. \uD83E\uDDC2 Based on libsodium’s Hexadecimal encoding/decoding and Base64 encoding/decoding ℹ️ See also: API Reference for HexEncoding, API Reference for Base64Encoding \uD83D\uDD10 Security Considerations These encoding functions are implemented in constant time with respect to input size, which means they avoid data-dependent branching and timing variations. This makes them resistant to side-channel attacks, such as timing attacks, which can leak information through observable differences in computation time. LibSodium.Net ensures that these security properties are preserved in its managed API by: Using Span<T> and avoiding intermediate heap allocations. Delegating directly to libsodium’s hardened, constant-time implementations. These properties make HexEncoding and Base64Encoding suitable for encoding sensitive data like cryptographic keys, hashes, tokens, and other secrets. ✨ HexEncoding HexEncoding provides methods to encode a byte array into a lowercase hexadecimal string and decode from hexadecimal back into binary. All operations are span-based for performance and safety. \uD83D\uDCCB Encode to hex Span<byte> bin = stackalloc byte[] { 0x01, 0x23, 0x45 }; string hex = HexEncoding.BinToHex(bin); // \"012345\" You can also write the hex into a preallocated Span<char>: Span<char> hexBuffer = stackalloc char[bin.Length * 2]; HexEncoding.BinToHex(bin, hexBuffer); \uD83D\uDCCB Decode from hex string hex = \"0123456789abcdef\"; Span<byte> buffer = stackalloc byte[hex.Length / 2]; HexEncoding.HexToBin(hex, buffer); You can also ignore separators such as colons: string formatted = \"01:23:45:67\"; HexEncoding.HexToBin(formatted, buffer, \":\"); ⚠️ Exceptions ArgumentException: when hex buffer is too small. LibSodiumException: on malformed hex input or destination buffer too small. ✨ Base64Encoding Base64Encoding supports multiple Base64 variants, including URL-safe and no-padding modes. \uD83D\uDCD8 Base64 variants public enum Base64Variant { Original, OriginalNoPadding, UrlSafe, UrlSafeNoPadding } These map directly to sodium_base64_VARIANT_* in libsodium. \uD83D\uDCCB Encode to Base64 Span<byte> bin = stackalloc byte[] { 1, 2, 3, 4 }; string b64 = Base64Encoding.BinToBase64(bin, Base64Variant.Original); You can also write the result into a Span<char>: Span<char> buffer = stackalloc char[Base64Encoding.GetBase64EncodedLen(bin.Length, Base64Variant.Original)]; Base64Encoding.BinToBase64(bin, buffer, Base64Variant.Original); \uD83D\uDCCB Decode from Base64 string b64 = \"AQIDBA==\"; Span<byte> output = stackalloc byte[Base64Encoding.GetBase64DecodedMaxLen(b64.Length)]; Base64Encoding.Base64ToBin(b64, output, Base64Variant.Original); Optional ignored characters (e.g., formatting spaces): Base64Encoding.Base64ToBin(\" AQ ID BA == \", output, Base64Variant.Original, \" \"); ⚠️ Exceptions ArgumentException: buffer too small. LibSodiumException: invalid Base64 input or mismatched variant. These encoding utilities are highly optimized, secure, and suitable for cryptographic applications where constant-time guarantees and low-level memory control are essential."
  },
  "guide/Hashing.html": {
    "href": "guide/Hashing.html",
    "title": "\uD83D\uDD00 Hashing | LibSodium.Net",
    "summary": "\uD83D\uDD00 Hashing LibSodium.Net provides multiple hashing APIs for different use cases: API Algorithm Use Case GenericHash BLAKE2b Cryptographic hash with optional key. Use for MAC, PRF, fingerprints. ShortHash SipHash‑2‑4 Keyed hash designed to prevent collisions in hash tables. Fast for short inputs. CryptoSha256 SHA‑256 Fast fixed‑length (32‑byte) hash for integrity checks, digital signatures, checksums. CryptoSha512 SHA‑512 Fast fixed‑length (64‑byte) hash for high‑strength integrity and digital signatures. CryptoPasswordHashArgon Argon2id/i13 Password hashing and key derivation (slow & memory‑hard) CryptoPasswordHashScrypt Scrypt Password hashing and key derivation (slow & memory‑hard, legacy) \uD83D\uDCDD SHA‑2 functions are not suitable for password hashing or key derivation. Use Argon2 or scrypt instead. \uD83E\uDDC2 Based on libsodium’s Hashing \uD83E\uDDC2 Based on Password Hashing \uD83E\uDDC2 Based on SHA-2 ℹ️ API Reference: CryptoGenericHash ℹ️ API Reference: CryptoSha256 ℹ️ API Reference: CryptoSha512 ℹ️ API Reference: CryptoShortHash ℹ️ API Reference: CryptoPasswordHashArgon ℹ️ API Reference: CryptoPasswordHashScrypt \uD83C\uDF1F Features Cryptographic hashing with variable output length (GenericHash) Fast fixed‑length hashing (CryptoSha256 & CryptoSha512) SipHash‑based keyed hash for short inputs (ShortHash) Password hashing and key derivation using Argon2 (CryptoPasswordHash) All methods are allocation‑free, Span‑based, and deterministic (except password hash, which is randomized) Stream and async support for large input hashing (GenericHash, CryptoSha256, CryptoSha512) Incremental (multi-part) hashing (GenericHash, CryptoSha256, CryptoSha512) \uD83D\uDDDD️ Key Management Some hash functions accept a key (e.g., GenericHash, ShortHash), while others produce one as output (e.g., Argon2, Scrypt). This section explains how to pass and store keys safely. Keys can be provided or stored using the following types: SecureMemory<byte> — most secure option, with memory protection and automatic zeroing. Span<byte> / ReadOnlySpan<byte> — fast and stack-allocated. Ideal for synchronous use. byte[] — interoperable and usable in both sync and async contexts. Memory<byte> / ReadOnlyMemory<byte> — for use with async methods. \uD83D\uDCDD Use Span<T> for high-performance local operations, and SecureMemory<byte> to protect secrets in memory. When using key derivation functions (e.g., Argon2, Scrypt): Examples: // SecureMemory<byte> using var key = new SecureMemory<byte>(GenericHash.KeyLen); RandomGenerator.Fill(key); key.ProtectReadOnly(); // Span<byte> Span<byte> key = stackalloc byte[GenericHash.KeyLen]; RandomGenerator.Fill(key); // byte[] var key = new byte[GenericHash.KeyLen]; RandomGenerator.Fill(key); Tips: Store the derived key in SecureMemory<byte>, mark it as read-only using .ProtectReadOnly(), and dispose it properly. Never reuse keys across different algorithms or protocols. Even if the key size is compatible, doing so weakens isolation and security boundaries. Use a strong, random salt and a context-specific derivation strategy. Generate a fresh random key with RandomGenerator.Fill() and store it securely (e.g., Azure Key Vault, environment variable, HSM). Rotate keys periodically. ✨ GenericHash — BLAKE2b BLAKE2b is a cryptographic hash function designed as a faster and safer alternative to SHA‑2. It provides high‑performance hashing with optional key support, making it suitable for: Cryptographic checksums (fingerprints) Message authentication codes (MACs) Deriving identifiers or integrity tags Hashing files or streams of arbitrary size Unique deterministic identifiers Pseudorandom functions (PRF) when keyed By default, it produces 32‑byte output, but can be configured to return between 16 and 64 bytes. It supports keyed hashing for MAC‑like or PRF behavior, using a key of 32 bytes by default (configurable between 16 and 64 bytes), or unkeyed hashing for general‑purpose use. \uD83D\uDCCF Constants Name Value Description HashLen 32 Default output length MinHashLen 16 Minimum output length MaxHashLen 64 Maximum output length KeyLen 32 Default key length MinKeyLen 16 Minimum key length MaxKeyLen 64 Maximum key length \uD83D\uDCCB Hashing with GenericHash With optional key: Span<byte> hash = stackalloc byte[CryptoGenericHash.HashLen]; CryptoGenericHash.ComputeHash(hash, message); // unkeyed CryptoGenericHash.ComputeHash(hash, message, key); // keyed from a stream: using var stream = File.OpenRead(\"large-input.dat\"); CryptoGenericHash.ComputeHash(hash, stream); Async stream support: using var stream = File.OpenRead(\"large-input.dat\"); await CryptoGenericHash.ComputeHashAsync(hash, stream, key); ✨ CryptoSha256 — SHA‑256 CryptoSha256 offers a high‑speed, fixed‑length (32‑byte) SHA‑256 implementation built directly on libsodium’s crypto_hash_sha256 API. Use it when you need interoperability with existing SHA‑256 digests (e.g., digital signatures, blockchain, TLS certificate fingerprints) or whenever a fixed 32‑byte checksum is required. \uD83D\uDCCF Constants Name Value Description HashLen 32 Output length (32 bytes) \uD83D\uDCCB Hashing with CryptoSha256 Hash a byte array: Span<byte> hash = stackalloc byte[CryptoSha256.HashLen]; CryptoSha256.ComputeHash(hash, message); Hash a stream (buffered, sync): using var stream = File.OpenRead(\"video.mp4\"); CryptoSha256.ComputeHash(hash, stream); Async stream hashing: await CryptoSha256.ComputeHashAsync(hash, stream); ✨ CryptoSha512 — SHA‑512 CryptoSha512 is a fixed‑length (64‑byte) implementation of SHA‑512 via libsodium’s crypto_hash_sha512. It is usually faster than SHA‑256 on modern 64‑bit CPUs and provides a larger security margin. \uD83D\uDCCF Constants Name Value Description HashLen 64 Output length (64 bytes) \uD83D\uDCCB Hashing with CryptoSha512 Hash a Span : Span<byte> hash = stackalloc byte[CryptoSha512.HashLen]; CryptoSha512.ComputeHash(hash, message); Hash a stream (buffered, sync): using var stream = File.OpenRead(\"backup.tar\"); CryptoSha512.ComputeHash(hash, stream); Async stream hashing: await CryptoSha512.ComputeHashAsync(hash, stream); ✨ Incremental Hashing In some scenarios, data to be hashed is not available as a single contiguous buffer — for example, when you want to compute hash(a || b || c) from multiple inputs. LibSodium.Net offers incremental hashing for this purpose. The following classes support incremental hashing: CryptoGenericHash (BLAKE2b, optionally keyed) CryptoSha256 (SHA-256) CryptoSha512 (SHA-512) These types expose an incremental API via the ICryptoIncrementalHash interface. Compute hash from multiple parts: Span<byte> hash = stackalloc byte[CryptoSha256.HashLen]; using var hasher = CryptoSha256.CreateIncrementalHash(); hasher.Update(Encoding.UTF8.GetBytes(\"header\")); hasher.Update(Encoding.UTF8.GetBytes(\"payload\")); hasher.Update(Encoding.UTF8.GetBytes(\"footer\")); hasher.Final(hash); This pattern ensures correctness and efficiency when you want to hash logically grouped inputs without allocating or copying them into a single buffer. With a keyed BLAKE2b hash Span<byte> key = stackalloc byte[CryptoGenericHash.KeyLen]; RandomGenerator.Fill(key); Span<byte> hash = stackalloc byte[32]; var part1 = Encoding.UTF8.GetBytes(\"hello\"); var part2 = Encoding.UTF8.GetBytes(\"world\"); using var hasher = CryptoGenericHash.CreateIncrementalHash(key, hash.Length); hasher.Update(part1); hasher.Update(part2); hasher.Final(hash); ℹ️ The Final() method may only be called once per hash instance. You must create a new instance for each new computation. ✨ ShortHash — SipHash‑2‑4 ⚠️ ShortHash is not a cryptographic hash. Do not use it for fingerprinting, content integrity, password hashing, or digital signatures. SipHash is a fast keyed hash function optimized for short inputs. It is designed to mitigate hash‑flooding attacks in hash tables and similar data structures where untrusted input might lead to performance degradation. It should be used for: Hash table key protection Fast authentication of short data Use cases where speed and DoS‑resistance are more important than collision resistance SipHash is always keyed, and its output is always 8 bytes. \uD83D\uDCCF Constants Name Value Description HashLen 8 Output length (8 bytes) KeyLen 16 Key length (16 bytes) \uD83D\uDCCB Hashing with ShortHash ℹ️ key is required Span<byte> hash = stackalloc byte[CryptoShortHash.HashLen]; CryptoShortHash.ComputeHash(hash, message, key); ✨ PasswordHashArgon Secure password hashing and key derivation using Argon2 (Argon2id / Argon2i13). This algorithm is specifically designed to defend against brute‑force attacks by requiring significant computational work and memory. It is ideal for storing passwords, deriving keys from passphrases, or implementing authentication mechanisms. Unlike fast cryptographic hash functions (like SHA‑256 or BLAKE2b), Argon2 is deliberately slow and memory‑intensive, which drastically increases the cost of large‑scale password cracking (e.g., GPU attacks). LibSodium.Net exposes both Argon2id (recommended) and Argon2i. The cost parameters (iterations and memory) can be tuned to balance security and performance depending on the context: Interactive – suitable for login forms. Moderate – for higher‑value secrets. Sensitive – for long‑term or critical secrets. \uD83D\uDCCF Constants Name Value Description SaltLen 16 Length of the salt in bytes MinKeyLen 16 Minimum key length for derivation EncodedLen 128 Length of the encoded hash string Prefix \"$argon2id$\" Prefix for Argon2id encoded hash MinMemoryLen 8 KiB Minimum acceptable memory for hashing MinIterations 1 Minimum acceptable iterations InteractiveIterations 2 Iteration count for interactive targets InteractiveMemoryLen 64 MiB Memory usage for interactive targets ModerateIterations 3 For app secrets or backup keys ModerateMemoryLen 256 MiB For app secrets or backup keys SensitiveIterations 4 Iteration count for sensitive targets SensitiveMemoryLen 1 GiB Memory usage for sensitive targets \uD83D\uDCCB Working with PasswordHashArgon Hash a password (encoded, random salt): string hash = CryptoPasswordHash.HashPassword(\"my password\"); Verify a password: bool valid = CryptoPasswordHash.VerifyPassword(hash, \"my password\"); Derive a secret key from a password (e.g., for encryption): using var key = new SecureMemory(32); Span<byte> salt = stackalloc byte[CryptoPasswordHash.SaltLen]; RandomGenerator.Fill(salt); CryptoPasswordHash.DeriveKey(key, \"password\", salt); You can customise the computational cost: CryptoPasswordHash.DeriveKey( key, \"password\", salt, iterations: CryptoPasswordHash.SensitiveIterations, requiredMemoryLen: CryptoPasswordHash.SensitiveMemoryLen); ✨ PasswordHashScrypt Password hashing and key derivation using scrypt, a memory-hard function introduced before Argon2. Though not side-channel resistant, it is still widely used and interoperable. LibSodium.Net improves over libsodium by offering consistent tuning options (Min, Interactive, Moderate, Sensitive) and full validation coverage. \uD83D\uDCCF Constants Name Value Description SaltLen 32 Length of the salt in bytes MinKeyLen 16 Minimum key length for derivation EncodedLen 102 Length of the encoded hash string Prefix \"$7$\" Prefix for scrypt encoded hash MinIterations 1024 (2^10) Minimum recommended iterations MinMemoryLen 32 KiB (2^15) Minimum recommended memory InteractiveIterations 524288 (2^19) For login/password use InteractiveMemoryLen 16 MiB (2^24) For login/password use ModerateIterations 4194304 (2^22) For app secrets or backup keys ModerateMemoryLen 128 MiB (2^27) For app secrets or backup keys SensitiveIterations 33554432 (2^25) For long-term or high-value secrets SensitiveMemoryLen 1 GiB (2^30) For long-term or high-value secrets \uD83D\uDCCB Working with PasswordHashScrypt Hash and verify: string hash = CryptoPasswordHashScrypt.HashPassword(\"my password\"); bool valid = CryptoPasswordHashScrypt.VerifyPassword(hash, \"my password\"); Deriving a key from a password: using var key = new SecureMemory<byte>(32); Span<byte> salt = stackalloc byte[CryptoPasswordHashScrypt.SaltLen]; RandomGenerator.Fill(salt); CryptoPasswordHashScrypt.DeriveKey(key, \"password\", salt, iterations: CryptoPasswordHashScrypt.ModerateIterations, requiredMemoryLen: CryptoPasswordHashScrypt.ModerateMemoryLen); ⚠️ Error Handling ArgumentException — when input or key lengths are invalid ArgumentOutOfRangeException — when iterations or memory limits are too low LibSodiumException — if the underlying native function fails \uD83D\uDCDD Notes GenericHash is based on BLAKE2b and supports variable‑length output and optional keys. CryptoSha256 and CryptoSha512 provide interoperable SHA‑2 digests and are the best choice when you need a fixed‑length checksum or compatibility with external systems. ShortHash is based on SipHash‑2‑4 — not a general‑purpose cryptographic hash, but a keyed primitive for protecting hash tables. CryptoPasswordHashArgon uses Argon2id/Argon2i13 with computational and memory hardness. All hash functions are deterministic: same input and key produce same output — except CryptoPasswordHash.HashPassword, which includes a random salt and produces a different hash each time. Scrypt is not side-channel resistant. Use Argon2i13 or Argon2id13 for high-security or shared-host scenarios. Use ShortHash only when you can keep the key secret. \uD83E\uDDED Choosing the Right Hash API Scenario Recommended API Variable‑length cryptographic checksum GenericHash Fixed‑length 32‑byte digest (e.g., TLS cert fingerprint) CryptoSha256 Fixed‑length 64‑byte digest, higher speed on x64 CryptoSha512 MAC (Message Authentication Code) or PRF (Pseudo Random Function) GenericHash (with key) Hashing short keys in tables ShortHash Password storage / passphrase‑derived keys CryptoPasswordHashArgon Legacy Password storage / passphrase‑derived keys CryptoPasswordHashScrypt \uD83D\uDC40 See Also ℹ️ API Reference: CryptoGenericHash ℹ️ API Reference: CryptoSha256 ℹ️ API Reference: CryptoSha512 ℹ️ API Reference: CryptoShortHash ℹ️ API Reference: CryptoPasswordHashArgon ℹ️ API Reference: CryptoPasswordHashScrypt \uD83E\uDDC2 libsodium Hashing \uD83E\uDDC2 libsodium Password Hashing \uD83E\uDDC2 libsodium SHA-2"
  },
  "guide/KeyDerivation.html": {
    "href": "guide/KeyDerivation.html",
    "title": "\uD83D\uDD11 Key Derivation in LibSodium.Net | LibSodium.Net",
    "summary": "\uD83D\uDD11 Key Derivation in LibSodium.Net LibSodium.Net provides three powerful primitives for key derivation: CryptoKeyDerivation: libsodium's native KDF built on BLAKE2b. CryptoHChaCha20: a fast, stateless KDF based on the HChaCha20 core function. CryptoHkdf: a standard HKDF implementation based on HMAC (SHA-256 or SHA-512). \uD83E\uDDC2 Based on libsodium's Key derivation \uD83E\uDDC2 Based on libsodium's HKDF ℹ️ See also: API Reference for CryptoKeyDerivation ℹ️ See also: API Reference for HKDF ℹ️ See also: API Reference for CryptoHChaCha20 This guide compares all options, shows how to choose between them, and offers practical usage advice. \uD83D\uDCCB Primitives Comparative Feature CryptoKeyDerivation Hkdf CryptoHChaCha20 Algorithm BLAKE2b HMAC-SHA-256 / HMAC-SHA-512 HChaCha20 Based on crypto_kdf_* API crypto_kdf_hkdf_{sha256,sha512} crypto_core_hchacha20 Standard No RFC 5869 No Derivation style Single-step Extract-then-expand Single-step Inputs masterKey, subkeyId, context ikm, salt, info key, input, [context] Deterministic Yes Yes Yes Performance Faster Slower Fastest Interoperability Low High Medium (used in XChaCha20) Subkey uniqueness driver ulong subkeyId + 8-byte context Arbitrary salt and info 16-byte input + optional context Max identifier size 16 bytes total (id + context) Arbitrary 32 bytes (input + context) Collisions with random IDs Realistic risk Practically zero (if inputs are long) Low risk (if input is random) State requirement Yes (track last subkeyId) No No Stateless randomness Not safe Safe Safe Best practice Use a database sequence Use long random salt/info Use random 16-byte input SHA-256 vs SHA-512 in HKDF SHA-256: smaller hash, historically faster on constrained environments (e.g., old ARM cores). SHA-512: stronger and typically faster on modern 64-bit CPUs due to optimized instructions and wider registers. Use SHA-512 unless you have specific compatibility or performance constraints. ✨ When to Use Each Choose HKDF when: You need RFC 5869 compliance. You want to avoid state tracking. You can safely randomize inputs (salt/info). You’re interoperating with non-libsodium systems. Choose CryptoKeyDerivation when: You need to derive many related subkeys (e.g., message sequence). You control the environment and want maximum speed. You can track subkeyId safely (e.g., in a DB or in-memory). \uD83D\uDCDD Example: For a secure message stream, generate one random subkeyId per session, then increment it for each message. This yields high performance and unique keys. Choose CryptoHChaCha20 when: You want stateless deterministic derivation from a master key. You need nonce extension for AES-GCM or similar AEAD schemes. You want domain separation via a fixed 16-byte context. ✨ CryptoKeyDerivation This API is built on libsodium’s BLAKE2b-based crypto_kdf_* functions. It allows fast deterministic derivation of many subkeys from a single master key and a context+id pair. \uD83D\uDCCF Constants Name Value Description MasterKeyLen 32 Length of master key (32 bytes) ContextLen 8 Length of context string (8 bytes) MinSubkeyLen 16 Minimum subkey length MaxSubkeyLen 64 Maximum subkey length \uD83D\uDCCB Generate a master key You can use CryptoKeyDerivation.GenerateMasterKey to generate a cryptographically secure random master key. Alternatively, the key may be securely stored or derived. Master key can be SecureMemory<byte>, Span<byte>, or byte[] (implicitly convertible to Span<byte>) // SecureMemory masterKey using var masterKey = new SecureMemory<byte>(CryptoKeyDerivation.MasterKeyLen); CryptoKeyDerivation.GenerateMasterKey(masterKey); // Span masterKey Span<byte> masterKey = stackalloc byte[CryptoKeyDerivation.MasterKeyLen]; CryptoKeyDerivation.GenerateMasterKey(masterKey); // byte[] masterKey var masterKey = new byte[CryptoKeyDerivation.MasterKeyLen]; CryptoKeyDerivation.GenerateMasterKey(masterKey); \uD83D\uDCCB Derive a subkey You derive a subkey from a master key, a subkey id and a context using DeriveSubKey() method. Subkeys can be SecureMemory<byte>, Span<byte>, or byte[] (implicitly convertible to Span<byte>) // SecureMemory subkey using var subkey = new SecureMemory<byte>(32); CryptoKeyDerivation.DeriveSubkey(masterKey, subkey, 42, \"MYCTX\"); // Span subkey Span<byte> subkey = stackalloc byte[32]; CryptoKeyDerivation.DeriveSubkey(masterKey, subkey, 42, \"MYCTX\"); // byte[] subkey using var subkey = new byte[32]; CryptoKeyDerivation.DeriveSubkey(masterKey, subkey, 42, \"MYCTX\"); \uD83D\uDCDD Context must be exactly 8 bytes. Strings shorter than 8 are zero-padded. ✨ CryptoHChaCha20 CryptoHChaCha20 provides fast, deterministic subkey derivation using the HChaCha20 function, originally designed for use in XChaCha20. It is suitable for nonce extension, domain separation and stateless derivation of subkeys from a master key. \uD83E\uDDC2 Based on libsodium’s crypto_core_hchacha20 ℹ️ API Reference: CryptoHChaCha20 \uD83D\uDCCF Constants Name Value Description KeyLen 32 Length of the master key InputLen 16 Length of the salt-like input ContextLen 16 Length of the optional domain context SubKeyLen 32 Length of the derived subkey \uD83D\uDCCB Derive a subkey You can derive a 32-byte subkey using a 32-byte master key and a 16-byte input. You may optionally provide a 16-byte domain context. using var subKey = new SecureMemory<byte>(CryptoHChaCha20.SubKeyLen); using var key = new SecureMemory<byte>(CryptoHChaCha20.KeyLen); Span<byte> input = stackalloc byte[CryptoHChaCha20.InputLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(input); CryptoHChaCha20.DeriveSubkey(key, subKey, input, \"app-context\"); \uD83D\uDCCB Example: AES256-GCM nonce extension HChaCha20 can be used to securely extend a nonce for AES256-GCM: // this is a sample to demonstrate nonce extension using HChaCha20 // it extends a 12-byte AES256-GCM nonce into a 28-byte nonce Span<byte> key = Convert.FromHexString(\"000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\"); // 16 + 12 = 28 bytes total Span<byte> extendedNonce = stackalloc byte[CryptoHChaCha20.InputLen + Aes256Gcm.NonceLen]; RandomGenerator.Fill(extendedNonce); Span<byte> subkey = stackalloc byte[CryptoHChaCha20.SubKeyLen]; // first 16 bytes of nonce are used as input to derive the subkey var input = extendedNonce.Slice(0, CryptoHChaCha20.InputLen); CryptoHChaCha20.DeriveSubkey(key, subkey, input); ReadOnlySpan<byte> plaintext = \"some plaintext data to encrypt\"u8; Span<byte> ciphertext = stackalloc byte[plaintext.Length + Aes256Gcm.MacLen]; // the next 12 bytes of extended nonce are used as the AES256-GCM nonce var nonce = extendedNonce.Slice(CryptoHChaCha20.InputLen, Aes256Gcm.NonceLen); Aes256Gcm.Encrypt(ciphertext, plaintext, subkey, nonce: nonce); ✨ HKDF HKDF implements RFC 5869 using HMAC-SHA-256 or HMAC-SHA-512. It is compatible with System.Security.Cryptography.HKDF.DeriveKey and produces identical outputs when the inputs match. \uD83D\uDCDD LibSodium.Net's HKDF is fully interoperable with System.Security.Cryptography.HKDF from .NET — both produce identical outputs when using the same inputs and hash algorithm. Key, IKM (Initial Key Material), PRK (Pseudo-Random Key), and OKM (Output Key Material) can be provided as SecureMemory<byte>, Span<byte> / ReadOnlySpan<byte>, or byte[] (implicitly convertible to Span<byte>) for synchronous methods. For asynchronous streaming methods, use SecureMemory<byte>, Memory<byte> / ReadOnlyMemory<byte>, or byte[] (implicitly convertible to Memory<byte> / ReadOnlyMemory<byte>). \uD83D\uDCCF Constants Name SHA256 SHA512 Description PrkLen 32 64 Length of PRK (pseudorandom key) MinOkmLen 4 4 Minimum output length MaxOkmLen 8160 16320 Maximum output length (255 * hash size) \uD83E\uDE84 HKDF Phases Extract: Converts input keying material (IKM) and salt into a pseudorandom key (PRK). Expand: Derives the final output key material (OKM) from the PRK and optional info. DeriveKey: Performs both steps in one call. When to use which: Use DeriveKey for simple cases where no reuse of PRK is needed. Use Extract + Expand when you want to reuse PRK for multiple outputs. Use Expand when you already have a good master key. \uD83D\uDCCB Derive a key in one step // Span key Span<byte> key = stackalloc byte[64]; HKDF.DeriveKey(HashAlgorithmName.SHA512, ikm, key, salt, info); // SecureMemory key using var key = new SecureMemory<byte>(64); HKDF.DeriveKey(HashAlgorithmName.SHA512, ikm, key, salt, info); \uD83D\uDCCB Separate extract and expand Span<byte> prk = stackalloc byte[HKDF.Sha512PrkLen]; HKDF.Extract(HashAlgorithmName.SHA512, ikm, salt, prk); Span<byte> okm = stackalloc byte[64]; HKDF.Expand(HashAlgorithmName.SHA512, prk, okm, info); \uD83D\uDCCB Extract from stream (incremental entropy) This allows deriving a PRK from streamed IKM. using var stream = File.OpenRead(\"large-secret.bin\"); var prk = new byte[HKDF.Sha512PrkLen]; await HKDF.ExtractAsync(HashAlgorithmName.SHA512, stream, salt, prk); ⚠️ Error Handling ArgumentException — for invalid sizes or null contexts. ArgumentOutOfRangeException — when lengths are outside defined bounds. NotSupportedException — if unsupported hash algorithm is selected. LibSodiumException — if the native call fails. \uD83D\uDCDD Notes Prefer DeriveKey() when simplicity is more important than flexibility. Use Extract/Expand for advanced scenarios: PRK reuse, incremental entropy, or interoperability layers. Only HKDF supports streaming input for IKM. CryptoKeyDerivation is deterministic and optimized for fast sequential subkey derivation. Using SecureMemory<byte> for keys and ikm's is strongly recommended, as it protects key material in unmanaged memory with automatic zeroing and access control. \uD83D\uDC40 See Also libsodium key derivation RFC 5869 API Reference: CryptoKeyDerivation API Reference: HKDF"
  },
  "guide/KeyExchange.html": {
    "href": "guide/KeyExchange.html",
    "title": "\uD83D\uDD11 Key Exchange with CryptoKeyExchange | LibSodium.Net",
    "summary": "\uD83D\uDD11 Key Exchange with CryptoKeyExchange Securely establishing a shared secret between two parties is a foundational step for any encrypted communication channel. LibSodium.Net wraps libsodium’s crypto_kx primitive in an ergonomic, allocation‑free API that is safe by default and AOT‑friendly. \uD83E\uDDC2 Based on libsodium's Key Exchange** ℹ️ See also: API Reference for CryptoKeyExchange ✨ What Does Key Exchange Do? Key exchange (sometimes called authenticated key agreement) lets two peers that each own a long‑term key pair derive two fresh 32‑byte session keys – one for sending (TX) and one for receiving (RX). These session keys can then be fed into other LibSodium.Net constructs such as SecretBox or SecretStream to encrypt traffic. Confidential – Only the two parties learn the session keys. Integrity & Authenticity – Each side proves possession of its secret key, preventing MitM attacks. Speed – Single round‑trip and constant‑time operations on Curve25519. \uD83C\uDF1F Features Allocation‑free Span<T> API – zero heap allocations. Deterministic or random key generation – choose reproducibility or fresh randomness. Separate TX/RX keys – enforces directionality and prevents nonce reuse. AOT & Unity friendly – works seamlessly in Ahead‑of‑Time compiled environments. Defensive size checks – throws early on invalid input lengths. Accepts SecureMemory<byte> as private key input. It provides guarded heap allocations with memory protection and automatic wiping. ✨ Typical Scenarios Scenario Why Key Exchange Fits Client ↔️ Server TLS‑like handshake Derive symmetric keys before switching to an AEAD cipher for bulk data. IoT device onboarding Small code size & no certificates required. P2P chat/file sharing Each participant becomes client or server dynamically to agree on forward‑secure channels. Session re‑keying Periodically refresh symmetric keys without exchanging new public keys. \uD83D\uDCDD The crypto_kx API does not provide Perfect Forward Secrecy by itself; re‑run the exchange whenever you need new keys. ✨ API Overview \uD83D\uDCCF Constants All lengths are in bytes. These constants are exposed by CryptoKeyExchange for zero-cost validation. Name Value Description PublicKeyLen 32 Curve25519 public key SecretKeyLen 32 Curve25519 secret (private) key SeedLen 32 Length of deterministic seed SessionKeyLen 32 Length of derived session keys \uD83D\uDCCB Core Methods Method Role GenerateKeyPair Random key pair. GenerateKeyPairDeterministically Reproducible key pair from a 32‑byte seed. DeriveClientSessionKeys Client side of the handshake → produces (rx, tx). DeriveServerSessionKeys Server side of the handshake → produces (rx, tx). \uD83D\uDCCB Usage Example \uD83D\uDCDD Naming convention in arguments: tx = key to transmit (send), rx = key to receive. Using SecureMemory for private and session keys: // Key generation (once) Span<byte> clientPublicKey = stackalloc byte[CryptoKeyExchange.PublicKeyLen]; using var clientSecretKey = new SecureMemory<byte>(CryptoKeyExchange.SecretKeyLen); CryptoKeyExchange.GenerateKeyPair(clientPublicKey, clientSecretKey); clientSecretKey.ProtectReadOnly(); Span<byte> serverPublicKey = stackalloc byte[CryptoKeyExchange.PublicKeyLen]; using var serverSecretKey = new SecureMemory<byte>(CryptoKeyExchange.SecretKeyLen); CryptoKeyExchange.GenerateKeyPair(serverPublicKey, serverSecretKey); serverSecretKey.ProtectReadOnly(); // Derive session keys (per connection) using var clientReceiveKey = new SecureMemory<byte>(CryptoKeyExchange.SessionKeyLen); using var clientSendKey = new SecureMemory<byte>(CryptoKeyExchange.SessionKeyLen); CryptoKeyExchange.DeriveClientSessionKeys(clientReceiveKey, clientSendKey, clientPublicKey, clientSecretKey, serverPublicKey); clientReceiveKey.ProtectReadOnly(); clientSendKey.ProtectReadOnly(); using var serverReceiveKey = new SecureMemory<byte>(CryptoKeyExchange.SessionKeyLen); using var serverSendKey = new SecureMemory<byte>(CryptoKeyExchange.SessionKeyLen); CryptoKeyExchange.DeriveServerSessionKeys(serverReceiveKey, serverSendKey, serverPublicKey, serverSecretKey, clientPublicKey); serverReceiveKey.ProtectReadOnly(); serverSendKey.ProtectReadOnly(); // Verify keys match Debug.Assert(clientSendKey.SequenceEqual(serverReceiveKey)); // Upstream traffic Debug.Assert(clientReceiveKey.SequenceEqual(serverSendKey)); // Downstream traffic // Use with SecretBox var ciphertext = SecretBox.Encrypt(message, nonce, clientSendKey); var plaintext = SecretBox.Decrypt(ciphertext, nonce, serverReceiveKey); Using Span for private and session keys: // Key generation (once) Span<byte> clientPublicKey = stackalloc byte[CryptoKeyExchange.PublicKeyLen]; Span<byte> clientSecretKey = stackalloc byte[CryptoKeyExchange.SecretKeyLen]; CryptoKeyExchange.GenerateKeyPair(clientPublicKey, clientSecretKey); Span<byte> serverPublicKey = stackalloc byte[CryptoKeyExchange.PublicKeyLen]; Span<byte> serverSecretKey = stackalloc byte[CryptoKeyExchange.SecretKeyLen]; CryptoKeyExchange.GenerateKeyPair(serverPublicKey, serverSecretKey); // Derive session keys (per connection) Span<byte> clientReceiveKey = stackalloc byte[CryptoKeyExchange.SessionKeyLen]; Span<byte> clientSendKey = stackalloc byte[CryptoKeyExchange.SessionKeyLen]; CryptoKeyExchange.DeriveClientSessionKeys(clientReceiveKey, clientSendKey, clientPublicKey, clientSecretKey, serverPublicKey); Span<byte> serverReceiveKey = stackalloc byte[CryptoKeyExchange.SessionKeyLen]; Span<byte> serverSendKey = stackalloc byte[CryptoKeyExchange.SessionKeyLen]; CryptoKeyExchange.DeriveServerSessionKeys(serverReceiveKey, serverSendKey, serverPublicKey, serverSecretKey, clientPublicKey); // Verify keys match Debug.Assert(clientSendKey.SequenceEqual(serverReceiveKey)); // Upstream traffic Debug.Assert(clientReceiveKey.SequenceEqual(serverSendKey)); // Downstream traffic // Use with SecretBox var ciphertext = SecretBox.Encrypt(message, nonce, clientSendKey); var plaintext = SecretBox.Decrypt(ciphertext, nonce, serverReceiveKey); \uD83D\uDCCB Using Ed25519 Keys with CryptoKeyExchange If you already have an Ed25519 key pair (typically used for digital signatures), you can convert it to Curve25519 format and use it directly with CryptoKeyExchange. \uD83D\uDCDD Ed25519 to Curve25519 conversion is one-way: you can derive a Curve25519 key pair from an Ed25519 pair, but not vice versa. Using SecureMemory for private keys: Span<byte> edPk = stackalloc byte[CryptoSign.PublicKeyLen]; using var edSk = new SecureMemory<byte>(CryptoSign.PrivateKeyLen); CryptoSign.GenerateKeyPair(edPk, edSk); edSk.ProtectReadOnly(); Span<byte> curvePk = stackalloc byte[CryptoKeyExchange.PublicKeyLen]; using var curveSk = new SecureMemory<byte>(CryptoKeyExchange.SecretKeyLen); CryptoSign.PublicKeyToCurve(curvePk, edPk); CryptoSign.PrivateKeyToCurve(curveSk, edSk); curveSk.ProtectReadOnly(); Using Span for private keys: Span<byte> edPk = stackalloc byte[CryptoSign.PublicKeyLen]; Span<byte> edSk = stackalloc byte[CryptoSign.PrivateKeyLen]; CryptoSign.GenerateKeyPair(edPk, edSk); Span<byte> curvePk = stackalloc byte[CryptoKeyExchange.PublicKeyLen]; Span<byte> curveSk = stackalloc byte[CryptoKeyExchange.SecretKeyLen]; CryptoSign.PublicKeyToCurve(curvePk, edPk); CryptoSign.PrivateKeyToCurve(curveSk, edSk); The resulting curvePk and curveSk are fully compatible with all key exchange methods in CryptoKeyExchange. ⚠️ Error Handling Size checks – All spans must match the declared constants. Otherwise ArgumentException or ArgumentOutOfRangeException is thrown. Return codes – Non‑zero return from native libsodium maps to LibSodiumException. Dispose secrets carefully – Zero out secret keys (SecretKeyLen) after use. SecureMemory<T> is automatically zeroed when disposed. \uD83D\uDCDD Security Notes Always transmit public keys over an authenticated channel or pin them out‑of‑band. Re‑key often if you require PFS. The operation is cheap. Combine with SecretStream.Encrypt / Decrypt (or their Async variants) for long‑lived encrypted pipes. Do not share the same session key across protocols; derive one per purpose using an HKDF if needed. Using SecureMemory<byte> for private and session keys is strongly recommended, as it protects key material in unmanaged memory with automatic zeroing and access control. \uD83D\uDC40 See Also \uD83E\uDDC2 libsodium Key Exchange \uD83E\uDDC2 libsodium Ed25519 ↔ Curve25519 ℹ️ API Reference: CryptoKeyExchange ℹ️ API Reference: CryptoSign"
  },
  "guide/MAC.html": {
    "href": "guide/MAC.html",
    "title": "\uD83D\uDCDC MAC Algorithms | LibSodium.Net",
    "summary": "\uD83D\uDCDC MAC Algorithms Message Authentication Codes (MACs) provide integrity and authenticity for messages by allowing the recipient to verify that the data was produced by someone holding the secret key. All code examples are written in the C# language and use LibSodium.Net’s allocation-free API. Unlike encryption, authentication doesn't hide the contents of a message. It ensures that the message has not been tampered with and was created by someone who knows the shared secret key. LibSodium.Net exposes three HMAC‑SHA‑2 variants and Poly1305 that cover the vast majority of real‑world requirements while staying allocation‑free and AOT‑friendly. \uD83E\uDDC2 Based on libsodium’s HMAC‑SHA‑2 \uD83E\uDDC2 Based on libsodium’s One-time authentication ℹ️ API Reference: CryptoHmacSha256 ℹ️ API Reference: CryptoHmacSha512 ℹ️ API Reference: CryptoHmacSha512_256 ℹ️ API Reference: CryptoOneTimeAuth \uD83C\uDF1F Features Keyed authentication with proven constructions (HMAC‑SHA‑2 & Poly1305). Allocation‑free Span<T> API + streaming + async overloads. Unified method names: ComputeMac, VerifyMac, GenerateKey. Safe size checks that throw early (ArgumentException). Deterministic output – same key + message ⇒ same tag. Incremental (Multi-Part) MAC construction. ⚖️ Algorithm Comparison (bytes) API Hash / Primitive MacLen KeyLen Recommended Use‑Case CryptoHmacSha256 SHA‑256 32 32 Interop with systems expecting HMAC‑SHA‑256 (JWT, TLS, S3). CryptoHmacSha512 SHA‑512 64 32 Larger tag & usually faster on 64‑bit CPUs. CryptoHmacSha512_256 SHA‑512/256 32 32 32‑byte tag with SHA‑512 speed & security margin. CryptoOneTimeAuth Poly1305 16 32 One‑time MAC for single‑key usage (AEAD internals, per‑message keys, SecretBox). ℹ️ All lengths are in bytes ✨ HMAC‑SHA‑256 The CryptoHmacSha256 API implements HMAC-SHA-256 —built on the widely-deployed SHA-256 hash function— producing a 32-byte tag with a fixed 32-byte key. Choose this when you are interacting with external systems that require HMAC-SHA-256 (e.g., AWS S3 signatures, JWT HS256 tokens, many REST APIs). \uD83D\uDCCF Constants Name Value Description MacLen 32 Length of the authentication tag (32). KeyLen 32 Length of the secret key (32). ✨ HMAC‑SHA‑512 The CryptoHmacSha512 API implements HMAC-SHA-512 —producing a 64-byte tag with a fixed 32-byte key— and leverages SHA-512, which is typically faster than SHA-256 on modern 64-bit CPUs thanks to wider 64-bit arithmetic. Choose this variant when tag length isn’t constrained and you want the largest security margin (the 64-byte tag halves collision probability compared to 32-byte tags). \uD83D\uDCCF Constants Name Value Description MacLen 64 Length of the authentication tag (64). KeyLen 32 Length of the secret key (32). ✨ HMAC‑SHA‑512/256 The CryptoHmacSha512_256 API implements HMAC-SHA-512/256. It is not “SHA-256”; it re-uses SHA-512’s wide pipeline but truncates to 256 bits, producing a 32-byte tag with a fixed 32-byte key while retaining the performance of SHA-512. Use this variant when you need SHA-256-sized output yet can rely on SHA-512 acceleration in your environment (typically 64-bit CPUs). \uD83D\uDCCF Constants Name Value Description MacLen 32 Length of the authentication tag (32). KeyLen 32 Length of the secret key (32). ✨ Poly1305 The CryptoOneTimeAuth API implements Poly1305. It is an extremely fast, one-time authenticator designed by D. J. Bernstein, authenticating a message with a fixed single-use 32-byte key and producing a compact 16-byte tag. Use cases include: AEAD constructions – e.g. ChaCha20‑Poly1305, XChaCha20‑Poly1305, XSalsa20‑Poly1305 (SecretBox) Authenticating short messages when you can derive a fresh key per message Implementing high‑speed, one‑shot integrity checks inside protocols ⚠️ Key reuse breaks security. Each key must be used to authenticate one message only. Derive a new random key (or sub‑key) per message. \uD83D\uDCCF Constants Name Value Description MacLen 16 Length of the authentication tag (16). KeyLen 32 Length of the secret key (32). \uD83D\uDDDD️ Key Management You can pass keys to MAC methods using: SecureMemory<byte> – most secure, with memory protection and automatic zeroing. Span<byte>/ReadOnlySpan<byte> – fast and stack-allocated, but not supported in asynchronous methods. byte[] – works with both synchronous and asynchronous APIs. Memory<byte>/ReadOnlyMemory<byte> — used in async APIs. Can be converted to span if needed. \uD83D\uDCDD Use Span<T> when performance is critical, and SecureMemory<byte> when security is paramount. Examples: // SecureMemory<byte> using var key = new SecureMemory<byte>(CryptoHmacSha256.KeyLen); CryptoHmacSha256.GenerateKey(key); key.ProtectReadOnly(); // Span<byte> Span<byte> key = stackalloc byte[CryptoHmacSha256.KeyLen]; CryptoHmacSha256.GenerateKey(key); // byte[] var key = new byte[CryptoHmacSha256.KeyLen]; CryptoHmacSha256.GenerateKey(key); Tips: Generate a fresh random key with GenerateKey and store it securely (e.g., Azure Key Vault, environment variable, HSM). Never reuse keys across different algorithms or protocols. Even if the key size is compatible, doing so weakens isolation and security boundaries. Rotate keys periodically. Don't reuse keys in CryptoOneTimeAuth. \uD83D\uDCCB Usage Example using System.Diagnostics; // Async overloads accept Memory<byte>/ReadOnlyMemory<byte>, not Span<byte>. // We use byte[] because it implicitly converts to both Memory<byte> and Span<byte>. byte[] mac = new byte[CryptoHmacSha256.MacLen]; // UTF‑8 string literal (.NET 8+) ReadOnlySpan<byte> message = \"hello\"u8; // Calculate MAC CryptoHmacSha256.ComputeMac(key, message, mac); // Verify MAC bool ok = CryptoHmacSha256.VerifyMac(key, message, mac); Debug.Assert(ok); // Stream example (sync) using var stream = File.OpenRead(\"file.bin\"); CryptoHmacSha256.ComputeMac(key, stream, mac); stream.Position = 0; // rewind bool okStream = CryptoHmacSha256.VerifyMac(key, stream, mac); Debug.Assert(okStream); // Stream example (async) stream.Position = 0; await CryptoHmacSha256.ComputeMacAsync(key, stream, mac); stream.Position = 0; bool okStreamAsync = await CryptoHmacSha256.VerifyMacAsync(key, stream, mac); Debug.Assert(okStreamAsync); ℹ️ Same API across algorithms – swap the class name to change the MAC primitive. ✨ Incremental MAC All MAC algorithms in LibSodium.Net support incremental MAC construction, allowing you to compute a tag over a sequence of message parts (e.g., MAC(key, a || b || c)) without allocating or copying them into a single buffer. This is useful when authenticating structured messages, layered protocols, or data assembled in multiple stages. The following APIs expose incremental MAC support via the ICryptoIncrementalHash interface: CryptoHmacSha256 CryptoHmacSha512 CryptoHmacSha512_256 CryptoOneTimeAuth Each class provides CreateIncrementalMac(ReadOnlySpan<byte> key) and CreateIncrementalMac(SecureMemory<byte> key) methods. Compute MAC over multiple parts: Span<byte> mac = stackalloc byte[CryptoHmacSha512.MacLen]; ReadOnlySpan<byte> part1 = \"hello \"u8; ReadOnlySpan<byte> part2 = \"world\"u8; using var incMac = CryptoHmacSha512.CreateIncrementalMac(key); incMac.Update(part1); incMac.Update(part2); incMac.Final(mac); Poly1305 incremental MAC: Span<byte> mac = stackalloc byte[CryptoOneTimeAuth.MacLen]; ReadOnlySpan<byte> part1 = \"hello \"u8; ReadOnlySpan<byte> part2 = \"world\"u8; using var incMac = CryptoOneTimeAuth.CreateIncrementalMac(key); incMac.Update(part1); incMac.Update(part2); incMac.Final(mac); ⚠️ The Final() method may only be called once. If you need to compute another MAC, create a new incremental instance with CreateIncrementalMac(). \uD83E\uDDED Choosing the Right MAC Scenario Recommendation Interop with JWT HS256 / Web APIs CryptoHmacSha256 Internal service‑to‑service messages on x64 servers CryptoHmacSha512 Need 32‑byte tag but favour SHA‑512 performance CryptoHmacSha512_256 Authenticating AEAD ciphertext / per‑packet tag with derived sub‑key CryptoOneTimeAuth Very short messages (< 64 B) & performance critical, one‑time setting CryptoOneTimeAuth Long‑term shared key, multi‑message scenario Any HMAC variant (avoid Poly1305 key reuse) ⚠️ Error Handling Condition Exception Key or MAC buffer wrong length ArgumentException Stream read fails / internal RC LibSodiumException \uD83D\uDCDD Notes All APIs are deterministic: same key + message ⇒ same MAC. Verification is constant‑time to avoid timing attacks. The secret key length is fixed: 32 bytes. \uD83D\uDC40 See Also \uD83E\uDDC2 libsodium HMAC‑SHA‑2 \uD83E\uDDC2 libsodium One-time authentication ℹ️ API Reference: CryptoHmacSha256 ℹ️ API Reference: CryptoHmacSha512 ℹ️ API Reference: CryptoHmacSha512_256 ℹ️ API Reference: CryptoOneTimeAuth"
  },
  "guide/PublicKeyCrypto.html": {
    "href": "guide/PublicKeyCrypto.html",
    "title": "\uD83D\uDD11 Public Key Cryptography | LibSodium.Net",
    "summary": "\uD83D\uDD11 Public Key Cryptography LibSodium.Net provides high-level APIs for public-key cryptography based on Curve25519 and Ed25519. This includes secure encryption between peers (CryptoBox), anonymous encryption (Sealed Boxes), and digital signatures (CryptoSign). LibSodium.Net also exposes the low-level scalar multiplication primitive via CryptoScalarMult, which implements X25519. \uD83E\uDDC2 Based on libsodium's Public-Key Cryptography \uD83E\uDDC2 Based on libsodium's Point*scalar multiplication ℹ️ API Reference: CryptoBox ℹ️ API Reference: CryptoSign ℹ️ API Reference: CryptoScalarMult \uD83C\uDF1F Features Public-key authenticated encryption (CryptoBox) Anonymous encryption for messages (Sealed Boxes) Digital signatures with Ed25519 (CryptoSign) Span-based APIs for efficient, allocation-free usage Conversion from Ed25519 keys to Curve25519 (CryptoSign.PublicKeyToCurve, CryptoSign.PrivateKeyToCurve) Keys and seeds can be provided as SecureMemory<byte>, Span<byte>/ReadOnlySpan<byte>, and byte[]. ✨ CryptoBox — Authenticated Encryption The CryptoBox API securely encrypts messages between two parties using public-key cryptography. The sender and the recipient each have a key pair, and the message is both encrypted and authenticated. It also supports Sealed Boxes for anonymous encryption, allowing anyone to encrypt a message to a recipient without revealing their identity. Internally, it uses Curve25519 for key exchange, XSalsa20 for encryption, and Poly1305 for authentication. It supports both combined and detached modes, encryption using either a keypair or a precomputed shared key, and offers automatic or manual nonce handling — all through a unified, ergonomic API. \uD83E\uDDC2 Based on libsodium's Authenticated encryption using crypto_box \uD83D\uDC40 API Reference for CryptoBox \uD83D\uDCCF Constants Name Value Description PublicKeyLen 32 Curve25519 public key length PrivateKeyLen 32 Curve25519 private key length SharedKeyLen 32 Precomputed shared key length NonceLen 24 Nonce length MacLen 16 Authentication tag length SealOverheadLen 48 Overhead added by EncryptWithPublicKey \uD83D\uDCCB CryptoBox Key Management Generate random key pair: // SecureMemory Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; using var privateKey = new SecureMemory<byte>(CryptoBox.PrivateKeyLen); CryptoBox.GenerateKeypair(publicKey, privateKey); privateKey.ProtectReadOnly(); // Span Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(publicKey, privateKey); Deterministic key pair from seed: // SecureMemory using var seed = new SecureMemory<byte>(CryptoBox.SeedLen); //TODO: fill the seed using seed.AsSpan() seed.ProtectReadOnly(); Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; using var privateKey = new SecureMemory<byte>(CryptoBox.PrivateKeyLen); CryptoBox.GenerateKeypairDeterministically(publicKey, privateKey, seed); privateKey.ProtectReadOnly(); // Span Span<byte> seed = stackalloc byte[CryptoBox.SeedLen]; //TODO: fill the seed Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypairDeterministically(publicKey, privateKey, seed); **Precompute shared key: // SecureMemory using var sharedKey = SecureMemory<byte>(CryptoBox.SharedKeyLen); CryptoBox.CalculateSharedKey(sharedKey, otherPartyPublicKey, myPrivateKey); sharedKey.ProtectReadOnly(); // Span Span<byte> sharedKey = stackalloc byte[CryptoBox.SharedKeyLen]; CryptoBox.CalculateSharedKey(sharedKey, otherPartyPublicKey, myPrivateKey); ✨ Encrypting and Decrypting with CryptoBox Encrypt / Decrypt with Keypair (Combined, Auto Nonce): var message = Encoding.UTF8.GetBytes(\"Hello, world!\"); Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPublicKey, senderPrivateKey); Span<byte> decrypted = stackalloc byte[message.Length]; CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPublicKey, recipientPrivateKey); AssertLite.True(decrypted.SequenceEqual(message)); Encrypt / Decrypt with Keypair (Detached, Manual Nonce) Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPublicKey, senderPrivateKey, mac, nonce); CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPublicKey, recipientPublicKey, mac, nonce); Encrypt / Decrypt with Shared Key (Combined, Auto Nonce): Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey); Debug.Assert(decrypted.SequenceEqual(message)); Encrypt / Decrypt with Shared Key (Detached, Manual Nonce): Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey, mac, nonce); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey, mac, nonce); Sealed Boxes — Anonymous Encryption: Sealed boxes enable anonymous encryption: anyone can encrypt a message to a recipient’s public key without revealing their identity. Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.SealOverheadLen]; CryptoBox.EncryptWithPublicKey(ciphertext, message, recipientPublicKey); Span<byte> decrypted = stackalloc byte[message.Length]; CryptoBox.DecryptWithPrivateKey(decrypted, ciphertext, recipientPrivateKey); AssertLite.True(decrypted.SequenceEqual(message)); ✨ CryptoSign — Digital Signatures Uses Ed25519 to sign and verify messages. Produces 64-byte signatures. This is useful for verifying authenticity without encryption. \uD83E\uDDC2 See: libsodium crypto_sign \uD83D\uDC40 API Reference for CryptoSign \uD83D\uDCCF Constants Name Value Description PublicKeyLen 32 Ed25519 public key length PrivateKeyLen 64 Ed25519 private key length SignatureLen 64 Signature length SeedLen 32 Seed length for deterministic key \uD83D\uDCCB Working with CryptoSign Generate random key pair: // SecureMemory Span<byte> publicKey = stackalloc byte[CryptoSign.PublicKeyLen]; using var privateKey = new SecureMemory<byte>(CryptoSign.PrivateKeyLen); CryptoSign.GenerateKeyPair(publicKey, privateKey); privateKey.ProtectReadOnly(); // Span Span<byte> publicKey = stackalloc byte[CryptoSign.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoSign.PrivateKeyLen]; CryptoSign.GenerateKeyPair(publicKey, privateKey); Sign and Verify: Span<byte> signature = stackalloc byte[CryptoSign.SignatureLen]; CryptoSign.Sign(message, signature, privateKey); bool ok = CryptoSign.TryVerify(message, signature, publicKey); CryptoSign.Verify(message, signature, publicKey); // throws LibSodiumException if the signature is invalid \uD83D\uDCCB Convert Ed25519 to Curve25519 CryptoSign allows converting Ed25519 key pairs to Curve25519 format, suitable for encryption and key exchange. These converted keys can be used with the CryptoBox and CryptoKeyExchange APIs. // SecureMemory Span<byte> edPk = stackalloc byte[CryptoSign.PublicKeyLen]; using var edSk = new SecureMemory<byte>(CryptoSign.PrivateKeyLen); CryptoSign.GenerateKeyPair(edPk, edSk); edSk.ProtectReadOnly(); Span<byte> curvePk = stackalloc byte[CryptoBox.PublicKeyLen]; using var curveSk = SecureMemory<byte>(CryptoBox.PrivateKeyLen); CryptoSign.PublicKeyToCurve(curvePk, edPk); CryptoSign.PrivateKeyToCurve(curveSk, edSk); curveSk.ProtectReadOnly(); // Span Span<byte> edPk = stackalloc byte[CryptoSign.PublicKeyLen]; Span<byte> edSk = stackalloc byte[CryptoSign.PrivateKeyLen]; CryptoSign.GenerateKeyPair(edPk, edSk); Span<byte> curvePk = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> curveSk = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoSign.PublicKeyToCurve(curvePk, edPk); CryptoSign.PrivateKeyToCurve(curveSk, edSk); The resulting curvePk and curveSk can be used anywhere a Curve25519 key is expected. ✨ CryptoScalarMult — Raw Scalar Multiplication The CryptoScalarMult API exposes the low-level scalar multiplication primitive crypto_scalarmult, based on Curve25519. This operation implements the X25519 algorithm (ECDH over Curve25519), as defined in RFC 7748. It forms the foundation of key exchange protocols such as CryptoBox, CryptoKeyExchange, and others. This API is rarely needed directly. Prefer CryptoBox or CryptoKeyExchange unless you need protocol-level control or are replicating RFC 7748 behavior manually. \uD83E\uDDC2 Based on libsodium's Scalar multiplication ℹ️ API Reference for CryptoScalarMult \uD83D\uDCCF Constants Name Value Description PublicKeyLen 32 Length of the public key (q = nB) PrivateKeyLen 32 Length of the private scalar SharedKeyLen 32 Length of the computed q = nP \uD83D\uDCCB Working with CryptoScalarMult Calculate Public Key: Computes the public key q = n·B given a private scalar n: Span<byte> privateKey = stackalloc byte[CryptoScalarMult.PrivateKeyLen]; Span<byte> publicKey = stackalloc byte[CryptoScalarMult.PublicKeyLen]; RandomGenerator.Fill(privateKey); CryptoScalarMult.CalculatePublicKey(publicKey, privateKey); Compute Shared Point: Performs scalar multiplication q = n·P with a private scalar and a peer’s public key: Span<byte> sharedPoint = stackalloc byte[CryptoScalarMult.SharedKeyLen]; CryptoScalarMult.Compute(sharedPoint, myPrivateKey, peerPublicKey); ⚠️ Avoid Using q Directly as a Shared Key Many (privateKey, publicKey) pairs can produce the same result q when using CryptoScalarMult. This is because q is a point on the curve, and scalar multiplication is not injective. A safer and recommended approach is to derive a shared key using a cryptographic hash of the transcript: sharedKey = H(q || pk1 || pk2) This binds the result to the specific public keys involved, preventing ambiguity or replay. The order of the public keys must be agreed upon (e.g., lexicographically or based on fixed roles) to ensure both sides derive the same key. \uD83D\uDCCB Recommended Derivation Pattern using System.Diagnostics; Span<byte> clientPrivateKey = stackalloc byte[CryptoScalarMult.PrivateKeyLen]; Span<byte> clientPublicKey = stackalloc byte[CryptoScalarMult.PublicKeyLen]; Span<byte> serverPrivateKey = stackalloc byte[CryptoScalarMult.PrivateKeyLen]; Span<byte> serverPublicKey = stackalloc byte[CryptoScalarMult.PublicKeyLen]; Span<byte> sharedPointClient = stackalloc byte[CryptoScalarMult.SharedKeyLen]; Span<byte> sharedPointServer = stackalloc byte[CryptoScalarMult.SharedKeyLen]; Span<byte> derivedKeyClient = stackalloc byte[CryptoGenericHash.HashLen]; Span<byte> derivedKeyServer = stackalloc byte[CryptoGenericHash.HashLen]; // Generate key pairs RandomGenerator.Fill(clientPrivateKey); RandomGenerator.Fill(serverPrivateKey); CryptoScalarMult.CalculatePublicKey(clientPublicKey, clientPrivateKey); CryptoScalarMult.CalculatePublicKey(serverPublicKey, serverPrivateKey); // Derive shared key on the client side CryptoScalarMult.Compute(sharedPointClient, clientPrivateKey, serverPublicKey); using (var hash = CryptoGenericHash.CreateIncrementalHash()) { hash.Update(sharedPointClient); hash.Update(clientPublicKey); hash.Update(serverPublicKey); hash.Final(derivedKeyClient); } // Derive shared key on the server side CryptoScalarMult.Compute(sharedPointServer, serverPrivateKey, clientPublicKey); using (var hash = CryptoGenericHash.CreateIncrementalHash()) { hash.Update(sharedPointServer); hash.Update(clientPublicKey); hash.Update(serverPublicKey); hash.Final(derivedKeyServer); } // Validate both parties derived the same key Debug.Assert(derivedKeyClient.SequenceEqual(derivedKeyServer)); ⚠️ Error Handling ArgumentException — when input buffers have incorrect lengths or invalid parameters. LibSodiumException — when authentication fails or a crypto operation cannot complete. \uD83D\uDCDD Notes Sealed boxes are anonymous: the recipient cannot identify the sender. CryptoBox uses crypto_box_easy internally; CryptoSign uses crypto_sign_detached. All APIs are Span-friendly and do not allocate memory internally. EncryptWithPublicKey prepends a 32-byte ephemeral public key and 16-byte MAC. Use CryptoSign when authentication is required without encryption. CryptoScalarMult is a low-level primitive and does not provide authentication. Avoid using scalar multiplication output directly as a key — always apply a hash. \uD83D\uDC40 See Also API Reference: CryptoBox API Reference: CryptoSign API Reference: CryptoScalarMult libsodium.org Public-Key Crypto libsodium scalar multiplication RFC 7748 – X25519"
  },
  "guide/RandomGenerator.html": {
    "href": "guide/RandomGenerator.html",
    "title": "\uD83C\uDFB2 RandomGenerator | LibSodium.Net",
    "summary": "\uD83C\uDFB2 RandomGenerator The RandomGenerator class in LibSodium.Net provides access to cryptographically secure random values. It wraps several functions from libsodium's randombytes API and ensures correct initialization and exception safety. \uD83E\uDDC2Based on libsodium's Generating random data ℹ️ See also: API Reference for RandomGenerator \uD83C\uDF1F Features Generate random 32-bit unsigned integers. Generate bounded random integers. Fill buffers with secure random bytes. Generate deterministic random bytes using a seed. Stir or close the RNG engine as needed. \uD83D\uDCCB Getting Random Values Get a random 32-bit unsigned integer: returns a cryptographically secure, uniformly distributed value. uint value = RandomGenerator.GetUInt32(); Get a random value less than an upper bound: Returns a value in the range [0, upperBound). uint lessThan100 = RandomGenerator.GetUInt32(100); \uD83D\uDCCB Filling Buffers \uD83D\uDD10 When dealing with sensitive data (e.g., seeds, key material), prefer using SecureMemory<byte> for guarded heap allocations and automatic zeroing. Fill a buffer with unpredictable cryptographic random bytes: Span<byte> buffer = stackalloc byte[32]; RandomGenerator.Fill(buffer); var buffer = new byte[32]; RandomGenerator.Fill(buffer); ** using var buffer = SecureMemory.Create<byte>(32); RandomGenerator.Fill(buffer); Fill a buffer with deterministic random bytes: Span<byte> seed = stackalloc byte[RandomGenerator.SeedLen]; RandomGenerator.Fill(seed); // Generate a secure seed Span<byte> buffer = stackalloc byte[32]; RandomGenerator.FillDeterministic(buffer, seed); var seed = new byte[RandomGenerator.SeedLen]; RandomGenerator.Fill(seed); // Generate a secure seed var buffer = new byte[32]; RandomGenerator.FillDeterministic(buffer, seed); using var seed = SecureMemory.Create<byte>(RandomGenerator.SeedLen); RandomGenerator.Fill(seed); // Generate a secure seed using var buffer = SecureMemory.Create<byte>(32); RandomGenerator.FillDeterministic(buffer, seed); The same seed and length will always produce the same output. ⚠️ Seed must be exactly RandomGenerator.SeedLen bytes long. Otherwise, ArgumentException is thrown. \uD83D\uDCCB Stirring and Closing Stir the RNG: RandomGenerator.Stir(); This reseeds the RNG, recommended after forking a process or when explicitly needed. Close the RNG: RandomGenerator.Close(); Closes the randombytes subsystem. This may be needed in long-running processes or to release resources. Calling it more than once will throw LibSodiumException. ⚠️ Error Handling ArgumentException — thrown when FillDeterministic receives an invalid seed length. LibSodiumException — thrown when Close() fails (e.g., called twice). The RandomGenerator API is well-suited for cryptographic use cases and follows safe defaults. It gives you access to high-quality random data and control over deterministic randomness when reproducibility is required."
  },
  "guide/SecretBox.html": {
    "href": "guide/SecretBox.html",
    "title": "\uD83D\uDD12 Symmetric Authenticated Encryption with SecretBox | LibSodium.Net",
    "summary": "\uD83D\uDD12 Symmetric Authenticated Encryption with SecretBox The SecretBox API in LibSodium.Net provides a simple and secure way to perform symmetric authenticated encryption using the XSalsa20 stream cipher and Poly1305 MAC. It supports both combined and detached encryption modes, as well as manual or automatic nonce handling — all from a single, unified API. \uD83E\uDDC2Based on libsodium's Authenticated encryption using crypto_secretbox ℹ️ See also: API Reference for SecretBox \uD83C\uDF1F Features Symmetric authenticated encryption using XSalsa20-Poly1305. Combined mode and detached mode support. Automatic or manual nonce handling. Built-in MAC verification (tamper detection). Unified Encrypt / Decrypt API with optional parameters. Safe and efficient Span<T>-based implementation. Accepts SecureMemory<byte> as key input. \uD83D\uDCCB Usage Key Management: LibSodium.Net accepts Span<byte>, byte[], or SecureMemory<byte> as key inputs. Using SecureMemory<byte> is strongly recommended, as it protects key material in unmanaged memory with automatic zeroing and access control. Span<byte> key = stackalloc byte[SecretBox.KeyLen]; var key = new byte[SecretBox.KeyLen]; using var key = new SecureMemory<byte>(SecretBox.KeyLen); To generate a random key use RandomGenerator.Fill RandomGenerator.Fill(key); If you're using SecureMemory<byte>, it's recommended to call ProtectReadOnly() after initializing the key, to prevent further modifications. key.ProtectReadOnly(); Combined Mode (Auto Nonce): var plaintext = Encoding.UTF8.GetBytes(\"Hello, auto-nonce world!\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen + SecretBox.NonceLen]; SecretBox.Encrypt(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); Combined Mode (Manual Nonce): Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Manual nonce combined\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen]; SecretBox.Encrypt(ciphertext, plaintext, key, nonce: nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key, nonce: nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); Detached Mode (Auto Nonce): var plaintext = Encoding.UTF8.GetBytes(\"Detached + auto nonce\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.NonceLen]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.Encrypt(ciphertext, plaintext, key, mac); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key, mac); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); Detached Mode (Manual Nonce) Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached with nonce\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.Encrypt(ciphertext, plaintext, key, mac, nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key, mac, nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); ⚠️ Error Handling ArgumentException — invalid input sizes. LibSodiumException — authentication failed. \uD83D\uDCDD Notes Nonce must be exactly SecretBox.NonceLen bytes when passed manually. Auto-nonce is prepended to the ciphertext when not specified. Combined mode outputs ciphertext + MAC (+ optional nonce). Detached mode separates MAC from ciphertext. Buffers can be larger than required. Use RandomGenerator.Fill() to generate cryptographically secure random keys and nonces. Alternatively, keys may be securely stored or derived using a key derivation function. Use SecureMemory<byte> for keys. \uD83D\uDC40 See Also libsodium secretbox documentation API Reference"
  },
  "guide/SecretStream.html": {
    "href": "guide/SecretStream.html",
    "title": "\uD83D\uDD12 Authenticated Stream Encryption with SecretStream | LibSodium.Net",
    "summary": "\uD83D\uDD12 Authenticated Stream Encryption with SecretStream The SecretStream class in LibSodium.Net provides secure, authenticated stream-based encryption and decryption using the XChaCha20-Poly1305 algorithm. It also supports additional authenticated data (AAD), allowing you to cryptographically bind headers or metadata to the encrypted stream. It's designed to handle large streams of data efficiently and securely. \uD83E\uDDC2 Based on libsodium's Encrypted streams and file encryption ℹ️ See also: API Reference for SecretStream ✨ Features Authenticated encryption ensures data integrity. Automatic chunking and handling of large data streams. Secure random key generation. Protection against nonce reuse. Accepts SecureMemory<byte> as key input. Supports additional authenticated data (AAD). \uD83D\uDCCB Usage LibSodium.Net accepts Span<byte>/ReadOnlySpan<byte>, byte[], or SecureMemory<byte> as key inputs for synchronous methods. For asynchronous methods, it accepts Memory<byte>/ReadOnlyMemory<byte>, byte[], or SecureMemory<byte>. Using SecureMemory<byte> is strongly recommended, as it protects key material in unmanaged memory with automatic zeroing and access control. byte[] key = new byte[CryptoSecretStream.KeyLen]; CryptoSecretStream.GenerateKey(key); using var key = new SecureMemory<byte>(CryptoSecretStream.KeyLen); CryptoSecretStream.GenerateKey(key); key.ProtectReadOnly(); Use CryptoSecretStream.GenerateKey() to generate a cryptographically secure random key. Alternatively, keys may be securely stored or derived using a key derivation function. Encrypting and decrypting files synchronously: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); SecretStream.Encrypt(inputFile, encryptedFile, key); encryptedFile.Position = 0; SecretStream.Decrypt(encryptedFile, decryptedFile, key); Encrypting and decrypting files asynchronously: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); await SecretStream.EncryptAsync(inputFile, encryptedFile, key); encryptedFile.Position = 0; await SecretStream.DecryptAsync(encryptedFile, decryptedFile, key); Encrypting and decrypting with AAD: To authenticate additional data (AAD), use the overloads that accept an aad parameter. ⚠️ The same AAD must be provided for both encryption and decryption to ensure verification. ReadOnlySpan<byte> aad = \"header info\"u8; byte[] aadArray = aad.ToArray(); // Async methods require ReadOnlyMemory<byte> SecretStream.Encrypt(input, encrypted, key, aad); SecretStream.Decrypt(encrypted, decrypted, key, aad); await SecretStream.EncryptAsync(input, encrypted, key, aadArray); await SecretStream.DecryptAsync(encrypted, decrypted, key, aadArray); ⚠️ Security Considerations Secure Key Management: Protect your keys; losing them or exposing them compromises security. Use SecureMemory<byte> when possible. Nonce Management: Handled internally by SecretStream; avoid manual nonce reuse. Integrity Checks: Automatic using Poly1305 tags; any tampering results in exceptions. AAD Integrity: If you use AAD, it must match exactly on encryption and decryption, or the authentication will fail. ⚠️ Error Handling Encryption and decryption throw specific exceptions for error conditions: ArgumentException: Invalid arguments (wrong key length, null streams). LibSodiumException: Authentication failed, typically from tampered data. \uD83D\uDD52 Performance Considerations SecretStream processes data in chunks (default: 64KB) for optimal balance between memory usage and performance. Utilize asynchronous methods (EncryptAsync/DecryptAsync) for IO-bound scenarios for better scalability."
  },
  "guide/SecureBigUnsignedInteger.html": {
    "href": "guide/SecureBigUnsignedInteger.html",
    "title": "\uD83D\uDD22 SecureBigUnsignedInteger | LibSodium.Net",
    "summary": "\uD83D\uDD22 SecureBigUnsignedInteger The SecureBigUnsignedInteger class provides constant-time operations for working with large, little-endian, unsigned integers represented as Span<byte>. It wraps several low-level functions from libsodium that are specifically designed to be safe against side-channel attacks. \uD83E\uDDC2 Based on libsodium’s Integer manipulation helpers ℹ️ See also: API Reference for SecureBigUnsignedInteger \uD83D\uDD10 Security Considerations All operations in this class are evaluated in constant time with respect to buffer size, which helps prevent timing-based side-channel attacks. These methods are suitable for cryptographic contexts where comparisons, additions, or manipulations of secrets must not leak information through execution timing. \uD83C\uDF1F Features Constant-time comparison, equality, addition, and subtraction. Increment by 1 or arbitrary 64-bit value. Zero-checking. Supports arbitrary-sized numbers (as long as both operands have the same length). Uses spans to avoid heap allocations. ✨ Usage Examples \uD83D\uDCCB Constant-Time Equality Check Span<byte> a = stackalloc byte[] { 1, 2, 3 }; Span<byte> b = stackalloc byte[] { 1, 2, 3 }; bool areEqual = SecureBigUnsignedInteger.Equals(a, b); // true \uD83D\uDCCB Constant-Time Compare int cmp = SecureBigUnsignedInteger.Compare(a, b); // 0 if equal, <0 if a < b, >0 if a > b \uD83D\uDCCB Increment Span<byte> number = stackalloc byte[4]; SecureBigUnsignedInteger.Increment(number); // adds 1 SecureBigUnsignedInteger.Increment(number, 42); // adds 42 \uD83D\uDCCB Addition and Subtraction Span<byte> a = stackalloc byte[] { 5, 0, 0 }; ReadOnlySpan<byte> b = stackalloc byte[] { 3, 0, 0 }; SecureBigUnsignedInteger.Add(a, b); // a = a + b SecureBigUnsignedInteger.Subtract(a, b); // a = a - b ⚠️ Both operands must have the same length. Otherwise, ArgumentException is thrown. \uD83D\uDCCB Zero Check Span<byte> n = stackalloc byte[] { 0, 0, 0 }; bool isZero = SecureBigUnsignedInteger.IsZero(n); // true This API is ideal for low-level cryptographic arithmetic where performance, determinism, and side-channel resistance are essential."
  },
  "guide/SecureMemory.html": {
    "href": "guide/SecureMemory.html",
    "title": "\uD83D\uDEE1️ SecureMemory | LibSodium.Net",
    "summary": "\uD83D\uDEE1️ SecureMemory When working with cryptographic data, it's essential to ensure that sensitive information doesn't get leaked through memory dumps or swapping. LibSodium.Net provides SecureMemory and SecureMemory<T> as robust tools to manage sensitive data safely in unmanaged memory. \uD83E\uDDC2 Backed by libsodium's Secure memory. ℹ️ See also: API Reference for SecureMemory<T> These APIs leverage libsodium’s sodium_malloc, sodium_mlock, and related memory protection functions to offer secure, optionally read-only memory regions that are wiped on disposal. ✨ SecureMemory<T> SecureMemory<T> is a managed wrapper around unmanaged memory that stores a buffer of unmanaged type T items. It ensures: Memory is allocated using sodium_allocarray. Memory is wiped with sodium_free on disposal. Optional read-only protection using ProtectReadOnly(). Optional read-write toggle with ProtectReadWrite(). Safe access through Span<T>, Memory<T>, ReadOnlySpan<T>, and ReadOnlyMemory<T>. \uD83D\uDDDD️ SecureMemory<byte> is used extensively across LibSodium.Net for handling keys, seeds, and other sensitive data. It provides guarded unmanaged heap allocations with memory protection and automatic wiping, making it the recommended type for storing cryptographic secrets. \uD83D\uDCCB Basic Usage // Allocate secure memory. using var buffer = new SecureMemory<byte>(32); // Contents are initialized to 0x80 (for debugging purposes). Debug.Assert(!buffer.IsZero()); // Optional: explicitly zero memory. buffer.MemZero(); // Fill with random data. RandomGenerator.Fill(buffer); // Write access var span = buffer.AsSpan(); var memory = buffer.AsMemory(); // Making it read-only prevents modifications. buffer.ProtectReadOnly(); // access as read-only var readOnlySpan = buffer.AsReadOnlySpan(); var readOnlyMemory = buffer.AsReadOnlyMemory(); // Make it writable again. buffer.ProtectReadWrite(); ✨ Safety Features Memory is initialized to 0x80 bytes. Accessing the SecureMemory<T> object after disposal throws ObjectDisposedException. Writing to memory after calling ProtectReadOnly() throws an AccessViolationException. AsSpan() and AsMemory() throw InvalidOperationException if the memory is protected with ProtectReadOnly(). Attempting to write using a previously obtained Span<T> or Memory<T> will trigger an AccessViolationException Memory is automatically zeroed out upon disposal using sodium_memzero. ⚠️ Security Considerations Unmanaged memory isn't GC-tracked — make sure to dispose properly. AccessViolationException is a sign that read/write protections are working as intended. Avoid exposing memory unnecessarily — always limit visibility."
  },
  "guide/StreamCiphers.html": {
    "href": "guide/StreamCiphers.html",
    "title": "\uD83D\uDD12 Stream Ciphers | LibSodium.Net",
    "summary": "\uD83D\uDD12 Stream Ciphers Stream ciphers provide confidentiality for messages of any length —short or long— turning data into a sequence indistinguishable from random noise. They operate on fixed-size blocks of data, using minimal memory, which makes them perfect for real-time streams, huge files, or jumping directly to any part of a message without processing everything before it. How they work: A stream cipher generates a pseudorandom sequence called the keystream from a secret key and a fresh nonce, then combines it with the plaintext or ciphertext using XOR to encrypt or decrypt; the operation is symmetric, so the same process is used for both encryption and decryption. ⚠️ No built-in authentication: Stream ciphers only provide confidentiality. They do not protect against tampering — an attacker can flip bits undetected. Always combine with a MAC (e.g., Poly1305) or use an AEAD construction when integrity or authenticity matters. Why use them? Works on the fly: ideal for live audio, video, chat, or sensor feeds. Minimal buffering: great for very large files or constrained devices. Random access: you can decrypt any block independently. Beyond encryption you can treat the keystream itself as a fast pseudorandom function (PRF) for masking or key‑derivation tasks. \uD83E\uDDC2 Based on libsodium’s Stream ciphers ℹ️ API Reference: CryptoStreamXSalsa20 ℹ️ API Reference: CryptoStreamSalsa20 ℹ️ API Reference: CryptoStreamChaCha20 ℹ️ API Reference: CryptoStreamChaCha20Ietf ℹ️ API Reference: CryptoStreamXChaCha20 \uD83C\uDF1F Features Allocation‑free Span<T> API plus streaming & async overloads. Unified method names: Encrypt, Decrypt, GenerateKeystream. Supports encryption and decryption starting at a given block index (initialCounter). Key & nonce length checks throw early (ArgumentException). Deterministic: same key + nonce ⇒ same keystream. Huge keystream period: 2^64 blocks ≈ 2^70 bytes —except for the IETF variant— practically limitless but not infinite. Accepts SecureMemory<byte> as key input. ✨ Common API All stream cipher classes share the following members: Member Type Description KeyLen Constant Length of the secret key in bytes. NonceLen Constant Length of the nonce in bytes. BlockLen Constant Keystream block size in bytes. Encrypt Method Encrypts data using key and nonce. Applies to both span-based and stream-based. Decrypt Method Decrypts data using key and nonce. Applies to both span-based and stream-based. GenerateKeystream Method Generates keystream into an output buffer using key and nonce. EncryptAsync Method Asynchronously encrypts stream input to stream output with key and nonce. DecryptAsync Method Asynchronously decrypts stream input to stream output with key and nonce. ⚖️ Algorithm Comparison API KeyLen NonceLen BlockLen Keystream Period CryptoStreamXSalsa20 32 24 64 2⁶⁴ blocks = 1 ZiB CryptoStreamSalsa20 32 8 64 2⁶⁴ blocks = 1 ZiB CryptoStreamChaCha20 32 8 64 2⁶⁴ blocks = 1 ZiB CryptoStreamChaCha20Ietf 32 12 64 2³² blocks = 256 GiB CryptoStreamXChaCha20 32 24 64 2⁶⁴ blocks = 1 ZiB KeyLen, NonceLen, and BlockLen are in bytes. \uD83E\uDDED Choosing the Right Stream Cipher Scenario Recommendation Random nonces, enormous message count CryptoStreamXChaCha20 Interop with RFC 8439 / HTTP / QUIC CryptoStreamChaCha20Ietf NaCl / libsodium pre‑2018 compatibility CryptoStreamXSalsa20 or Salsa20 Embedded / resource‑constrained but need ChaCha core CryptoStreamChaCha20 Never reuse nonces & bounded message number Any variant (pick nonce length) \uD83D\uDCCB Usage Example All examples are in C# and work for all stream cipher algorithms, just change the class name. LibSodium.Net accepts Span<byte>/ReadOnlySpan<byte>, byte[], or SecureMemory<byte> as key inputs for synchronous methods. For asynchronous methods, it accepts Memory<byte>/ReadOnlyMemory<byte>, byte[], or SecureMemory<byte>. Using SecureMemory<byte> is strongly recommended, as it protects key material in unmanaged memory with automatic zeroing and access control. // Async overloads accept Memory<byte>/ReadOnlyMemory<byte>, not Span<byte>. // We use byte[] because it implicitly converts to both Memory<byte> and Span<byte>. byte[] key = new byte[CryptoStreamXChaCha20.KeyLen]; RandomGenerator.Fill(key); // SecureMemory works for both synchronous and asynchronous methods. using var key = new SecureMemory<byte>(CryptoStreamXChaCha20.KeyLen); RandomGenerator.Fill(key); key.ProtectReadOnly(); Use RandomGenerator.Fill() to generate a cryptographically secure random key. Alternatively, keys may be securely stored or derived using a key derivation function. byte[] nonce = new byte[CryptoStreamXChaCha20.NonceLen]; RandomGenerator.Fill(nonce); // 1. Basic usage encrypt and decrypt buffer ReadOnlySpan<byte> plaintext = \"secret\"u8; // Encrypting a buffer: byte[] ciphertext = new byte[plaintext.Length]; CryptoStreamXChaCha20.Encrypt(key, nonce, plaintext, ciphertext); // Decrypting a buffer: byte[] decrypted = new byte[ciphertext.Length]; CryptoStreamXChaCha20.Decrypt(key, nonce, ciphertext, decrypted); // Check that the decrypted buffer matches the original plaintext Debug.Assert(plaintext.SequenceEqual(decrypted)); // 2. Stream-based (sync) using (var inputFile = File.OpenRead(\"video.raw\")) using (var encryptedFile = File.Create(\"video.enc\")) using (var decryptedFile = File.Create(\"video.dec\")) { // Encrypting a file: CryptoStreamXChaCha20.Encrypt(key, nonce, inputFile, encryptedFile); // Decrypting a file: encryptedFile.Position = 0; // Reset the position of the encrypted file to the beginning CryptoStreamXChaCha20.Decrypt(key, nonce, encryptedFile, decryptedFile); } // 3. Stream-based (async) using (var inputFile = File.OpenRead(\"video.raw\")) using (var encryptedFile = File.Create(\"video.enc\")) using (var decryptedFile = File.Create(\"video.dec\")) { // Encrypting a file: await CryptoStreamXChaCha20.EncryptAsync(key, nonce, inputFile, encryptedFile); // Decrypting a file: encryptedFile.Position = 0; // Reset the position of the encrypted file to the beginning await CryptoStreamXChaCha20.DecryptAsync(key, nonce, encryptedFile, decryptedFile); } // 4. Generate raw keystream Span<byte> keystream = stackalloc byte[128]; CryptoStreamXChaCha20.GenerateKeystream(keystream, nonce, key); // 5. Start encryption/decryption from a specific block index (e.g., resume or skip) CryptoStreamXChaCha20.Encrypt(key, nonce, plaintext, ciphertext, initialCounter: 10); CryptoStreamXChaCha20.Decrypt(key, nonce, ciphertext, decrypted, initialCounter: 10); ⚠️ Error Handling Condition Exception Wrong key / nonce length ArgumentException Output buffer too small ArgumentException I/O failure in stream overloads LibSodiumException \uD83D\uDDDD️ Key & Nonce Management Tips Never reuse a nonce with the same key—this reveals keystream and breaks confidentiality. Prefer 24‑byte variants for random nonces; use counters for 8/12‑byte variants. Use SecureMemory<byte> for keys. It provides guarded heap allocations with memory protection and automatic wiping. \uD83D\uDCDD Notes Stream ciphers offer no built‑in authentication, pair them with a MAC (Poly1305/HMAC) or use an AEAD construction. Keystream period is 2^64 blocks (64 bytes each), except CryptoStreamChaCha20Ietf with 2^32. All APIs are constant‑time with respect to secret data. \uD83D\uDC40 See Also \uD83E\uDDC2 Stream ciphers ℹ️ API Reference: CryptoStreamXSalsa20 ℹ️ API Reference: CryptoStreamSalsa20 ℹ️ API Reference: CryptoStreamChaCha20 ℹ️ API Reference: CryptoStreamChaCha20Ietf ℹ️ API Reference: CryptoStreamXChaCha20"
  },
  "guide/XChaCha20-Poly1305.html": {
    "href": "guide/XChaCha20-Poly1305.html",
    "title": "\uD83D\uDD10 XChaCha20-Poly1305 | LibSodium.Net",
    "summary": "\uD83D\uDD10 XChaCha20-Poly1305 The XChaCha20Poly1305 API in LibSodium.Net provides authenticated encryption with associated data (AEAD) and extended nonce support (192-bit), making it safer for use in systems where nonce reuse is a concern. It supports both combined and detached encryption modes, and allows manual or automatic nonce handling through a unified API. \uD83E\uDDC2 Based on libsodium's XChaCha20-Poly1305 construction ℹ️ See also: API Reference for XChaCha20Poly1305 \uD83C\uDF1F Features Authenticated encryption with associated data (AEAD). 24-byte nonce (192-bit) minimizes risk of nonce reuse. Combined and detached mode support through a single API. Optional additionalData for protocol-level authentication. Manual or automatic nonce handling. Span<T>-based API for high performance and low allocations. ✨ Encrypting and Decrypting Messages Use the Encrypt and Decrypt methods to perform authenticated encryption. The mode is determined by the presence of the optional mac parameter. \uD83D\uDCCB Combined Mode (Auto Nonce, No AAD) Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto nonce test\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + XChaCha20Poly1305.MacLen + XChaCha20Poly1305.NonceLen]; XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Combined Mode (Manual Nonce with AAD) Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen]; Span<byte> nonce = stackalloc byte[XChaCha20Poly1305.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"With AAD and nonce\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + XChaCha20Poly1305.MacLen]; Span<byte> aad = Encoding.UTF8.GetBytes(\"metadata\"); XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, aad: aad, nonce: nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Detached Mode (Manual Nonce) Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen]; Span<byte> nonce = stackalloc byte[XChaCha20Poly1305.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached encryption\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[XChaCha20Poly1305.MacLen]; XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac, nonce: nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, mac, nonce: nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); ⚠️ Error Handling ArgumentException — invalid input sizes. LibSodiumException — authentication failed (tampered data). \uD83D\uDCDD Notes Nonce must be exactly 24 bytes. Auto-nonce is prepended to ciphertext for easy reuse. Buffers must have space for output (e.g., ciphertext includes MAC and possibly nonce). It can be longer than needed. Encrypt and Decrypt automatically choose combined or detached mode depending on the presence of the mac parameter. Use RandomGenerator.Fill() to safely generate keys and nonces. AAD is optional but recommended for additional authentication context. \uD83D\uDC40 See Also libsodium AEAD documentation RFC 8439 - ChaCha20 and Poly1305 for IETF Protocols API Reference"
  },
  "guide/index.html": {
    "href": "guide/index.html",
    "title": "\uD83D\uDD10 Introduction to LibSodium.Net | LibSodium.Net",
    "summary": "\uD83D\uDD10 Introduction to LibSodium.Net LibSodium.Net provides .NET developers with easy-to-use bindings for libsodium, a powerful, modern cryptography library widely recognized for its simplicity and security. This makes it straightforward to add robust cryptographic functionality to your .NET applications. All code examples are written in C# and use LibSodium.Net’s allocation-free API. ✨ Why LibSodium.Net? Cross-platform testing: The suite runs against native-AOT builds on Windows, Linux, and macOS. Modern Cryptography: Includes authenticated encryption, public-key cryptography, hashing, MAC, key derivation, key exchange and many more. Simple and Secure API: Designed to reduce complexity, helping you implement cryptography correctly and securely. Secure Memory Handling: Sensitive data management to minimize risks like memory leaks or data exposure. Span over Arrays : Optimized for performance and memory efficiency by using Span<T> instead of heap-allocated arrays. AOT Compatible: Uses LibraryImport (source-generated P/Invoke) instead of DllImport, making it fully compatible with AOT compilation environments. \uD83D\uDE80 Getting Started with LibSodium.Net Here's how you can quickly integrate LibSodium.Net into your .NET projects. ✨ Install via NuGet You can easily install LibSodium.Net using the NuGet package manager: CLI dotnet add package LibSodium.Net Visual Studio Right-click your project in Solution Explorer. Choose Manage NuGet Packages. Search for LibSodium.Net and click Install. Package Manager Console Install-Package LibSodium.Net"
  },
  "index.html": {
    "href": "index.html",
    "title": "LibSodium.Net | LibSodium.Net",
    "summary": "LibSodium.Net Modern Cryptography for .NET Welcome to LibSodium.Net, the secure and developer-friendly .NET bindings for libsodium — a battle-tested, modern cryptographic library used around the world. Whether you're building web services, desktop apps, IoT devices, or cross-platform tools, LibSodium.Net helps you add robust, efficient, and secure cryptographic functionality with confidence. All code examples in the guide are written in C# and use LibSodium.Net’s allocation-free API. ✨ Simple, Powerful, and Secure Built on the trusted libsodium C library. Complete coverage of the libsodium API —every primitive and helper— fully documented in .NET style. Designed for modern .NET: efficient memory handling via Span<T>, support for AOT via LibraryImport. Safe-by-default APIs that help you do cryptography right. Includes secure memory utilities, symmetric and asymmetric encryption, hashing, key derivation, and more. \uD83C\uDF0A First-Class Streaming Encryption LibSodium.Net provides idiomatic support for large file and streaming authenticated encryption using libsodium’s XChaCha20-Poly1305. Powered by the SecretStream API, you can securely encrypt and decrypt files of any size with tamper-detection and zero nonce reuse risk — all in a few lines of code. \uD83D\uDE80 Get Started Install the NuGet package: dotnet add package LibSodium.Net Then head over to our Guide to learn how to: Encrypt and decrypt data securely Generate cryptographic keys Work with secure memory Handle errors properly and safely \uD83D\uDCC4 Reference Documentation Need details on specific APIs? Browse the full Reference Documentation to explore everything from SecretBox and SecureMemory<T> to stream encryption and key generation helpers."
  }
}