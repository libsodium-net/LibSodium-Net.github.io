{
  "api/LibSodium.Base64Encoding.html": {
    "href": "api/LibSodium.Base64Encoding.html",
    "title": "Class Base64Encoding | LibSodium.Net",
    "summary": "Class Base64Encoding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for Base64 encoding and decoding. public static class Base64Encoding Inheritance object Base64Encoding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Base64ToBin(ReadOnlySpan<char>, Span<byte>, Base64Variant, string?) Decodes a Base64 string into a binary representation. public static Span<byte> Base64ToBin(ReadOnlySpan<char> b64, Span<byte> bin, Base64Variant variant, string? ignore = null) Parameters b64 ReadOnlySpan<char> The Base64 string to decode as a ReadOnlySpan. bin Span<byte> The span to store the decoded binary data. variant Base64Variant The Base64 variant to use. ignore string Characters to ignore during decoding. Returns Span<byte> A span containing the decoded binary data. Base64ToBin(string, Span<byte>, Base64Variant, string?) Decodes a Base64 string into a binary representation. public static Span<byte> Base64ToBin(string b64, Span<byte> bin, Base64Variant variant, string? ignore = null) Parameters b64 string The Base64 string to decode. bin Span<byte> The span to store the decoded binary data. variant Base64Variant The Base64 variant to use. ignore string Characters to ignore during decoding. Returns Span<byte> A span containing the decoded binary data. BinToBase64(ReadOnlySpan<byte>, Base64Variant) Encodes binary data into a Base64 string. public static string BinToBase64(ReadOnlySpan<byte> bin, Base64Variant variant) Parameters bin ReadOnlySpan<byte> The binary data to encode. variant Base64Variant The Base64 variant to use. Returns string A Base64 encoded string. BinToBase64(ReadOnlySpan<byte>, Span<char>, Base64Variant) Encodes binary data into a Base64 representation and stores it in a character span. public static Span<char> BinToBase64(ReadOnlySpan<byte> bin, Span<char> b64, Base64Variant variant) Parameters bin ReadOnlySpan<byte> The binary data to encode. b64 Span<char> The span to store the Base64 encoded data. variant Base64Variant The Base64 variant to use. Returns Span<char> A span containing the Base64 encoded data. GetBase64DecodedMaxLen(int) Calculates the maximum length of the decoded binary data from a Base64 string. public static int GetBase64DecodedMaxLen(int base64Len) Parameters base64Len int The length of the Base64 string. Returns int The maximum length of the decoded binary data. GetBase64EncodedLen(int, Base64Variant, bool) Calculates the length of the Base64 encoded string for a given binary length. public static int GetBase64EncodedLen(int binLen, Base64Variant variant, bool includeNullTerminator = true) Parameters binLen int The length of the binary data. variant Base64Variant The Base64 variant to use. includeNullTerminator bool Indicates whether to include a null terminator in the length calculation. Returns int The length of the Base64 encoded string."
  },
  "api/LibSodium.Base64Variant.html": {
    "href": "api/LibSodium.Base64Variant.html",
    "title": "Enum Base64Variant | LibSodium.Net",
    "summary": "Enum Base64Variant Namespace LibSodium Assembly LibSodium.Net.dll Represents Base64 encoding variants. public enum Base64Variant Fields Original = 1 Original Base64 encoding variant. OriginalNoPadding = 3 Original Base64 encoding variant with no padding. UrlSafe = 5 URL safe Base64 encoding variant. UrlSafeNoPadding = 7 URL safe Base64 encoding variant with no padding."
  },
  "api/LibSodium.CryptoSecretStream.html": {
    "href": "api/LibSodium.CryptoSecretStream.html",
    "title": "Class CryptoSecretStream | LibSodium.Net",
    "summary": "Class CryptoSecretStream Namespace LibSodium Assembly LibSodium.Net.dll The CryptoSecretStream class provides methods for performing authenticated encryption and decryption of data streams, with optional additional authenticated data. It is based on the XChaCha20-Poly1305 algorithm. public static class CryptoSecretStream Inheritance object CryptoSecretStream Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields HeaderLen The length of the header used in the secret stream. public const int HeaderLen = 24 Field Value int KeyLen The length of the key used for encryption and decryption. public const int KeyLen = 32 Field Value int OverheadLen The length of the overhead added to each ciphertext message. This includes the authentication tag and any necessary metadata for the stream. public static int OverheadLen Field Value int StateLen The length of the state used in the secret stream. public static int StateLen Field Value int Methods DecryptChunk(Span<byte>, Span<byte>, out CryptoSecretStreamTag, ReadOnlySpan<byte>) Decrypts and verifies the authenticity of a block of data using the secret stream. public static Span<byte> DecryptChunk(Span<byte> state, Span<byte> cleartext, out CryptoSecretStreamTag tag, ReadOnlySpan<byte> ciphertext) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. cleartext Span<byte> The span to write the decrypted data to. Must have a length of at least ciphertext.Length - OverheadLen. tag CryptoSecretStreamTag When this method returns, contains the tag associated with the decrypted message. ciphertext ReadOnlySpan<byte> The encrypted and authenticated data to decrypt. Returns Span<byte> A Span<T> representing the decrypted data written to cleartext. Exceptions ArgumentException If the length of the state or cleartext spans are incorrect. LibSodiumException If the decryption or authentication of the chunk fails, likely due to tampered ciphertext. DecryptChunk(Span<byte>, Span<byte>, out CryptoSecretStreamTag, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts and verifies the authenticity of a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> DecryptChunk(Span<byte> state, Span<byte> cleartext, out CryptoSecretStreamTag tag, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> additionalData) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. cleartext Span<byte> The span to write the decrypted data to. Must have a length of at least ciphertext.Length - OverheadLen. tag CryptoSecretStreamTag When this method returns, contains the tag associated with the decrypted message. ciphertext ReadOnlySpan<byte> The encrypted and authenticated data to decrypt. additionalData ReadOnlySpan<byte> Additional authenticated data that was cryptographically incorporated during the calculation of the authentication tag for the corresponding ciphertext. This value must be identical to the one used during the EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) call for authentication to succeed. Returns Span<byte> A Span<T> representing the decrypted data written to cleartext. Exceptions ArgumentException If the length of the state or cleartext spans are incorrect. LibSodiumException If the decryption or authentication of the chunk fails, likely due to tampered ciphertext or incorrect AAD. EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag) Encrypts and authenticates a block of data using the secret stream. public static Span<byte> EncryptChunk(Span<byte> state, Span<byte> ciphertext, ReadOnlySpan<byte> cleartext, CryptoSecretStreamTag tag) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. ciphertext Span<byte> The span to write the encrypted and authenticated data to. Must have a length of at least cleartext.Length + OverheadLen. cleartext ReadOnlySpan<byte> The data to encrypt. tag CryptoSecretStreamTag The tag to associate with this message. Returns Span<byte> A Span<T> representing the encrypted and authenticated data written to ciphertext. Exceptions ArgumentException If the length of the state or ciphertext spans are incorrect. LibSodiumException If the encryption of the block fails. EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) Encrypts and authenticates a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> EncryptChunk(Span<byte> state, Span<byte> ciphertext, ReadOnlySpan<byte> cleartext, CryptoSecretStreamTag tag, ReadOnlySpan<byte> additionalData) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. ciphertext Span<byte> The span to write the encrypted and authenticated data to. Must have a length of at least cleartext.Length + OverheadLen. cleartext ReadOnlySpan<byte> The data to encrypt. tag CryptoSecretStreamTag The tag to associate with this message. additionalData ReadOnlySpan<byte> Additional data that is cryptographically incorporated during the calculation of the authentication tag for the ciphertext. This data is authenticated but not encrypted. Returns Span<byte> A Span<T> representing the encrypted and authenticated data written to ciphertext. Exceptions ArgumentException If the length of the state or ciphertext spans are incorrect. LibSodiumException If the encryption of the chunk fails. GenerateKey(Span<byte>) Generates a random key for use with the secret stream. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> The span to write the generated key to. Exceptions ArgumentException If the length of the key span is not equal to KeyLen. InitializeDecryption(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Initializes the authenticated decryption process for a secret stream. public static void InitializeDecryption(Span<byte> state, ReadOnlySpan<byte> header, ReadOnlySpan<byte> key) Parameters state Span<byte> The span to write the initial state to. Must be StateLen bytes long. header ReadOnlySpan<byte> The stream header received from the sender. Must be HeaderLen bytes long. key ReadOnlySpan<byte> The secret key used for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of decryption fails, likely due to an incorrect header or key. InitializeEncryption(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Initializes the authenticated encryption process for a secret stream. public static void InitializeEncryption(Span<byte> state, Span<byte> header, ReadOnlySpan<byte> key) Parameters state Span<byte> The span to write the initial state to. Must be StateLen bytes long. header Span<byte> The span to write the stream header to. Must be HeaderLen bytes long. key ReadOnlySpan<byte> The secret key to use for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of encryption fails."
  },
  "api/LibSodium.CryptoSecretStreamTag.html": {
    "href": "api/LibSodium.CryptoSecretStreamTag.html",
    "title": "Enum CryptoSecretStreamTag | LibSodium.Net",
    "summary": "Enum CryptoSecretStreamTag Namespace LibSodium Assembly LibSodium.Net.dll The tags used in the secret stream. public enum CryptoSecretStreamTag Fields Final = 3 The value of the tag corresponding to the final message. Message = 0 The value of the tag corresponding to a regular message. Push = 1 Indicates that the message marks the end of a set of messages, but not the end of the stream Rekey = 2 “forget” the key used to encrypt this message and the previous ones, and derive a new secret key"
  },
  "api/LibSodium.HexEncoding.html": {
    "href": "api/LibSodium.HexEncoding.html",
    "title": "Class HexEncoding | LibSodium.Net",
    "summary": "Class HexEncoding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for encoding and decoding hexadecimal strings and byte buffers. public static class HexEncoding Inheritance object HexEncoding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BinToHex(ReadOnlySpan<byte>) Converts a byte buffer to a hexadecimal string in constant time for a given size. public static string BinToHex(ReadOnlySpan<byte> bin) Parameters bin ReadOnlySpan<byte> The byte buffer to convert. Returns string A hexadecimal string representation of the byte buffer. BinToHex(ReadOnlySpan<byte>, Span<char>) Converts a byte buffer to a hexadecimal string using a provided character span. public static Span<char> BinToHex(ReadOnlySpan<byte> bin, Span<char> hex) Parameters bin ReadOnlySpan<byte> The byte buffer to convert. hex Span<char> The span to write the hexadecimal string into. Returns Span<char> A span containing the hexadecimal string representation. HexToBin(ReadOnlySpan<char>, Span<byte>, string?) Converts a span of characters representing a hexadecimal string to a byte buffer. public static Span<byte> HexToBin(ReadOnlySpan<char> hex, Span<byte> bin, string? ignore = null) Parameters hex ReadOnlySpan<char> The span of characters representing the hexadecimal string. bin Span<byte> The span to write the byte buffer into. ignore string Optional characters to ignore during conversion. Returns Span<byte> A span containing the converted byte buffer. HexToBin(string, Span<byte>, string?) Converts a hexadecimal string to a byte buffer. public static Span<byte> HexToBin(string hex, Span<byte> bin, string? ignore = null) Parameters hex string The hexadecimal string to convert. bin Span<byte> The span to write the byte buffer into. ignore string Optional characters to ignore during conversion. Returns Span<byte> A span containing the converted byte buffer."
  },
  "api/LibSodium.LibSodiumException.html": {
    "href": "api/LibSodium.LibSodiumException.html",
    "title": "Class LibSodiumException | LibSodium.Net",
    "summary": "Class LibSodiumException Namespace LibSodium Assembly LibSodium.Net.dll Represents errors that occur during Sodium operations. [Serializable] public class LibSodiumException : CryptographicException, ISerializable Inheritance object Exception SystemException CryptographicException LibSodiumException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors LibSodiumException() Initializes a new instance of the LibSodiumException class. public LibSodiumException() LibSodiumException(string?) Initializes a new instance of the LibSodiumException class with a specified error message. public LibSodiumException(string? message) Parameters message string The error message that explains the reason for the exception. LibSodiumException(string?, Exception?) Initializes a new instance of the LibSodiumException class with a specified error message and a reference to the inner exception that is the cause of this exception. public LibSodiumException(string? message, Exception? innerException) Parameters message string The error message that explains the reason for the exception. innerException Exception The exception that is the cause of the current exception, or a null reference if no inner exception is specified."
  },
  "api/LibSodium.LibraryInitializer.html": {
    "href": "api/LibSodium.LibraryInitializer.html",
    "title": "Class LibraryInitializer | LibSodium.Net",
    "summary": "Class LibraryInitializer Namespace LibSodium Assembly LibSodium.Net.dll Static class that manages the initialization and configuration of libsodium. public static class LibraryInitializer Inheritance object LibraryInitializer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsInitialized Gets a value indicating whether the library has been initialized public static bool IsInitialized { get; } Property Value bool Methods EnsureInitialized() Ensures that the libsodium library is initialized. public static void EnsureInitialized()"
  },
  "api/LibSodium.LibraryVersion.html": {
    "href": "api/LibSodium.LibraryVersion.html",
    "title": "Class LibraryVersion | LibSodium.Net",
    "summary": "Class LibraryVersion Namespace LibSodium Assembly LibSodium.Net.dll Provides methods to retrieve the version information of the Sodium library. public static class LibraryVersion Inheritance object LibraryVersion Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetMajor() Gets the major version number of the Sodium library. public static int GetMajor() Returns int The major version number as an integer. GetMinor() Gets the minor version number of the Sodium library. public static int GetMinor() Returns int The minor version number as an integer. GetString() Gets the version string of the Sodium library. public static string? GetString() Returns string The version string as a string, or null if the string could not be retrieved."
  },
  "api/LibSodium.RandomGenerator.html": {
    "href": "api/LibSodium.RandomGenerator.html",
    "title": "Class RandomGenerator | LibSodium.Net",
    "summary": "Class RandomGenerator Namespace LibSodium Assembly LibSodium.Net.dll Static class for random number generation. public static class RandomGenerator Inheritance object RandomGenerator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields SeedLen The length of the seed used for deterministic random byte generation. public const int SeedLen = 32 Field Value int Methods Close() Closes the random number generator. public static void Close() Exceptions LibSodiumException Thrown when randombytes_close() fails. Fill(Span<byte>) Fills the specified buffer with random bytes. public static void Fill(Span<byte> buffer) Parameters buffer Span<byte> The buffer to fill with random bytes. FillDeterministic(Span<byte>, ReadOnlySpan<byte>) Fills the specified buffer with deterministic random bytes based on the provided seed. It produces the same sequence of random bytes for the same seed. public static void FillDeterministic(Span<byte> buffer, ReadOnlySpan<byte> seed) Parameters buffer Span<byte> The buffer to fill with deterministic random bytes. seed ReadOnlySpan<byte> The seed used for deterministic random byte generation. Exceptions ArgumentException Thrown when the seed length is not equal to SeedLen. GetUInt32() Gets a random unsigned 32-bit integer. public static uint GetUInt32() Returns uint A random unsigned 32-bit integer. GetUInt32(uint) Gets a random unsigned 32-bit integer less than the specified upper bound. public static uint GetUInt32(uint upperBound) Parameters upperBound uint The upper bound (exclusive) for the random number. Returns uint A random unsigned 32-bit integer less than upperBound. Stir() Stirs the random number generator to ensure randomness. public static void Stir()"
  },
  "api/LibSodium.SecretBox.html": {
    "href": "api/LibSodium.SecretBox.html",
    "title": "Class SecretBox | LibSodium.Net",
    "summary": "Class SecretBox Namespace LibSodium Assembly LibSodium.Net.dll Provides static methods for authenticated symmetric encryption and decryption using the Sodium secretbox primitives, specifically the XSalsa20 stream cipher and Poly1305 MAC for authentication. These methods offer combined encryption/authentication and detached encryption/authentication, with variations for handling nonces and Message Authentication Codes (MACs) within or separate from the ciphertext. public static class SecretBox Inheritance object SecretBox Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields KeyLen Represents the length of the encryption key in bytes. public const int KeyLen = 32 Field Value int MacLen represents the length of the Message Authentication Code (MAC) in bytes public const int MacLen = 16 Field Value int NonceLen Represents the length of the nonce (number used once) in bytes. public const int NonceLen = 24 Field Value int Methods DecryptCombined(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts the provided ciphertext, which begins with the nonce and Message Authentication Code (MAC), using the specified key, writing the resulting plaintext to the provided buffer. public static Span<byte> DecryptCombined(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key) Parameters plaintext Span<byte> The buffer to receive the decrypted plaintext. Must be at least ciphertext length minus MacLen and NonceLen bytes. ciphertext ReadOnlySpan<byte> The ciphertext data to decrypt, which begins with the nonce and MAC. Must be at least MacLen + NonceLen bytes in length. key ReadOnlySpan<byte> The decryption key. Must be KeyLen bytes in length. Returns Span<byte> A span referencing the beginning of the plaintext buffer, containing the decrypted plaintext. Exceptions ArgumentException Thrown when: The plaintext buffer is too small. The ciphertext buffer is too small. The key length is incorrect. LibSodiumException Thrown when decryption or verification fails. DecryptCombined(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts the provided ciphertext, which has the Message Authentication Code (MAC) prepended, using the specified key and nonce, writing the resulting plaintext to the provided buffer. public static Span<byte> DecryptCombined(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce) Parameters plaintext Span<byte> The buffer to receive the decrypted plaintext. Must be at least ciphertext length minus MacLen bytes. ciphertext ReadOnlySpan<byte> The ciphertext data to decrypt, which includes the MAC prepended. Must be at least MacLen bytes in length. key ReadOnlySpan<byte> The decryption key. Must be KeyLen bytes in length. nonce ReadOnlySpan<byte> The nonce (number used once) for decryption. Must be NonceLen bytes in length. Returns Span<byte> A span referencing the beginning of the plaintext buffer, containing the decrypted plaintext. Exceptions ArgumentException Thrown when: The plaintext buffer is too small. The ciphertext buffer is too small. The key length is incorrect. The nonce length is incorrect. LibSodiumException Thrown when decryption or verification fails. DecryptDetached(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts the provided ciphertext, which starts with the nonce, using the specified key and Message Authentication Code (MAC), writing the resulting plaintext to the provided buffer. public static Span<byte> DecryptDetached(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac) Parameters plaintext Span<byte> The buffer to receive the decrypted plaintext. Must be at least ciphertext length minus NonceLen bytes. ciphertext ReadOnlySpan<byte> The ciphertext data to decrypt, which starts with the nonce. Must be at least NonceLen bytes in length. key ReadOnlySpan<byte> The decryption key. Must be KeyLen bytes in length. mac ReadOnlySpan<byte> The Message Authentication Code (MAC) for verification. Must be MacLen bytes in length. Returns Span<byte> A span referencing the beginning of the plaintext buffer, containing the decrypted plaintext. Exceptions ArgumentException Thrown when: The plaintext buffer is too small. The mac length is incorrect. The key length is incorrect. The ciphertext length is too small. LibSodiumException Thrown when decryption or verification fails. DecryptDetached(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts the provided ciphertext using the specified key, nonce, and Message Authentication Code (MAC), writing the resulting plaintext to the provided buffer. public static Span<byte> DecryptDetached(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac, ReadOnlySpan<byte> nonce) Parameters plaintext Span<byte> The buffer to receive the decrypted plaintext. Must be at least the same size as ciphertext. ciphertext ReadOnlySpan<byte> The ciphertext data to decrypt. key ReadOnlySpan<byte> The decryption key. Must be KeyLen bytes in length. mac ReadOnlySpan<byte> The Message Authentication Code (MAC) for verification. Must be MacLen bytes in length. nonce ReadOnlySpan<byte> The nonce (number used once) for decryption. Must be NonceLen bytes in length. Returns Span<byte> A span referencing the beginning of the plaintext buffer, containing the decrypted plaintext. Exceptions ArgumentException Thrown when: The plaintext buffer is too small. The mac length is incorrect. The nonce length is incorrect. The key length is incorrect. LibSodiumException Thrown when decryption or verification fails. EncryptCombined(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts the provided plaintext using the specified key and a randomly generated nonce, writing the nonce, Message Authentication Code (MAC), and encrypted data to the provided ciphertext buffer. public static Span<byte> EncryptCombined(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key) Parameters ciphertext Span<byte> The buffer to receive the nonce, MAC, and encrypted data. Must be at least plaintext length plus MacLen and NonceLen bytes. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. key ReadOnlySpan<byte> The encryption key. Must be KeyLen bytes in length. Returns Span<byte> A span referencing the beginning of the ciphertext buffer, containing the nonce, MAC, and then the encrypted data in that order. Exceptions ArgumentException Thrown when: The ciphertext buffer is too small. The key length is incorrect. LibSodiumException Thrown when the underlying encryption operation fails. EncryptCombined(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts the provided plaintext using the specified key and nonce, writing the resulting ciphertext, including the Message Authentication Code (MAC), to the provided ciphertext buffer. public static Span<byte> EncryptCombined(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce) Parameters ciphertext Span<byte> The buffer to receive the encrypted data, including the MAC. Must be at least plaintext length plus MacLen bytes. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. key ReadOnlySpan<byte> The encryption key. Must be KeyLen bytes in length. nonce ReadOnlySpan<byte> The nonce (number used once) for encryption. Must be NonceLen bytes in length. Returns Span<byte> A span referencing the beginning of the ciphertext buffer, containing the MAC followed by the encrypted plaintext. Exceptions ArgumentException Thrown when: The ciphertext buffer is too small. The key length is incorrect. The nonce length is incorrect. LibSodiumException Thrown when the underlying encryption operation fails. EncryptDetached(Span<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts the provided plaintext using the specified key and a randomly generated nonce, producing a detached Message Authentication Code (MAC) and writing the nonce followed by the encrypted plaintext to the ciphertext buffer. public static Span<byte> EncryptDetached(Span<byte> ciphertext, Span<byte> mac, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key) Parameters ciphertext Span<byte> The buffer to receive the randomly generated nonce followed by the encrypted plaintext. Must be at least plaintext length plus NonceLen bytes. mac Span<byte> The buffer to receive the generated Message Authentication Code (MAC). Must be MacLen bytes in length. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. key ReadOnlySpan<byte> The encryption key. Must be KeyLen bytes in length. Returns Span<byte> A span referencing the beginning of the ciphertext buffer, containing the nonce followed by the encrypted plaintext. Exceptions ArgumentException Thrown when: The ciphertext buffer is too small. The mac buffer has an incorrect length. The key buffer has an incorrect length. LibSodiumException Thrown when the encryption operation fails. EncryptDetached(Span<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts the provided plaintext using the specified key and nonce, producing a detached Message Authentication Code (MAC) and writing the encrypted plaintext to the ciphertext buffer. public static Span<byte> EncryptDetached(Span<byte> ciphertext, Span<byte> mac, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> nonce) Parameters ciphertext Span<byte> The buffer to receive the encrypted plaintext. Must be at least the same size as plaintext. mac Span<byte> The buffer to receive the generated Message Authentication Code (MAC). Must be MacLen bytes in length. plaintext ReadOnlySpan<byte> The plaintext data to encrypt. key ReadOnlySpan<byte> The encryption key. Must be KeyLen bytes in length. nonce ReadOnlySpan<byte> The nonce (number used once) for encryption. Must be NonceLen bytes in length. Returns Span<byte> A span referencing the beginning of the ciphertext buffer, containing the encrypted plaintext. Exceptions ArgumentException Thrown when: The ciphertext buffer is too small. The mac buffer is the incorrect length. The nonce length is incorrect. The key length is incorrect. LibSodiumException Thrown when the encryption operation fails."
  },
  "api/LibSodium.SecretStream.html": {
    "href": "api/LibSodium.SecretStream.html",
    "title": "Class SecretStream | LibSodium.Net",
    "summary": "Class SecretStream Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level, stream-based authenticated encryption and decryption using the XChaCha20-Poly1305 algorithm. This class abstracts the complexity of securely processing large data streams, including chunking, authentication, and cryptographic state management. public static class SecretStream Inheritance object SecretStream Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class is built on LibSodium’s crypto_secretstream_xchacha20poly1305 API, using XChaCha20 for encryption and Poly1305 for message authentication. The large 192-bit nonce (24 bytes) virtually eliminates the risk of nonce reuse when generated randomly. The stream is processed in fixed-size chunks (64 KB), each individually encrypted and authenticated. A randomly generated header (nonce and metadata) is prepended to the stream and required for successful decryption. Security Considerations: Key Management: Keys must be generated securely and stored safely. Compromise of the key invalidates confidentiality and integrity guarantees. Nonce Handling: Nonces are generated internally. Do not reuse headers or keys manually unless you know what you're doing. Integrity: Poly1305 tags ensure tampering is detected during decryption. Any modification will result in decryption failure. Fields PlainChunkSize The size of each plaintext chunk processed during encryption (64KB). This chunk size is used to divide the input stream into manageable blocks. public const int PlainChunkSize = 65536 Field Value int Methods Decrypt(Stream, Stream, SecureMemory<byte>) Synchronously decrypts data from the input stream using a key stored in secure memory, and writes the plaintext to the output stream. public static void Decrypt(Stream input, Stream output, SecureMemory<byte> key) Parameters input Stream The stream containing encrypted data. It must begin with the secret stream header written during encryption. output Stream The stream where decrypted plaintext will be written. key SecureMemory<byte> A SecureMemory<T> buffer containing the decryption key. This key must match the one used to encrypt the stream. Remarks This method behaves identically to Decrypt(Stream, Stream, ReadOnlySpan<byte>), but uses a secure memory buffer for enhanced key confidentiality. The decryption header is consumed automatically at the beginning of the stream. Chunks are processed sequentially, and any failure in tag verification will cause decryption to halt with an exception. Internal buffers are cleared and returned to the pool after use. The input and output streams remain open. Exceptions ArgumentNullException Thrown if input, output, or key is null. ObjectDisposedException Thrown if the secure memory key has already been disposed. EndOfStreamException Thrown if the stream ends before the Final tag is encountered. LibSodiumException Thrown if the authentication of a chunk fails, which indicates tampering or a mismatched key. Decrypt(Stream, Stream, ReadOnlySpan<byte>) Synchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying each chunk's authenticity using XChaCha20-Poly1305. public static void Decrypt(Stream input, Stream output, ReadOnlySpan<byte> key) Parameters input Stream The readable stream containing encrypted data. The stream must begin with the encryption header produced during the corresponding encryption process. output Stream The writable stream where decrypted plaintext will be written. key ReadOnlySpan<byte> The secret decryption key. It must match the key used to encrypt the stream and be exactly 32 bytes long. Remarks This method processes the encrypted stream in chunks, validating each chunk before decrypting it. If authentication fails, a LibSodiumException is thrown and the decrypted output is invalidated. The stream must start with a header containing the nonce and metadata necessary for decryption. This header is automatically consumed at the beginning of the stream. All internal buffers are zeroed after use. The input and output streams are not closed automatically. Exceptions ArgumentException Thrown if the key is invalid. EndOfStreamException Thrown if the stream ends before the Final tag is reached, indicating an incomplete or truncated stream. LibSodiumException Thrown if authentication fails, indicating the ciphertext has been tampered with or the wrong key was used. DecryptAsync(Stream, Stream, SecureMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream using a key stored in SecureMemory<T>, and writes the plaintext to the output stream. public static Task DecryptAsync(Stream input, Stream output, SecureMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing the encrypted data. The stream must begin with the encryption header. output Stream The writable stream where the decrypted plaintext will be written. key SecureMemory<byte> A secure memory buffer containing the decryption key. This must match the key used to encrypt the stream. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks This overload behaves identically to DecryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken), but uses a SecureMemory<T> buffer for enhanced runtime key protection. The key is securely wiped from memory once decryption is complete. Stream lifetime is not managed automatically. Exceptions ArgumentNullException Thrown if any argument is null. ObjectDisposedException Thrown if the secure key has already been disposed. EndOfStreamException Thrown if the stream ends before the final tag is reached. LibSodiumException Thrown if the integrity check fails (e.g., if the ciphertext has been tampered with). OperationCanceledException Thrown if the operation is canceled. DecryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying integrity using XChaCha20-Poly1305. public static Task DecryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing encrypted data. The stream must begin with the header produced during encryption. output Stream The writable stream where decrypted plaintext will be written. key ReadOnlyMemory<byte> The secret key used for decryption. It must match the key used during encryption. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks The decryption process begins by reading the stream header, which includes a nonce required to initialize the decryption state. Each encrypted chunk is then read, authenticated, and decrypted in order. If any chunk fails authentication, a LibSodiumException is thrown and no plaintext is written for that chunk. If the stream ends before encountering a chunk tagged as Final, an EndOfStreamException is thrown. This method uses pooled buffers and zeroes out internal state after use to reduce memory leakage risks. Input and output streams are not closed automatically. Exceptions ArgumentNullException Thrown if any argument is null. EndOfStreamException Thrown if the stream ends unexpectedly or the final tag is never reached. LibSodiumException Thrown if the integrity check fails on any chunk (i.e., authentication tag mismatch). OperationCanceledException Thrown if the operation is canceled. Encrypt(Stream, Stream, SecureMemory<byte>) Synchronously encrypts data from the input stream using a secure key, and writes the ciphertext to the output stream. public static void Encrypt(Stream input, Stream output, SecureMemory<byte> key) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key SecureMemory<byte> A SecureMemory<T> buffer containing the encryption key. It must be 32 bytes in size, and will be securely wiped from memory after use. Remarks This method is functionally equivalent to Encrypt(Stream, Stream, ReadOnlySpan<byte>), but accepts the encryption key wrapped in SecureMemory<T> for added in-memory protection. This improves resistance to key leakage through memory inspection, especially in long-lived processes. Exceptions ArgumentNullException Thrown if key, input, or output is null. ObjectDisposedException Thrown if the key has already been disposed. ArgumentException Thrown if the key is invalid (wrong length). Encrypt(Stream, Stream, ReadOnlySpan<byte>) Synchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static void Encrypt(Stream input, Stream output, ReadOnlySpan<byte> key) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key ReadOnlySpan<byte> The encryption key. Must be securely generated and exactly 32 bytes long for XChaCha20-Poly1305. Remarks This method performs stream encryption in-place and blocks the calling thread until completion. It is suitable for scenarios where asynchronous patterns are not required or not supported. The input is processed in chunks of PlainChunkSize bytes. Each chunk is encrypted and authenticated before being written to the output stream. A cryptographic header is written at the beginning, and a final tag is written after the last chunk. All internal buffers are zeroed after use, and pooled memory is returned. The input and output streams are not closed or disposed automatically. Exceptions ArgumentException Thrown if the key is invalid. EndOfStreamException Thrown if the input stream ends unexpectedly. EncryptAsync(Stream, Stream, SecureMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream using a key stored in SecureMemory<T> and writes the ciphertext to the output stream. public static Task EncryptAsync(Stream input, Stream output, SecureMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key SecureMemory<byte> A secure memory buffer containing the secret key. It is critical that this buffer is disposed properly to ensure the key is wiped from memory. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks This overload offers identical functionality to EncryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken), but uses a SecureMemory<T> buffer to enhance key security during runtime. Using secure memory reduces the risk of sensitive data being captured in memory dumps or accessed by unauthorized code. Exceptions ArgumentNullException Thrown if any argument is null. ObjectDisposedException Thrown if the secure key has already been disposed. OperationCanceledException Thrown if the operation is canceled. EncryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static Task EncryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key ReadOnlyMemory<byte> The secret key for encryption. Must be securely generated and kept confidential. Typically 32 bytes in length for XChaCha20-Poly1305. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks The input stream is read in PlainChunkSize blocks. Each block is encrypted and written to the output stream with an authentication tag to ensure integrity. A cryptographic header (including a randomly generated nonce) is prepended to the output. This header is required for successful decryption. The encryption state is maintained internally and finalized when the last chunk is written with the Final tag. Note: The caller is responsible for managing the lifetime of the input/output streams. They are not closed or disposed automatically. Exceptions ArgumentNullException Thrown if any argument is null. OperationCanceledException Thrown if the operation is canceled."
  },
  "api/LibSodium.SecureBigUnsignedInteger.html": {
    "href": "api/LibSodium.SecureBigUnsignedInteger.html",
    "title": "Class SecureBigUnsignedInteger | LibSodium.Net",
    "summary": "Class SecureBigUnsignedInteger Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for working with arbitrary large little endian big unsigned integers in a secure way (constant time for a given length) public static class SecureBigUnsignedInteger Inheritance object SecureBigUnsignedInteger Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Add(Span<byte>, ReadOnlySpan<byte>) Adds two byte buffers representing big unsigned integers in constant time, storing the result in the second buffer public static void Add(Span<byte> a, ReadOnlySpan<byte> b) Parameters a Span<byte> The first byte buffer representing a big unsigned integer. b ReadOnlySpan<byte> The second byte buffer representing a big unsigned integer. It receives the result. Compare(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers representing big unsigned integers. public static int Compare(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> The first byte buffer. b2 ReadOnlySpan<byte> The second byte buffer. Returns int A negative number if b1 is less than b2, zero if they are equal, and a positive number if b1 is greater than b2. Equals(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers for equality in constant time. public static bool Equals(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> First buffer to compare. b2 ReadOnlySpan<byte> Second buffer to compare. Returns bool True if the buffers are equal, false otherwise. Increment(Span<byte>) Increments the given byte buffer representing a big unsigned integer by 1. public static void Increment(Span<byte> number) Parameters number Span<byte> The byte buffer to increment. Increment(Span<byte>, ulong) Increments the given byte buffer representing a big unsigned integer by a specified value. public static void Increment(Span<byte> number, ulong increment) Parameters number Span<byte> The byte buffer representing a big unsigned integer to increment. increment ulong The value to increment by. IsZero(ReadOnlySpan<byte>) Checks if the given byte buffer is zero. public static bool IsZero(ReadOnlySpan<byte> b) Parameters b ReadOnlySpan<byte> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Subtract(Span<byte>, ReadOnlySpan<byte>) Subtracts one byte buffer from another representing big unsigned integers. public static void Subtract(Span<byte> subtrahend, ReadOnlySpan<byte> minuend) Parameters subtrahend Span<byte> The byte buffer to subtract from. minuend ReadOnlySpan<byte> The byte buffer to subtract."
  },
  "api/LibSodium.SecureMemory-1.html": {
    "href": "api/LibSodium.SecureMemory-1.html",
    "title": "Class SecureMemory<T> | LibSodium.Net",
    "summary": "Class SecureMemory<T> Namespace LibSodium Assembly LibSodium.Net.dll Provides a secure unmanaged memory buffer for unmanaged types, using libsodium for memory protection. This class encapsulates secure memory allocation, read-only protection, and zeroing. public sealed class SecureMemory<T> : IDisposable where T : unmanaged Type Parameters T The unmanaged type of elements in the secure memory buffer. Inheritance object SecureMemory<T> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SecureMemory(int) Initializes a new instance of the SecureMemory<T> class with the specified length. public SecureMemory(int length) Parameters length int The number of elements of type T to allocate. Exceptions LibSodiumException Thrown if memory allocation fails. Properties IsDisposed Gets a value indicating whether the object has been disposed. public bool IsDisposed { get; } Property Value bool IsReadOnly Gets a value indicating whether the memory region is read-only. public bool IsReadOnly { get; } Property Value bool Length Gets the length of the secure unmanaged memory buffer, in number of elements of type T. public int Length { get; } Property Value int Methods AsMemory() Gets a Memory<T> representing the secure unmanaged memory buffer. public Memory<T> AsMemory() Returns Memory<T> Exceptions InvalidOperationException AsReadOnlyMemory() Gets a ReadOnlyMemory<T> representing the secure unmanaged memory buffer. public ReadOnlyMemory<T> AsReadOnlyMemory() Returns ReadOnlyMemory<T> Exceptions ObjectDisposedException AsReadOnlySpan() Gets a ReadOnlySpan<T> representing the secure unmanaged memory buffer. public ReadOnlySpan<T> AsReadOnlySpan() Returns ReadOnlySpan<T> Remarks While this method returns a new ReadOnlySpan<T> instance on each call, all returned spans represent the same underlying memory region. Exceptions ObjectDisposedException Thrown if the object has been disposed. AsSpan() Gets a Span<T> representing the secure unmanaged memory buffer. public Span<T> AsSpan() Returns Span<T> Remarks While this method returns a new Span<T> instance on each call, all returned spans represent the same underlying memory region. Modifications made through one span will be visible through any other span obtained from this instance. Exceptions ObjectDisposedException Thrown if the object has been disposed. InvalidOperationException Thrown if the memory region is read-only. Dispose() Releases all resources used by the SecureMemory<T> object, including the allocated unmanaged secure memory. public void Dispose() ~SecureMemory() Finalizes an instance of the SecureMemory<T> class. protected ~SecureMemory() MemZero() Fills the secure unmanaged memory buffer with zeros, effectively erasing its contents. public void MemZero() Exceptions ObjectDisposedException Thrown if the object has been disposed. ProtectReadOnly() Marks the secure unmanaged memory buffer as read-only. public void ProtectReadOnly() Exceptions ObjectDisposedException Thrown if the object has been disposed. LibSodiumException Thrown if setting the memory to read-only fails. ProtectReadWrite() Marks the secure unmanaged memory buffer as read-write. public void ProtectReadWrite() Exceptions ObjectDisposedException Thrown if the object has been disposed. LibSodiumException Thrown if setting the memory to read-write fails."
  },
  "api/LibSodium.SecureMemory.html": {
    "href": "api/LibSodium.SecureMemory.html",
    "title": "Class SecureMemory | LibSodium.Net",
    "summary": "Class SecureMemory Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for secure memory management using libsodium. These methods help protect sensitive data from being swapped to disk or accessed by other processes. public static class SecureMemory Inheritance object SecureMemory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Create<T>(int) Creates a SecureMemory<T> holding the specified number of items of given type public static SecureMemory<T> Create<T>(int length) where T : unmanaged Parameters length int The number of items Returns SecureMemory<T> Type Parameters T The type of items Equals(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers for equality in constant time. public static bool Equals(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> First buffer to compare. b2 ReadOnlySpan<byte> Second buffer to compare. Returns bool True if the buffers are equal, false otherwise. IsZero(ReadOnlySpan<byte>) Checks if the given byte buffer is zero. public static bool IsZero(ReadOnlySpan<byte> b) Parameters b ReadOnlySpan<byte> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. MemLock(ReadOnlySpan<byte>) Locks an unmanaged memory buffer, preventing it from being swapped to disk. public static void MemLock(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The span representing the unmanaged memory to lock. Exceptions LibSodiumException Thrown if locking the memory fails. MemLock<T>(ReadOnlySpan<T>) Locks an unmanaged memory buffer, preventing it from being swapped to disk. public static void MemLock<T>(ReadOnlySpan<T> buffer) where T : unmanaged Parameters buffer ReadOnlySpan<T> The span representing the unmanaged memory to lock. Type Parameters T Exceptions LibSodiumException Thrown if locking the memory fails. MemUnlock(ReadOnlySpan<byte>) Unlocks an unmanaged memory buffer, allowing it to be swapped to disk if necessary. public static void MemUnlock(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The span of bytes to unlock. Exceptions LibSodiumException Thrown if unlocking the memory fails. MemUnlock<T>(ReadOnlySpan<T>) Unlocks an unmanaged memory buffer, allowing it to be swapped to disk if necessary. public static void MemUnlock<T>(ReadOnlySpan<T> buffer) where T : unmanaged Parameters buffer ReadOnlySpan<T> The span of bytes to unlock. Type Parameters T Exceptions LibSodiumException Thrown if unlocking the memory fails. MemZero(byte[]) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero(byte[] buffer) Parameters buffer byte[] The span of bytes to zero out. MemZero(Span<byte>) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero(Span<byte> buffer) Parameters buffer Span<byte> The span of bytes to zero out. MemZero<T>(Span<T>) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero<T>(Span<T> buffer) where T : unmanaged Parameters buffer Span<T> The span of bytes to zero out. Type Parameters T MemZero<T>(T[]) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero<T>(T[] buffer) where T : unmanaged Parameters buffer T[] The span of bytes to zero out. Type Parameters T"
  },
  "api/LibSodium.SecurePadding.html": {
    "href": "api/LibSodium.SecurePadding.html",
    "title": "Class SecurePadding | LibSodium.Net",
    "summary": "Class SecurePadding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for padding and unpadding byte buffers to ensure they meet specified block sizes. public static class SecurePadding Inheritance object SecurePadding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pad(Span<byte>, int, int) Pads the given buffer to the specified block size. public static Span<byte> Pad(Span<byte> buffer, int unpaddedLen, int blockSize) Parameters buffer Span<byte> The buffer to pad. unpaddedLen int The length of the data before padding. blockSize int The block size to pad to. Returns Span<byte> A span of the padded buffer. Exceptions ArgumentException Thrown when blockSize is less than or equal to 0 or unpaddedLen is greater than buffer length. Unpad(Span<byte>, int) Unpads the given buffer that was padded to a specified block size. public static Span<byte> Unpad(Span<byte> buffer, int blockSize) Parameters buffer Span<byte> The buffer to unpad. blockSize int The block size that was used for padding. Returns Span<byte> A span of the unpadded buffer. Exceptions ArgumentException Thrown when blockSize is less than or equal to 0. LibSodiumException Thrown when unpadding fails."
  },
  "api/LibSodium.UnmanagedMemorySpanHolder-1.html": {
    "href": "api/LibSodium.UnmanagedMemorySpanHolder-1.html",
    "title": "Class UnmanagedMemorySpanHolder<T> | LibSodium.Net",
    "summary": "Class UnmanagedMemorySpanHolder<T> Namespace LibSodium Assembly LibSodium.Net.dll Holds the pointer and length of an unmanaged memory span for later recreation. Use only with unmanaged memory. public class UnmanagedMemorySpanHolder<T> where T : unmanaged Type Parameters T The unmanaged type of the span elements. Inheritance object UnmanagedMemorySpanHolder<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class stores the pointer and length of an unmanaged memory span, allowing for its later reconstruction. It is critical to use this class only with spans pointing to unmanaged memory. Using it with managed or stack-allocated spans will result in undefined behavior and potential memory corruption. This holder is particularly useful when a span needs to be accessed in asynchronous operations, lambda expressions, anonymous methods or other contexts with limited scope, such as after awaiting a task. Constructors UnmanagedMemorySpanHolder(ReadOnlySpan<T>) Initializes a new instance of the UnmanagedMemorySpanHolder<T> class from a read-only span. Use only with unmanaged memory. public UnmanagedMemorySpanHolder(ReadOnlySpan<T> span) Parameters span ReadOnlySpan<T> The read-only span pointing to unmanaged memory. Exceptions ArgumentException Thrown when the span is empty. UnmanagedMemorySpanHolder(Span<T>) Initializes a new instance of the UnmanagedMemorySpanHolder<T> class from a writable span. Use only with unmanaged memory. public UnmanagedMemorySpanHolder(Span<T> span) Parameters span Span<T> The read-only span pointing to unmanaged memory. Exceptions ArgumentException Thrown when the span is empty. Methods GetOriginalReadOnlySpan() Creates a new ReadOnlySpan<T> from the held unmanaged memory representing the original ReadOnlySpan<T>. public ReadOnlySpan<T> GetOriginalReadOnlySpan() Returns ReadOnlySpan<T> A ReadOnlySpan<T> representing the original ReadOnlySpan<T> GetOriginalSpan() Creates a new Span<T> from the held unmanaged memory representing the original Span<T> public Span<T> GetOriginalSpan() Returns Span<T> A Span<T> representing the original Span<T> Exceptions InvalidOperationException The original span was read-only, you cannot get a writable span."
  },
  "api/LibSodium.html": {
    "href": "api/LibSodium.html",
    "title": "Namespace LibSodium | LibSodium.Net",
    "summary": "Namespace LibSodium Classes Base64Encoding Provides methods for Base64 encoding and decoding. CryptoSecretStream The CryptoSecretStream class provides methods for performing authenticated encryption and decryption of data streams, with optional additional authenticated data. It is based on the XChaCha20-Poly1305 algorithm. HexEncoding Provides methods for encoding and decoding hexadecimal strings and byte buffers. LibSodiumException Represents errors that occur during Sodium operations. LibraryInitializer Static class that manages the initialization and configuration of libsodium. LibraryVersion Provides methods to retrieve the version information of the Sodium library. RandomGenerator Static class for random number generation. SecretBox Provides static methods for authenticated symmetric encryption and decryption using the Sodium secretbox primitives, specifically the XSalsa20 stream cipher and Poly1305 MAC for authentication. These methods offer combined encryption/authentication and detached encryption/authentication, with variations for handling nonces and Message Authentication Codes (MACs) within or separate from the ciphertext. SecretStream Provides high-level, stream-based authenticated encryption and decryption using the XChaCha20-Poly1305 algorithm. This class abstracts the complexity of securely processing large data streams, including chunking, authentication, and cryptographic state management. SecureBigUnsignedInteger Provides methods for working with arbitrary large little endian big unsigned integers in a secure way (constant time for a given length) SecureMemory Provides methods for secure memory management using libsodium. These methods help protect sensitive data from being swapped to disk or accessed by other processes. SecureMemory<T> Provides a secure unmanaged memory buffer for unmanaged types, using libsodium for memory protection. This class encapsulates secure memory allocation, read-only protection, and zeroing. SecurePadding Provides methods for padding and unpadding byte buffers to ensure they meet specified block sizes. UnmanagedMemorySpanHolder<T> Holds the pointer and length of an unmanaged memory span for later recreation. Use only with unmanaged memory. Enums Base64Variant Represents Base64 encoding variants. CryptoSecretStreamTag The tags used in the secret stream."
  },
  "features.html": {
    "href": "features.html",
    "title": "Features | LibSodium.Net",
    "summary": "Features LibSodium.Bindings.Net is designed to eventually support all of libsodium’s features while offering a modern and efficient approach to cryptographic operations Modern and Efficient Utilizes Span<T> instead of arrays for enhanced performance. Supports Ahead-of-Time (AOT) compilation by leveraging LibraryImport rather than DllImport. Implemented Features Helpers Constant-time equality testing Hexadecimal encoding and decoding. Base64 encoding and decoding Operations for arbitrary-length unsigned numbers. Testing for all-zero values. Pading Pad and unpad data using the ISO/IEC 7816-4 padding algorithm Secure Memory Zeroing memory Locking memory Guarded heap allocations. Generating random data Random UInt32 , including uniform with upper bound. Random buffer generation, including deterministic option. Closing and stirring the random generator Secret-Key Cryptography Authenticated encryption (SecretBox) Encrypted streams and file encryption Additional Features Coming soon"
  },
  "guide.html": {
    "href": "guide.html",
    "title": "\uD83D\uDD10 Introduction to LibSodium.Net | LibSodium.Net",
    "summary": "\uD83D\uDD10 Introduction to LibSodium.Net LibSodium.Net provides .NET developers with easy-to-use bindings for libsodium, a powerful, modern cryptography library widely recognized for its simplicity and security. This makes it straightforward to add robust cryptographic functionality to your .NET applications. ✨ Why LibSodium.Net? Cross-platform: Seamless support across Windows, Linux, and macOS. Modern Cryptography: Includes authenticated encryption, public-key cryptography, hashing, key derivation, and digital signatures. Simple and Secure API: Designed to reduce complexity, helping you implement cryptography correctly and securely. Secure Memory Handling: Sensitive data management to minimize risks like memory leaks or data exposure. Span over Arrays : Optimized for performance and memory efficiency by using Span<T> instead of heap-allocated arrays. AOT Compatible: Uses LibraryImport (source-generated P/Invoke) instead of DllImport, making it fully compatible with AOT compilation environments. \uD83D\uDE80 Getting Started with LibSodium.Net Here's how you can quickly integrate LibSodium.Net into your .NET projects. \uD83D\uDCE6 Install via NuGet You can easily install LibSodium.Net using the NuGet package manager: CLI Using the .NET CLI: dotnet add package LibSodium.Net Visual Studio Right-click your project in Solution Explorer. Choose Manage NuGet Packages. Search for LibSodium.Net and click Install. Package Manager Console Install-Package LibSodium.Net \uD83E\uDDF1 SecretBox The SecretBox API in LibSodium.Net provides a simple and secure way to perform symmetric authenticated encryption using the XSalsa20 stream cipher and Poly1305 MAC. It supports both combined and detached encryption modes. \uD83D\uDD10 SecretBox Features Symmetric authenticated encryption using XSalsa20-Poly1305 Support for combined and detached modes Automatic or manual nonce handling Tamper-proof via MAC verification \uD83D\uDD12 Encrypting and Decrypting Messages ✅ Combined Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Hello, secure world!\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen]; // Encrypt var result = SecretBox.EncryptCombined(ciphertext, plaintext, key, nonce); // Decrypt Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, result, key, nonce); Console.WriteLine(Encoding.UTF8.GetString(recovered)); ✅ Combined Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce mode test\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen + SecretBox.NonceLen]; var encrypted = SecretBox.EncryptCombined(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, encrypted, key); Console.WriteLine(Encoding.UTF8.GetString(recovered)); \uD83E\uDDE9 Detached Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached mode message\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key, nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac, nonce); Console.WriteLine(Encoding.UTF8.GetString(output)); \uD83E\uDDE9 Detached Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce detached mode\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.NonceLen]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac); Console.WriteLine(Encoding.UTF8.GetString(output)); ⚠️ Error Handling SecretBox methods throw: ArgumentException — if inputs are the wrong size. LibSodiumException — if decryption fails due to tampering or incorrect keys. \uD83D\uDCCC Notes Always use a new random nonce for each encryption. Decryption verifies the MAC before returning plaintext. Use RandomGenerator.Fill() to securely fill nonces and keys. SecretStream The SecretStream class in LibSodium.Net provides secure, authenticated stream-based encryption and decryption using the XChaCha20-Poly1305 algorithm. It's designed to handle large streams of data efficiently and securely. Key Features Authenticated encryption ensures data integrity. Automatic chunking and handling of large data streams. Secure random key generation. Protection against nonce reuse. Basic Usage 1. Generating a Secret Key A secret key must be securely generated and managed: byte[] key = new byte[CryptoSecretStream.KeyLen]; CryptoSecretStream.GenerateKey(key); 2. Encrypting Data Encrypting data streams: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); await SecretStream.EncryptAsync(inputFile, encryptedFile, key); Synchronous Encryption: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); SecretStream.Encrypt(inputFile, encryptedFile, key); 3. Decrypting Data Decrypting the encrypted data back to plaintext: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); await SecretStream.DecryptAsync(encryptedFile, decryptedFile, key); Synchronous Decryption: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); SecretStream.Decrypt(encryptedFile, decryptedFile, key); Security Considerations Secure Key Management: Protect your keys; losing them or exposing them compromises security. Nonce Management: Handled internally by SecretStream; avoid manual nonce reuse. Integrity Checks: Automatic using Poly1305 tags; any tampering results in exceptions. Error Handling Encryption and decryption throw specific exceptions for error conditions: ArgumentException: Invalid arguments (wrong key length, null streams). LibSodiumException: Authentication failed, typically from tampered data. Performance Considerations SecretStream processes data in chunks (default: 64KB) for optimal balance between memory usage and performance. Utilize asynchronous methods (EncryptAsync/DecryptAsync) for IO-bound scenarios for better scalability. \uD83D\uDEE1️ SecureMemory When working with cryptographic data, it's essential to ensure that sensitive information doesn't get leaked through memory dumps, swapping, or garbage collection. LibSodium.Net provides SecureMemory and SecureMemory<T> as robust tools to manage sensitive data safely in unmanaged memory. These APIs leverage libsodium's sodium_malloc, sodium_mlock, and related memory protection functions to offer secure, optionally read-only memory regions that are wiped on disposal. \uD83E\uDDE9 SecureMemory<T> SecureMemory<T> is a managed wrapper around unmanaged memory that stores a span of unmanaged type T. It ensures: Memory is allocated using sodium_allocarray. Memory is wiped with sodium_memzero on disposal. Optional read-only protection using ProtectReadOnly(). Optional read-write toggle with ProtectReadWrite(). Safe access through Span<T>, Memory<T>, ReadOnlySpan<T>, and ReadOnlyMemory<T>. ✅ Basic Usage using var secure = SecureMemory.Create<byte>(32); // Allocate secure memory var span = secure.AsSpan(); // Write access RandomGenerator.Fill(span); // Fill with sensitive data secure.ProtectReadOnly(); // Make it read-only var readOnly = secure.AsReadOnlySpan(); // Safe read-only view secure.ProtectReadWrite(); // Allow writing again \uD83D\uDD12 Safety Features Accessing a SecureMemory<T> object after disposal throws ObjectDisposedException. Accessing writable span when read-only throws InvalidOperationException. Any span or memory obtained prior to disposal becomes invalid. Using it after the object is disposed may result in AccessViolationException. Writing through a span obtained before marking the memory as read-only will throw an AccessViolationException. Memory is finalized and securely freed if not explicitly disposed. \uD83D\uDD27 SecureMemory Utilities SecureMemory also provides utility methods for working with unmanaged memory spans directly: \uD83D\uDD10 Allocate Secure Buffers var span = SecureMemory.Allocate<byte>(64); // Use span... SecureMemory.Free(span); // Free when done All allocations are initialized with 0xDB for predictable testing. \uD83D\uDD10 Zeroing Buffers byte[] buffer = { 1, 2, 3 }; SecureMemory.MemZero(buffer); // Zeros array securely \uD83D\uDD10 Lock/Unlock Memory var span = SecureMemory.Allocate<byte>(128); SecureMemory.MemLock(span); // Prevents swapping to disk SecureMemory.MemUnlock(span); SecureMemory.Free(span); \uD83D\uDD10 Read-Only & Read-Write Protections var span = SecureMemory.Allocate<long>(4); var readOnlySpan = SecureMemory.ProtectReadOnly(span); var writableSpan = SecureMemory.ProtectReadWrite(readOnlySpan); ⚠️ Security Considerations Do not pass managed memory (e.g., new byte[1024]) to Free(). Doing so can corrupt memory. Secure memory functions work only with unmanaged memory allocated by SecureMemory.Allocate(). Avoid using spans or memory references after the backing SecureMemory<T> has been disposed; doing so can cause undefined behavior or AccessViolationException. Writing to memory through a previously obtained span after calling ProtectReadOnly() will throw an AccessViolationException. Always dispose SecureMemory<T> when done, or use using to ensure cleanup. ✅ Unit-Tested Reliability The implementation is backed by comprehensive tests ensuring: Memory is initialized to 0xDB for testing predictability Read-only enforcement and write protection Exception safety on misuse Proper finalization and disposal semantics SecureMemory APIs are essential for handling secrets like keys, passwords, or tokens securely. They give you granular control over how and when memory is allocated, accessed, and cleared—adding another layer of defense in your cryptographic applications."
  },
  "guide/Encoding.html": {
    "href": "guide/Encoding.html",
    "title": "✏️ Encoding | LibSodium.Net",
    "summary": "✏️ Encoding LibSodium.Net provides high-performance, secure encoding utilities to convert binary data to and from human-readable formats. The library currently supports two types of encoding: Hexadecimal via HexEncoding Base64 via Base64Encoding These classes are wrappers around libsodium's encoding utilities, providing constant-time and safe operations using spans. \uD83E\uDDC2 Based on libsodium’s Hexadecimal encoding/decoding and Base64 encoding/decoding ℹ️ See also: API Reference for HexEncoding, API Reference for Base64Encoding \uD83D\uDD10 Security Considerations These encoding functions are implemented in constant time with respect to input size, which means they avoid data-dependent branching and timing variations. This makes them resistant to side-channel attacks, such as timing attacks, which can leak information through observable differences in computation time. LibSodium.Net ensures that these security properties are preserved in its managed API by: Using Span<T> and avoiding intermediate heap allocations. Delegating directly to libsodium’s hardened, constant-time implementations. These properties make HexEncoding and Base64Encoding suitable for encoding sensitive data like cryptographic keys, hashes, tokens, and other secrets. ✨ HexEncoding HexEncoding provides methods to encode a byte array into a lowercase hexadecimal string and decode from hexadecimal back into binary. All operations are span-based for performance and safety. \uD83D\uDCBB Encode to hex Span<byte> bin = stackalloc byte[] { 0x01, 0x23, 0x45 }; string hex = HexEncoding.BinToHex(bin); // \"012345\" You can also write the hex into a preallocated Span<char>: Span<char> hexBuffer = stackalloc char[bin.Length * 2]; HexEncoding.BinToHex(bin, hexBuffer); \uD83D\uDCBB Decode from hex string hex = \"0123456789abcdef\"; Span<byte> buffer = stackalloc byte[hex.Length / 2]; HexEncoding.HexToBin(hex, buffer); You can also ignore separators such as colons: string formatted = \"01:23:45:67\"; HexEncoding.HexToBin(formatted, buffer, \":\"); ⚠️ Exceptions ArgumentException: when hex buffer is too small. LibSodiumException: on malformed hex input or destination buffer too small. ✨ Base64Encoding Base64Encoding supports multiple Base64 variants, including URL-safe and no-padding modes. \uD83D\uDCD8 Base64 variants public enum Base64Variant { Original, OriginalNoPadding, UrlSafe, UrlSafeNoPadding } These map directly to sodium_base64_VARIANT_* in libsodium. \uD83D\uDCBB Encode to Base64 Span<byte> bin = stackalloc byte[] { 1, 2, 3, 4 }; string b64 = Base64Encoding.BinToBase64(bin, Base64Variant.Original); You can also write the result into a Span<char>: Span<char> buffer = stackalloc char[Base64Encoding.GetBase64EncodedLen(bin.Length, Base64Variant.Original)]; Base64Encoding.BinToBase64(bin, buffer, Base64Variant.Original); \uD83D\uDCBB Decode from Base64 string b64 = \"AQIDBA==\"; Span<byte> output = stackalloc byte[Base64Encoding.GetBase64DecodedMaxLen(b64.Length)]; Base64Encoding.Base64ToBin(b64, output, Base64Variant.Original); Optional ignored characters (e.g., formatting spaces): Base64Encoding.Base64ToBin(\" AQ ID BA == \", output, Base64Variant.Original, \" \"); ⚠️ Exceptions ArgumentException: buffer too small. LibSodiumException: invalid Base64 input or mismatched variant. These encoding utilities are highly optimized, secure, and suitable for cryptographic applications where constant-time guarantees and low-level memory control are essential."
  },
  "guide/RandomGenerator.html": {
    "href": "guide/RandomGenerator.html",
    "title": "\uD83C\uDFB2 RandomGenerator | LibSodium.Net",
    "summary": "\uD83C\uDFB2 RandomGenerator The RandomGenerator class in LibSodium.Net provides access to cryptographically secure random values. It wraps several functions from libsodium's randombytes API and ensures correct initialization and exception safety. \uD83E\uDDC2Based on libsodium's Generating random data ℹ️ See also: API Reference for RandomGenerator ✨ Features Generate random 32-bit unsigned integers. Generate bounded random integers. Fill buffers with secure random bytes. Generate deterministic random bytes using a seed. Stir or close the RNG engine as needed. \uD83D\uDCE6 Getting Random Values \uD83D\uDCBB Get a random 32-bit unsigned integer uint value = RandomGenerator.GetUInt32(); Returns a cryptographically secure, uniformly distributed value. \uD83D\uDCBB Get a random value less than an upper bound uint lessThan100 = RandomGenerator.GetUInt32(100); Returns a value in the range [0, upperBound). Uses a rejection sampling method to ensure uniform distribution. \uD83D\uDCE6 Filling Buffers \uD83D\uDCBB Fill a buffer with random bytes Span<byte> buffer = stackalloc byte[32]; RandomGenerator.Fill(buffer); This fills the buffer with unpredictable cryptographic random bytes. \uD83D\uDCBB Fill a buffer with deterministic random bytes Span<byte> seed = stackalloc byte[RandomGenerator.SeedLen]; RandomGenerator.Fill(seed); // Generate a secure seed Span<byte> buffer = stackalloc byte[32]; RandomGenerator.FillDeterministic(buffer, seed); The same seed and length will always produce the same output. ⚠️ Seed must be exactly RandomGenerator.SeedLen bytes long. Otherwise, ArgumentException is thrown. \uD83D\uDCE6 Stirring and Closing the RNG \uD83D\uDCBB Stir the RNG RandomGenerator.Stir(); This reseeds the RNG, recommended after forking a process or when explicitly needed. \uD83D\uDCBB Close the RNG RandomGenerator.Close(); Closes the randombytes subsystem. This may be needed in long-running processes or to release resources. Calling it more than once will throw LibSodiumException. ⚠️ Error Handling ArgumentException — thrown when FillDeterministic receives an invalid seed length. LibSodiumException — thrown when Close() fails (e.g., called twice). The RandomGenerator API is well-suited for cryptographic use cases and follows safe defaults. It gives you access to high-quality random data and control over deterministic randomness when reproducibility is required."
  },
  "guide/SecretBox.html": {
    "href": "guide/SecretBox.html",
    "title": "\uD83D\uDD12 SecretBox | LibSodium.Net",
    "summary": "\uD83D\uDD12 SecretBox The SecretBox API in LibSodium.Net provides a simple and secure way to perform symmetric authenticated encryption using the XSalsa20 stream cipher and Poly1305 MAC. It supports both combined and detached encryption modes, as well as manual or automatic nonce handling. \uD83E\uDDC2Based on libsodium's Authenticated encryption using crypto_secretbox ℹ️ See also: API Reference for SecretBox ✨ Features Symmetric authenticated encryption using XSalsa20-Poly1305. Combined mode and detached mode support. Automatic or manual nonce handling. Built-in MAC verification (tamper detection). Safe and efficient API using Span<T>. \uD83D\uDD0D Understanding Combined vs Detached Modes The SecretBox API offers two encryption modes: Combined Mode: the MAC (Message Authentication Code) is prepended to the ciphertext. The output is a single buffer that contains both the encrypted message and the MAC. Useful when you want to store or transmit ciphertext as one self-contained block. Detached Mode: the MAC is stored separately from the ciphertext. You get two outputs: one for the encrypted message, and one for the MAC. Useful when your protocol has a separate field for authentication tags. Nonce handling options: Manual Nonce: you provide a secure random nonce. Gives you full control but requires ensuring nonces are never reused with the same key. Automatic Nonce: the library generates a secure nonce and prepends it to the output. ⚠️ Reusing a nonce with the same key breaks security. Always use a fresh random nonce. \uD83D\uDCE6 Encrypting and Decrypting Messages \uD83D\uDCBB Combined Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Hello, secure world!\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen]; // Encrypt var result = SecretBox.EncryptCombined(ciphertext, plaintext, key, nonce); // Decrypt Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, result, key, nonce); Console.WriteLine(Encoding.UTF8.GetString(recovered)); \uD83D\uDCBB Combined Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce mode test\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen + SecretBox.NonceLen]; var encrypted = SecretBox.EncryptCombined(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, encrypted, key); Console.WriteLine(Encoding.UTF8.GetString(recovered)); \uD83D\uDCBB Detached Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached mode message\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key, nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac, nonce); Console.WriteLine(Encoding.UTF8.GetString(output)); \uD83D\uDCBB Detached Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce detached mode\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.NonceLen]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac); Console.WriteLine(Encoding.UTF8.GetString(output)); ⚠️ Error Handling ArgumentException — invalid input sizes. LibSodiumException — authentication failed. \uD83D\uDCDD Notes Always use a new random nonce for each encryption if you're not using auto-nonce. Combined mode includes both MAC and ciphertext in a single buffer. Detached mode outputs MAC separately — useful for protocols with separate fields. Nonce must be exactly SecretBox.NonceLen bytes. Use RandomGenerator.Fill() for secure key and nonce generation."
  },
  "guide/SecretStream.html": {
    "href": "guide/SecretStream.html",
    "title": "\uD83D\uDD12 SecretStream | LibSodium.Net",
    "summary": "\uD83D\uDD12 SecretStream The SecretStream class in LibSodium.Net provides secure, authenticated stream-based encryption and decryption using the XChaCha20-Poly1305 algorithm. It's designed to handle large streams of data efficiently and securely. \uD83E\uDDC2 Based on libsodium's Encrypted streams and file encryption ℹ️ See also: API Reference for SecretStream ✨ Key Features Authenticated encryption ensures data integrity. Automatic chunking and handling of large data streams. Secure random key generation. Protection against nonce reuse. \uD83D\uDCE6 Basic Usage \uD83D\uDCBB Generating a Secret Key A secret key must be securely generated and managed: byte[] key = new byte[CryptoSecretStream.KeyLen]; CryptoSecretStream.GenerateKey(key); \uD83D\uDCBB Encrypting Data Encrypting data streams asynchronously: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); await SecretStream.EncryptAsync(inputFile, encryptedFile, key); Synchronous Encryption: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); SecretStream.Encrypt(inputFile, encryptedFile, key); \uD83D\uDCBB Decrypting Data Decrypting asynchronously the encrypted data back to plaintext: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); await SecretStream.DecryptAsync(encryptedFile, decryptedFile, key); Synchronous Decryption: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); SecretStream.Decrypt(encryptedFile, decryptedFile, key); ⚠️ Security Considerations Secure Key Management: Protect your keys; losing them or exposing them compromises security. Nonce Management: Handled internally by SecretStream; avoid manual nonce reuse. Integrity Checks: Automatic using Poly1305 tags; any tampering results in exceptions. ⚠️ Error Handling Encryption and decryption throw specific exceptions for error conditions: ArgumentException: Invalid arguments (wrong key length, null streams). LibSodiumException: Authentication failed, typically from tampered data. \uD83D\uDD52 Performance Considerations SecretStream processes data in chunks (default: 64KB) for optimal balance between memory usage and performance. Utilize asynchronous methods (EncryptAsync/DecryptAsync) for IO-bound scenarios for better scalability."
  },
  "guide/SecureBigUnsignedInteger.html": {
    "href": "guide/SecureBigUnsignedInteger.html",
    "title": "\uD83D\uDD22 SecureBigUnsignedInteger | LibSodium.Net",
    "summary": "\uD83D\uDD22 SecureBigUnsignedInteger The SecureBigUnsignedInteger class provides constant-time operations for working with large, little-endian, unsigned integers represented as Span<byte>. It wraps several low-level functions from libsodium that are specifically designed to be safe against side-channel attacks. \uD83E\uDDC2 Based on libsodium’s Integer manipulation helpers ℹ️ See also: API Reference for SecureBigUnsignedInteger \uD83D\uDD10 Security Considerations All operations in this class are evaluated in constant time with respect to buffer size, which helps prevent timing-based side-channel attacks. These methods are suitable for cryptographic contexts where comparisons, additions, or manipulations of secrets must not leak information through execution timing. ✨ Features Constant-time comparison, equality, addition, and subtraction. Increment by 1 or arbitrary 64-bit value. Zero-checking. Supports arbitrary-sized numbers (as long as both operands have the same length). Uses spans to avoid heap allocations. \uD83D\uDCE6 Usage Examples \uD83D\uDCBB Constant-Time Equality Check Span<byte> a = stackalloc byte[] { 1, 2, 3 }; Span<byte> b = stackalloc byte[] { 1, 2, 3 }; bool areEqual = SecureBigUnsignedInteger.Equals(a, b); // true \uD83D\uDCBB Constant-Time Compare int cmp = SecureBigUnsignedInteger.Compare(a, b); // 0 if equal, <0 if a < b, >0 if a > b \uD83D\uDCBB Increment Span<byte> number = stackalloc byte[4]; SecureBigUnsignedInteger.Increment(number); // adds 1 SecureBigUnsignedInteger.Increment(number, 42); // adds 42 \uD83D\uDCBB Addition and Subtraction Span<byte> a = stackalloc byte[] { 5, 0, 0 }; ReadOnlySpan<byte> b = stackalloc byte[] { 3, 0, 0 }; SecureBigUnsignedInteger.Add(a, b); // a = a + b SecureBigUnsignedInteger.Subtract(a, b); // a = a - b ⚠️ Both operands must have the same length. Otherwise, ArgumentException is thrown. \uD83D\uDCBB Zero Check Span<byte> n = stackalloc byte[] { 0, 0, 0 }; bool isZero = SecureBigUnsignedInteger.IsZero(n); // true This API is ideal for low-level cryptographic arithmetic where performance, determinism, and side-channel resistance are essential."
  },
  "guide/SecureMemory.html": {
    "href": "guide/SecureMemory.html",
    "title": "\uD83D\uDEE1️ SecureMemory | LibSodium.Net",
    "summary": "\uD83D\uDEE1️ SecureMemory When working with cryptographic data, it's essential to ensure that sensitive information doesn't get leaked through memory dumps, swapping, or garbage collection. LibSodium.Net provides SecureMemory and SecureMemory<T> as robust tools to manage sensitive data safely in unmanaged memory. \uD83E\uDDC2 Backed by libsodium's Secure memory. ℹ️ See also: API Reference for SecureMemory<T> These APIs leverage libsodium’s sodium_malloc, sodium_mlock, and related memory protection functions to offer secure, optionally read-only memory regions that are wiped on disposal. ✨ SecureMemory<T> SecureMemory<T> is a managed wrapper around unmanaged memory that stores a buffer of unmanaged type T items. It ensures: Memory is allocated using sodium_allocarray. Memory is wiped with sodium_free on disposal. Optional read-only protection using ProtectReadOnly(). Optional read-write toggle with ProtectReadWrite(). Safe access through Span<T>, Memory<T>, ReadOnlySpan<T>, and ReadOnlyMemory<T>. \uD83D\uDCBB Basic Usage using var secure = SecureMemory.Create<byte>(32); // Allocate secure memory var span = secure.AsSpan(); // Write access RandomGenerator.Fill(span); // Fill with sensitive data secure.ProtectReadOnly(); // Make it read-only var readOnly = secure.AsReadOnlySpan(); // Safe read-only view ✨ Safety Features Accessing the SecureMemory<T> object after disposal throws ObjectDisposedException. Writing to memory after calling ProtectReadOnly() throws an AccessViolationException. Writing through a Span<T> previously obtained before calling ProtectReadOnly() also throws AccessViolationException. Memory is automatically zeroed out upon disposal using sodium_memzero. \uD83D\uDCE6 SecureMemory<T> Utilities \uD83D\uDCBB Allocate Secure Buffers using var buffer = SecureMemory.Create<byte>(64); \uD83D\uDCBB Zeroing Buffers buffer.MemZero(); // Overwrites memory with zeroes \uD83D\uDCBB Protect Memory buffer.ProtectReadOnly(); buffer.ProtectReadWrite(); \uD83D\uDCBB Read-Only & Read-Write Access Use .AsSpan() to get mutable access. Use .AsReadOnlySpan() to get immutable view. ⚠️ Security Considerations Unmanaged memory isn't GC-tracked — make sure to dispose properly. AccessViolationException is a sign that read/write protections are working as intended. Avoid exposing memory unnecessarily — always limit visibility."
  },
  "guide/index.html": {
    "href": "guide/index.html",
    "title": "\uD83D\uDD10 Introduction to LibSodium.Net | LibSodium.Net",
    "summary": "\uD83D\uDD10 Introduction to LibSodium.Net LibSodium.Net provides .NET developers with easy-to-use bindings for libsodium, a powerful, modern cryptography library widely recognized for its simplicity and security. This makes it straightforward to add robust cryptographic functionality to your .NET applications. ✨ Why LibSodium.Net? Cross-platform: Seamless support across Windows, Linux, and macOS. Modern Cryptography: Includes authenticated encryption, public-key cryptography, hashing, key derivation, and digital signatures. Simple and Secure API: Designed to reduce complexity, helping you implement cryptography correctly and securely. Secure Memory Handling: Sensitive data management to minimize risks like memory leaks or data exposure. Span over Arrays : Optimized for performance and memory efficiency by using Span<T> instead of heap-allocated arrays. AOT Compatible: Uses LibraryImport (source-generated P/Invoke) instead of DllImport, making it fully compatible with AOT compilation environments. \uD83D\uDE80 Getting Started with LibSodium.Net Here's how you can quickly integrate LibSodium.Net into your .NET projects. \uD83D\uDCE6 Install via NuGet You can easily install LibSodium.Net using the NuGet package manager: CLI dotnet add package LibSodium.Net Visual Studio Right-click your project in Solution Explorer. Choose Manage NuGet Packages. Search for LibSodium.Net and click Install. Package Manager Console Install-Package LibSodium.Net"
  },
  "index.html": {
    "href": "index.html",
    "title": "LibSodium.Net | LibSodium.Net",
    "summary": "LibSodium.Net Modern Cryptography for .NET Welcome to LibSodium.Net, the secure and developer-friendly .NET bindings for libsodium — a battle-tested, modern cryptographic library used around the world. Whether you're building web services, desktop apps, IoT devices, or cross-platform tools, LibSodium.Net helps you add robust, efficient, and secure cryptographic functionality with confidence. ✨ Simple, Powerful, and Secure Built on the trusted libsodium C library. Designed for modern .NET: efficient memory handling via Span<T>, support for AOT via LibraryImport. Safe-by-default APIs that help you do cryptography right. Includes secure memory utilities, symmetric and asymmetric encryption, hashing, key derivation, and more. \uD83C\uDF0A First-Class Streaming Encryption LibSodium.Net provides idiomatic support for large file and streaming authenticated encryption using libsodium’s XChaCha20-Poly1305. Powered by the SecretStream API, you can securely encrypt and decrypt files of any size with tamper-detection and zero nonce reuse risk — all in a few lines of code. \uD83D\uDE80 Get Started Install the NuGet package: dotnet add package LibSodium.Net Then head over to our Guide to learn how to: Encrypt and decrypt data securely Generate cryptographic keys Work with secure memory Handle errors properly and safely \uD83D\uDCC4 Reference Documentation Need details on specific APIs? Browse the full Reference Documentation to explore everything from SecretBox and SecureMemory<T> to stream encryption and key generation helpers."
  }
}