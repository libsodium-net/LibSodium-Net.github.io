{
  "api/LibSodium.Aegis128L.html": {
    "href": "api/LibSodium.Aegis128L.html",
    "title": "Class Aegis128L | LibSodium.Net",
    "summary": "Class Aegis128L Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the AEGIS-128L AEAD construction from Libsodium. public static class Aegis128L Inheritance object Aegis128L Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (32). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (16). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AEGIS-128L. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (16 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AEGIS-128L. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (16 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.Aegis256.html": {
    "href": "api/LibSodium.Aegis256.html",
    "title": "Class Aegis256 | LibSodium.Net",
    "summary": "Class Aegis256 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the AEGIS-256 AEAD construction from Libsodium. public static class Aegis256 Inheritance object Aegis256 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (32). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (32). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AEGIS-256. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (32 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AEGIS-256. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (32 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (32 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.Aes256Gcm.html": {
    "href": "api/LibSodium.Aes256Gcm.html",
    "title": "Class Aes256Gcm | LibSodium.Net",
    "summary": "Class Aes256Gcm Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the AES256-GCM AEAD construction from Libsodium. public static class Aes256Gcm Inheritance object Aes256Gcm Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (12). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using AES256-GCM. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using AES256-GCM. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.Base64Encoding.html": {
    "href": "api/LibSodium.Base64Encoding.html",
    "title": "Class Base64Encoding | LibSodium.Net",
    "summary": "Class Base64Encoding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for Base64 encoding and decoding. public static class Base64Encoding Inheritance object Base64Encoding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Base64ToBin(ReadOnlySpan<char>, Span<byte>, Base64Variant, string?) Decodes a Base64 string into a binary representation. public static Span<byte> Base64ToBin(ReadOnlySpan<char> b64, Span<byte> bin, Base64Variant variant, string? ignore = null) Parameters b64 ReadOnlySpan<char> The Base64 string to decode as a ReadOnlySpan. bin Span<byte> The span to store the decoded binary data. variant Base64Variant The Base64 variant to use. ignore string Characters to ignore during decoding. Returns Span<byte> A span containing the decoded binary data. Base64ToBin(string, Span<byte>, Base64Variant, string?) Decodes a Base64 string into a binary representation. public static Span<byte> Base64ToBin(string b64, Span<byte> bin, Base64Variant variant, string? ignore = null) Parameters b64 string The Base64 string to decode. bin Span<byte> The span to store the decoded binary data. variant Base64Variant The Base64 variant to use. ignore string Characters to ignore during decoding. Returns Span<byte> A span containing the decoded binary data. BinToBase64(ReadOnlySpan<byte>, Base64Variant) Encodes binary data into a Base64 string. public static string BinToBase64(ReadOnlySpan<byte> bin, Base64Variant variant) Parameters bin ReadOnlySpan<byte> The binary data to encode. variant Base64Variant The Base64 variant to use. Returns string A Base64 encoded string. BinToBase64(ReadOnlySpan<byte>, Span<char>, Base64Variant) Encodes binary data into a Base64 representation and stores it in a character span. public static Span<char> BinToBase64(ReadOnlySpan<byte> bin, Span<char> b64, Base64Variant variant) Parameters bin ReadOnlySpan<byte> The binary data to encode. b64 Span<char> The span to store the Base64 encoded data. variant Base64Variant The Base64 variant to use. Returns Span<char> A span containing the Base64 encoded data. GetBase64DecodedMaxLen(int) Calculates the maximum length of the decoded binary data from a Base64 string. public static int GetBase64DecodedMaxLen(int base64Len) Parameters base64Len int The length of the Base64 string. Returns int The maximum length of the decoded binary data. GetBase64EncodedLen(int, Base64Variant, bool) Calculates the length of the Base64 encoded string for a given binary length. public static int GetBase64EncodedLen(int binLen, Base64Variant variant, bool includeNullTerminator = true) Parameters binLen int The length of the binary data. variant Base64Variant The Base64 variant to use. includeNullTerminator bool Indicates whether to include a null terminator in the length calculation. Returns int The length of the Base64 encoded string."
  },
  "api/LibSodium.Base64Variant.html": {
    "href": "api/LibSodium.Base64Variant.html",
    "title": "Enum Base64Variant | LibSodium.Net",
    "summary": "Enum Base64Variant Namespace LibSodium Assembly LibSodium.Net.dll Represents Base64 encoding variants. public enum Base64Variant Fields Original = 1 Original Base64 encoding variant. OriginalNoPadding = 3 Original Base64 encoding variant with no padding. UrlSafe = 5 URL safe Base64 encoding variant. UrlSafeNoPadding = 7 URL safe Base64 encoding variant with no padding."
  },
  "api/LibSodium.ChaCha20Poly1305.html": {
    "href": "api/LibSodium.ChaCha20Poly1305.html",
    "title": "Class ChaCha20Poly1305 | LibSodium.Net",
    "summary": "Class ChaCha20Poly1305 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the ChaCha20-Poly1305 AEAD construction from Libsodium. public static class ChaCha20Poly1305 Inheritance object ChaCha20Poly1305 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (8). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (8 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (8 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.ChaCha20Poly1305Ietf.html": {
    "href": "api/LibSodium.ChaCha20Poly1305Ietf.html",
    "title": "Class ChaCha20Poly1305Ietf | LibSodium.Net",
    "summary": "Class ChaCha20Poly1305Ietf Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the IETF variant of the ChaCha20-Poly1305 AEAD construction from Libsodium. public static class ChaCha20Poly1305Ietf Inheritance object ChaCha20Poly1305Ietf Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (12). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using IETF variant of the ChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (12 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.CryptoAuth.html": {
    "href": "api/LibSodium.CryptoAuth.html",
    "title": "Class CryptoAuth | LibSodium.Net",
    "summary": "Class CryptoAuth Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for message authentication using the crypto_auth API from libsodium. public static class CryptoAuth Inheritance object CryptoAuth Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class wraps the crypto_auth functions from libsodium's secret-key authentication API, which uses the HMAC-SHA-512-256 algorithm to generate and verify message authentication codes (MACs). Fields KeyLen The length, in bytes, of a valid secret key for HMAC-SHA-512-256. public const int KeyLen = 32 Field Value int MacLen The length, in bytes, of the MAC produced by HMAC-SHA-512-256. public const int MacLen = 32 Field Value int Methods ComputeMac(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Computes a message authentication code (MAC) for the given input using HMAC-SHA-512-256. public static void ComputeMac(Span<byte> mac, ReadOnlySpan<byte> input, ReadOnlySpan<byte> key) Parameters mac Span<byte> A writable buffer with a length of MacLen bytes that will receive the computed MAC. input ReadOnlySpan<byte> The message data to authenticate. key ReadOnlySpan<byte> The secret key to use for authentication, must be KeyLen bytes long. Remarks This method is a wrapper around libsodium's crypto_auth function. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when the underlying libsodium operation fails unexpectedly. GenerateKey(Span<byte>) Generates a new random secret key for use with HMAC-SHA-512-256. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> A writable buffer with a length of KeyLen bytes that will be filled with the generated key. Remarks This function uses a cryptographically secure random number generator to produce a secret key. Internally calls crypto_auth_keygen from libsodium. Exceptions ArgumentException Thrown when the buffer length is not equal to KeyLen. TryVerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Attempts to verify that a given MAC is valid for the specified input and key using HMAC-SHA-512-256. public static bool TryVerifyMac(ReadOnlySpan<byte> mac, ReadOnlySpan<byte> input, ReadOnlySpan<byte> key) Parameters mac ReadOnlySpan<byte> The message authentication code to verify. Must be MacLen bytes long. input ReadOnlySpan<byte> The original message data that the MAC should authenticate. key ReadOnlySpan<byte> The secret key that was used to generate the MAC. Must be KeyLen bytes long. Returns bool true if the MAC is valid; otherwise, false. Remarks This method wraps the crypto_auth_verify function from libsodium. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when an unexpected error occurs during verification. VerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies that a given MAC is valid for the specified input and key using HMAC-SHA-512-256. public static void VerifyMac(ReadOnlySpan<byte> mac, ReadOnlySpan<byte> input, ReadOnlySpan<byte> key) Parameters mac ReadOnlySpan<byte> The message authentication code to verify. Must be MacLen bytes long. input ReadOnlySpan<byte> The original message data that the MAC should authenticate. key ReadOnlySpan<byte> The secret key that was used to generate the MAC. Must be KeyLen bytes long. Remarks Internally calls TryVerifyMac(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) and throws if the verification fails. Exceptions ArgumentException Thrown when the length of mac or key is invalid. LibSodiumException Thrown when the MAC verification fails or an unexpected error occurs."
  },
  "api/LibSodium.CryptoBox.html": {
    "href": "api/LibSodium.CryptoBox.html",
    "title": "Class CryptoBox | LibSodium.Net",
    "summary": "Class CryptoBox Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the Curve25519-based public-key authenticated encryption (crypto_box) from Libsodium. public static class CryptoBox Inheritance object CryptoBox Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes, auto nonce, as well as encryption using precomputed shared keys. Properties MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (24). public static int NonceLen { get; } Property Value int PrivateKeyLen Private key length in bytes (32). public static int PrivateKeyLen { get; } Property Value int PublicKeyLen Public key length in bytes (32). public static int PublicKeyLen { get; } Property Value int SealOverheadLen Length of the ciphertext overhead (48) when using EncryptWithPublicKey and DecryptWithPrivateKey. public static int SealOverheadLen { get; } Property Value int SeedLen Seed length in bytes (32). public static int SeedLen { get; } Property Value int SharedKeyLen Shared key length in bytes (32). public static int SharedKeyLen { get; } Property Value int Methods CalculatePublicKey(Span<byte>, ReadOnlySpan<byte>) Calculates the Curve25519 public key from a given private key. public static void CalculatePublicKey(Span<byte> publicKey, ReadOnlySpan<byte> privateKey) Parameters publicKey Span<byte> The buffer where the calculated public key (32 bytes) will be written. privateKey ReadOnlySpan<byte> The private key to derive from (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if public key calculation fails. CalculateSharedKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Calculates a shared secret using a peer's public key and the local private key. public static void CalculateSharedKey(Span<byte> sharedKey, ReadOnlySpan<byte> publicKey, ReadOnlySpan<byte> privateKey) Parameters sharedKey Span<byte> The buffer where the shared key (32 bytes) will be written. publicKey ReadOnlySpan<byte> The peer's public key (32 bytes). privateKey ReadOnlySpan<byte> The local private key (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if shared key calculation fails. DecryptWithKeypair(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using the recipient's private key and the sender's public key. Supports both combined and detached modes, with optional nonce. public static Span<byte> DecryptWithKeypair(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> senderPublicKey, ReadOnlySpan<byte> recipientPrivateKey, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). senderPublicKey ReadOnlySpan<byte> The sender's public key (32 bytes). recipientPrivateKey ReadOnlySpan<byte> The recipient's private key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided it is taken from the beginning of the ciphertext. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. DecryptWithPrivateKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a sealed message using the recipient's private key. This method uses libsodium's crypto_box_seal_open internally and automatically derives the recipient's public key from the given private key. The ciphertext must have been produced using EncryptWithPublicKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>). public static Span<byte> DecryptWithPrivateKey(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> recipientPrivateKey) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. Must be at least ciphertext.Length - SealOverheadLen bytes long. ciphertext ReadOnlySpan<byte> The sealed ciphertext, including a 32-byte ephemeral public key and a 16-byte MAC. Must be at least SealOverheadLen bytes long. recipientPrivateKey ReadOnlySpan<byte> The recipient's private key (32 bytes). Returns Span<byte> A slice of the plaintext buffer containing the decrypted message. Exceptions ArgumentException Thrown when buffer sizes are invalid or the private key is not 32 bytes long. LibSodiumException Thrown when the ciphertext cannot be decrypted or the MAC verification fails. DecryptWithSharedKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using a precomputed shared key. Supports both combined and detached modes, with optional nonce. public static Span<byte> DecryptWithSharedKey(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> sharedKey, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). sharedKey ReadOnlySpan<byte> The shared key (32 bytes) previously computed using CalculateSharedKey. mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, it is taken from the beginning of the ciphertext Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. EncryptWithKeypair(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using the recipient's public key and the sender's private key. Supports both combined and detached modes, with optional nonce. public static Span<byte> EncryptWithKeypair(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> recipientPublicKey, ReadOnlySpan<byte> senderPrivateKey, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. Must be large enough to hold the output (plaintext + 16 bytes MAC [+ 24 bytes nonce if auto-generated]). plaintext ReadOnlySpan<byte> The message to encrypt. recipientPublicKey ReadOnlySpan<byte> The recipient's public key (32 bytes). senderPrivateKey ReadOnlySpan<byte> The sender's private key (32 bytes). mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. EncryptWithPublicKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message anonymously using the recipient's public key. This method uses Libsodium's crypto_box_seal function internally, and does not require a sender key. The resulting ciphertext includes an ephemeral public key and a MAC, adding a constant overhead of SealOverheadLen bytes. public static Span<byte> EncryptWithPublicKey(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> recipientPublicKey) Parameters ciphertext Span<byte> The buffer where the sealed ciphertext will be written. Must be at least plaintext.Length + SealOverheadLen bytes long. plaintext ReadOnlySpan<byte> The message to encrypt. recipientPublicKey ReadOnlySpan<byte> The recipient's public key (32 bytes). Returns Span<byte> A slice of the ciphertext buffer containing the full sealed ciphertext. Exceptions ArgumentException Thrown when the recipient's public key is not 32 bytes long, or when the ciphertext buffer is too small. LibSodiumException Thrown when the underlying Libsodium encryption operation fails. EncryptWithSharedKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using a precomputed shared key. Supports both combined and detached modes, with optional nonce. public static Span<byte> EncryptWithSharedKey(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> sharedKey, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. Must be large enough to hold the output (plaintext + 16 bytes MAC [+ 24 bytes nonce if auto-generated]). plaintext ReadOnlySpan<byte> The message to encrypt. sharedKey ReadOnlySpan<byte> The shared key (32 bytes) previously computed using CalculateSharedKey. mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails. GenerateKeypair(Span<byte>, Span<byte>) Generates a new Curve25519 key pair for use with crypto_box. public static void GenerateKeypair(Span<byte> publicKey, Span<byte> privateKey) Parameters publicKey Span<byte> The buffer where the generated public key (32 bytes) will be written. privateKey Span<byte> The buffer where the generated private key (32 bytes) will be written. Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key generation fails. GenerateKeypairDeterministically(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Generates a Curve25519 key pair deterministically from a seed. public static void GenerateKeypairDeterministically(Span<byte> publicKey, Span<byte> privateKey, ReadOnlySpan<byte> seed) Parameters publicKey Span<byte> The buffer where the generated public key (32 bytes) will be written. privateKey Span<byte> The buffer where the generated private key (32 bytes) will be written. seed ReadOnlySpan<byte> The seed to use for deterministic key generation (32 bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key generation fails."
  },
  "api/LibSodium.CryptoGenericHash.html": {
    "href": "api/LibSodium.CryptoGenericHash.html",
    "title": "Class CryptoGenericHash | LibSodium.Net",
    "summary": "Class CryptoGenericHash Namespace LibSodium Assembly LibSodium.Net.dll Provides a high-level interface to the libsodium generic hash function, based on BLAKE2b. public static class CryptoGenericHash Inheritance object CryptoGenericHash Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class wraps the crypto_generichash functions from libsodium, offering both one-shot and streaming hash computations. The output length and key length can be customized within defined bounds. The hash can be computed over a byte span or a stream, synchronously or asynchronously. For additional details, see the official libsodium documentation: \uD83E\uDDC2 https://libsodium.gitbook.io/doc/hashing/generic_hashing Fields HashLen Default hash length in bytes (32). public const int HashLen = 32 Field Value int KeyLen Default key length in bytes (32). public const int KeyLen = 32 Field Value int MaxHashLen Maximum allowed length in bytes for the hash (64). public const int MaxHashLen = 64 Field Value int MaxKeyLen Maximum allowed key length in bytes (64 bytes). public const int MaxKeyLen = 64 Field Value int MinHashLen Minimum allowed length in bytes for the hash (16). public const int MinHashLen = 16 Field Value int MinKeyLen Minimum length in bytes for secret keys (16). public const int MinKeyLen = 16 Field Value int Methods ComputeHash(Span<byte>, Stream, ReadOnlySpan<byte>) Computes a generic hash from the contents of a stream. public static void ComputeHash(Span<byte> hash, Stream input, ReadOnlySpan<byte> key = default) Parameters hash Span<byte> The buffer where the computed hash will be written. Its length defines the output size. input Stream The input stream to read and hash. key ReadOnlySpan<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. ComputeHash(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Computes a generic hash of the specified message. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message, ReadOnlySpan<byte> key = default) Parameters hash Span<byte> The buffer where the computed hash will be written. Its length defines the output size. message ReadOnlySpan<byte> The input message to hash. key ReadOnlySpan<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally. ComputeHashAsync(Memory<byte>, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously computes a generic hash from the contents of a stream. public static Task ComputeHashAsync(Memory<byte> hash, Stream input, ReadOnlyMemory<byte> key = default, CancellationToken cancellationToken = default) Parameters hash Memory<byte> The memory buffer where the computed hash will be written. Its length defines the output size. input Stream The input stream to read and hash. key ReadOnlyMemory<byte> An optional key for keyed hashing (HMAC-like). May be empty for unkeyed mode. cancellationToken CancellationToken A cancellation token to cancel the operation. Returns Task A task representing the asynchronous hash computation. Exceptions ArgumentException Thrown if hash has an invalid length, or if key is too long. LibSodiumException Thrown if the hashing operation fails internally."
  },
  "api/LibSodium.CryptoPasswordHash.html": {
    "href": "api/LibSodium.CryptoPasswordHash.html",
    "title": "Class CryptoPasswordHash | LibSodium.Net",
    "summary": "Class CryptoPasswordHash Namespace LibSodium Assembly LibSodium.Net.dll Provides password hashing and key derivation using Argon2. public static class CryptoPasswordHash Inheritance object CryptoPasswordHash Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks \uD83E\uDDC2 Based on libsodium's crypto_pwhash API: https://doc.libsodium.org/password_hashing Fields EncodedLen Maximum length of the encoded hash string (includes null terminator) (128). public const int EncodedLen = 128 Field Value int InteractiveIterations Recommended iterations for interactive use (2). public const int InteractiveIterations = 2 Field Value int InteractiveMemoryLen Recommended memory usage for interactive use (64Mb). public const int InteractiveMemoryLen = 67108864 Field Value int MinIterations Minimum number of iterations for key derivation (1). public const int MinIterations = 1 Field Value int MinKeyLen Minimum allowed length in bytes for the derived key (16). public const int MinKeyLen = 16 Field Value int MinMemoryLen Minimum memory usage in bytes (8k). public const int MinMemoryLen = 8192 Field Value int MinPasswordLen Minimum allowed password length in bytes (0). public const int MinPasswordLen = 0 Field Value int ModerateIterations Recommended iterations for moderate use (3). public const int ModerateIterations = 3 Field Value int ModerateMemoryLen Recommended memory usage for moderate use (256Mb). public const int ModerateMemoryLen = 268435456 Field Value int Prefix Prefix for the encoded hash string (e.g. \"\\(argon2id\\)\"). public const string Prefix = \"$argon2id$\" Field Value string SaltLen Length of the salt in bytes (16). public const int SaltLen = 16 Field Value int SensitiveIterations Recommended iterations for sensitive use (4). public const int SensitiveIterations = 4 Field Value int SensitiveMemoryLen Recommended memory usage for sensitive use (1Gb). public const int SensitiveMemoryLen = 1073741824 Field Value int Methods DeriveKey(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, int, int, PasswordHashAlgorithm) Derives a secret key from a password and salt using Argon2. public static void DeriveKey(Span<byte> key, ReadOnlySpan<byte> password, ReadOnlySpan<byte> salt, int iterations = 2, int requiredMemoryLen = 67108864, PasswordHashAlgorithm algorithm = PasswordHashAlgorithm.Argon2id13) Parameters key Span<byte> Buffer to receive the derived key (recommended: 32 bytes). password ReadOnlySpan<byte> The password to hash. salt ReadOnlySpan<byte> The salt (must be 16 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). algorithm PasswordHashAlgorithm Hash algorithm to use (default: Argon2id13). Exceptions ArgumentException If arguments are invalid. LibSodiumException If hashing fails. DeriveKey(Span<byte>, string, ReadOnlySpan<byte>, int, int, PasswordHashAlgorithm) Derives a secret key from a password string and salt using Argon2. public static void DeriveKey(Span<byte> key, string password, ReadOnlySpan<byte> salt, int iterations = 2, int requiredMemoryLen = 67108864, PasswordHashAlgorithm algorithm = PasswordHashAlgorithm.Argon2id13) Parameters key Span<byte> Buffer to receive the derived key (recommended: 32 bytes). password string The password string to hash. salt ReadOnlySpan<byte> The salt (must be 16 bytes). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). algorithm PasswordHashAlgorithm Hash algorithm to use (default: Argon2id13). Exceptions ArgumentNullException If the password is null. LibSodiumException If hashing fails. HashPassword(ReadOnlySpan<byte>, int, int) Hashes a password into a human-readable string (including algorithm and parameters). public static string HashPassword(ReadOnlySpan<byte> password, int iterations = 2, int requiredMemoryLen = 67108864) Parameters password ReadOnlySpan<byte> The password to hash (in UTF-8). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentOutOfRangeException If password is too short or parameters are invalid. LibSodiumException If hashing fails. HashPassword(string, int, int) Hashes a password string into a human-readable string (including algorithm and parameters). public static string HashPassword(string password, int iterations = 2, int requiredMemoryLen = 67108864) Parameters password string The password to hash (as string). iterations int Computation cost (default: INTERACTIVE). requiredMemoryLen int Memory usage limit in bytes (default: INTERACTIVE). Returns string A string containing only ASCII characters, including the algorithm identifier, salt, and parameters. Exceptions ArgumentNullException If the password is null. ArgumentOutOfRangeException If parameters are invalid. LibSodiumException If hashing fails. VerifyPassword(string, ReadOnlySpan<byte>) Verifies a password against a previously hashed string. public static bool VerifyPassword(string hashedPassword, ReadOnlySpan<byte> password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password ReadOnlySpan<byte> The password to verify. Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If hashedPassword is null. ArgumentException If hashedPassword is too long. VerifyPassword(string, string) Verifies a password string against a previously hashed string. public static bool VerifyPassword(string hashedPassword, string password) Parameters hashedPassword string The encoded password hash string (must be ASCII and null-terminated). password string The password to verify (as string). Returns bool true if the password is valid; otherwise, false. Exceptions ArgumentNullException If password is null."
  },
  "api/LibSodium.CryptoSecretStream.html": {
    "href": "api/LibSodium.CryptoSecretStream.html",
    "title": "Class CryptoSecretStream | LibSodium.Net",
    "summary": "Class CryptoSecretStream Namespace LibSodium Assembly LibSodium.Net.dll The CryptoSecretStream class provides methods for performing authenticated encryption and decryption of data streams, with optional additional authenticated data. It is based on the XChaCha20-Poly1305 algorithm. public static class CryptoSecretStream Inheritance object CryptoSecretStream Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields HeaderLen The length of the header used in the secret stream. public const int HeaderLen = 24 Field Value int KeyLen The length of the key used for encryption and decryption. public const int KeyLen = 32 Field Value int OverheadLen The length of the overhead added to each ciphertext message. This includes the authentication tag and any necessary metadata for the stream. public static int OverheadLen Field Value int StateLen The length of the state used in the secret stream. public static int StateLen Field Value int Methods DecryptChunk(Span<byte>, Span<byte>, out CryptoSecretStreamTag, ReadOnlySpan<byte>) Decrypts and verifies the authenticity of a block of data using the secret stream. public static Span<byte> DecryptChunk(Span<byte> state, Span<byte> cleartext, out CryptoSecretStreamTag tag, ReadOnlySpan<byte> ciphertext) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. cleartext Span<byte> The span to write the decrypted data to. Must have a length of at least ciphertext.Length - OverheadLen. tag CryptoSecretStreamTag When this method returns, contains the tag associated with the decrypted message. ciphertext ReadOnlySpan<byte> The encrypted and authenticated data to decrypt. Returns Span<byte> A Span<T> representing the decrypted data written to cleartext. Exceptions ArgumentException If the length of the state or cleartext spans are incorrect. LibSodiumException If the decryption or authentication of the chunk fails, likely due to tampered ciphertext. DecryptChunk(Span<byte>, Span<byte>, out CryptoSecretStreamTag, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts and verifies the authenticity of a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> DecryptChunk(Span<byte> state, Span<byte> cleartext, out CryptoSecretStreamTag tag, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> additionalData) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. cleartext Span<byte> The span to write the decrypted data to. Must have a length of at least ciphertext.Length - OverheadLen. tag CryptoSecretStreamTag When this method returns, contains the tag associated with the decrypted message. ciphertext ReadOnlySpan<byte> The encrypted and authenticated data to decrypt. additionalData ReadOnlySpan<byte> Additional authenticated data that was cryptographically incorporated during the calculation of the authentication tag for the corresponding ciphertext. This value must be identical to the one used during the EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) call for authentication to succeed. Returns Span<byte> A Span<T> representing the decrypted data written to cleartext. Exceptions ArgumentException If the length of the state or cleartext spans are incorrect. LibSodiumException If the decryption or authentication of the chunk fails, likely due to tampered ciphertext or incorrect AAD. EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag) Encrypts and authenticates a block of data using the secret stream. public static Span<byte> EncryptChunk(Span<byte> state, Span<byte> ciphertext, ReadOnlySpan<byte> cleartext, CryptoSecretStreamTag tag) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. ciphertext Span<byte> The span to write the encrypted and authenticated data to. Must have a length of at least cleartext.Length + OverheadLen. cleartext ReadOnlySpan<byte> The data to encrypt. tag CryptoSecretStreamTag The tag to associate with this message. Returns Span<byte> A Span<T> representing the encrypted and authenticated data written to ciphertext. Exceptions ArgumentException If the length of the state or ciphertext spans are incorrect. LibSodiumException If the encryption of the block fails. EncryptChunk(Span<byte>, Span<byte>, ReadOnlySpan<byte>, CryptoSecretStreamTag, ReadOnlySpan<byte>) Encrypts and authenticates a block of data using the secret stream with additional authenticated data (AAD). public static Span<byte> EncryptChunk(Span<byte> state, Span<byte> ciphertext, ReadOnlySpan<byte> cleartext, CryptoSecretStreamTag tag, ReadOnlySpan<byte> additionalData) Parameters state Span<byte> The current state of the secret stream. Must be StateLen bytes long. ciphertext Span<byte> The span to write the encrypted and authenticated data to. Must have a length of at least cleartext.Length + OverheadLen. cleartext ReadOnlySpan<byte> The data to encrypt. tag CryptoSecretStreamTag The tag to associate with this message. additionalData ReadOnlySpan<byte> Additional data that is cryptographically incorporated during the calculation of the authentication tag for the ciphertext. This data is authenticated but not encrypted. Returns Span<byte> A Span<T> representing the encrypted and authenticated data written to ciphertext. Exceptions ArgumentException If the length of the state or ciphertext spans are incorrect. LibSodiumException If the encryption of the chunk fails. GenerateKey(Span<byte>) Generates a random key for use with the secret stream. public static void GenerateKey(Span<byte> key) Parameters key Span<byte> The span to write the generated key to. Exceptions ArgumentException If the length of the key span is not equal to KeyLen. InitializeDecryption(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Initializes the authenticated decryption process for a secret stream. public static void InitializeDecryption(Span<byte> state, ReadOnlySpan<byte> header, ReadOnlySpan<byte> key) Parameters state Span<byte> The span to write the initial state to. Must be StateLen bytes long. header ReadOnlySpan<byte> The stream header received from the sender. Must be HeaderLen bytes long. key ReadOnlySpan<byte> The secret key used for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of decryption fails, likely due to an incorrect header or key. InitializeEncryption(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Initializes the authenticated encryption process for a secret stream. public static void InitializeEncryption(Span<byte> state, Span<byte> header, ReadOnlySpan<byte> key) Parameters state Span<byte> The span to write the initial state to. Must be StateLen bytes long. header Span<byte> The span to write the stream header to. Must be HeaderLen bytes long. key ReadOnlySpan<byte> The secret key to use for encryption. Must be KeyLen bytes long. Exceptions ArgumentException If the length of the state, header, or key spans are incorrect. LibSodiumException If the initialization of encryption fails."
  },
  "api/LibSodium.CryptoSecretStreamTag.html": {
    "href": "api/LibSodium.CryptoSecretStreamTag.html",
    "title": "Enum CryptoSecretStreamTag | LibSodium.Net",
    "summary": "Enum CryptoSecretStreamTag Namespace LibSodium Assembly LibSodium.Net.dll The tags used in the secret stream. public enum CryptoSecretStreamTag Fields Final = 3 The value of the tag corresponding to the final message. Message = 0 The value of the tag corresponding to a regular message. Push = 1 Indicates that the message marks the end of a set of messages, but not the end of the stream Rekey = 2 “forget” the key used to encrypt this message and the previous ones, and derive a new secret key"
  },
  "api/LibSodium.CryptoShortHash.html": {
    "href": "api/LibSodium.CryptoShortHash.html",
    "title": "Class CryptoShortHash | LibSodium.Net",
    "summary": "Class CryptoShortHash Namespace LibSodium Assembly LibSodium.Net.dll Provides a high-level interface to the libsodium short-input hash function, based on SipHash-2-4. public static class CryptoShortHash Inheritance object CryptoShortHash Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This function is optimized for short messages and uses a 16-byte secret key to protect against hash-flooding attacks. It is not suitable for general-purpose cryptographic hashing. \uD83E\uDDC2 https://libsodium.gitbook.io/doc/hashing/short-input_hashing Fields HashLen Hash length in bytes (8). public const int HashLen = 8 Field Value int KeyLen Key length in bytes (16). public const int KeyLen = 16 Field Value int Methods ComputeHash(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Computes a short hash (SipHash-2-4) of the given message using the provided 16-byte key. The key must remain secret. This function will not provide any mitigations against DoS attacks if the key is known from attackers. public static void ComputeHash(Span<byte> hash, ReadOnlySpan<byte> message, ReadOnlySpan<byte> key) Parameters hash Span<byte> A buffer of exactly 8 bytes to receive the output. message ReadOnlySpan<byte> The message to hash. key ReadOnlySpan<byte> A 16-byte secret key. Exceptions ArgumentException Thrown if the key or hash buffer is not of expected length. LibSodiumException Thrown if the hashing operation fails."
  },
  "api/LibSodium.CryptoSign.html": {
    "href": "api/LibSodium.CryptoSign.html",
    "title": "Class CryptoSign | LibSodium.Net",
    "summary": "Class CryptoSign Namespace LibSodium Assembly LibSodium.Net.dll Provides digital signature functionality using Ed25519, as implemented by libsodium. public static class CryptoSign Inheritance object CryptoSign Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PrivateKeyLen Length in bytes of a private (secret) key (64). public const int PrivateKeyLen = 64 Field Value int PublicKeyLen Length in bytes of a public key (32). public const int PublicKeyLen = 32 Field Value int SeedLen Length in bytes of a seed used to generate key pairs deterministically. public const int SeedLen = 32 Field Value int SignatureLen Length in bytes of a signature (64). public const int SignatureLen = 64 Field Value int Methods GenerateKeyPair(Span<byte>, Span<byte>) Generates a new Ed25519 public/private key pair. public static void GenerateKeyPair(Span<byte> publicKey, Span<byte> privateKey) Parameters publicKey Span<byte> A span where the generated public key will be stored (must be PublicKeyLen bytes). privateKey Span<byte> A span where the generated private key will be stored (must be PrivateKeyLen bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key pair generation fails. GenerateKeyPairDeterministically(Span<byte>, Span<byte>, ReadOnlySpan<byte>) Generates a Ed25519 public/private key pair from a seed deterministically. public static void GenerateKeyPairDeterministically(Span<byte> publicKey, Span<byte> secretKey, ReadOnlySpan<byte> seed) Parameters publicKey Span<byte> A span where the generated public key will be stored (must be PublicKeyLen bytes). secretKey Span<byte> A span where the generated private key will be stored (must be PrivateKeyLen bytes). seed ReadOnlySpan<byte> A seed used for key generation (must be SeedLen bytes). Exceptions ArgumentException Thrown if the buffer sizes are incorrect. LibSodiumException Thrown if key pair generation fails. Sign(ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Creates a signature for the given message using the provided private key. public static Span<byte> Sign(ReadOnlySpan<byte> message, Span<byte> signature, ReadOnlySpan<byte> privateKey) Parameters message ReadOnlySpan<byte> The message to be signed. signature Span<byte> A span to store the signature (must be at least SignatureLen bytes). privateKey ReadOnlySpan<byte> The private key to sign with (must be PrivateKeyLen bytes). Returns Span<byte> A slice of the signature span containing the actual signature. Exceptions ArgumentException Thrown if the signature or private key length is incorrect. LibSodiumException Thrown if the signing operation fails. TryVerify(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies a signature against a given message and public key. public static bool TryVerify(ReadOnlySpan<byte> message, ReadOnlySpan<byte> signature, ReadOnlySpan<byte> publicKey) Parameters message ReadOnlySpan<byte> The original message. signature ReadOnlySpan<byte> The signature to verify (must be SignatureLen bytes). publicKey ReadOnlySpan<byte> The public key used to verify the signature (must be PublicKeyLen bytes). Returns bool true if the signature is valid; otherwise, false. Exceptions ArgumentException Thrown if the signature or public key length is incorrect. Verify(ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Verifies a signature against a given message and public key. Throws if the signature is invalid. public static void Verify(ReadOnlySpan<byte> message, ReadOnlySpan<byte> signature, ReadOnlySpan<byte> publicKey) Parameters message ReadOnlySpan<byte> The original message. signature ReadOnlySpan<byte> The signature to verify (must be SignatureLen bytes). publicKey ReadOnlySpan<byte> The public key used to verify the signature (must be PublicKeyLen bytes). Exceptions ArgumentException Thrown if the signature or public key length is incorrect. LibSodiumException Thrown if the signature is invalid."
  },
  "api/LibSodium.HexEncoding.html": {
    "href": "api/LibSodium.HexEncoding.html",
    "title": "Class HexEncoding | LibSodium.Net",
    "summary": "Class HexEncoding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for encoding and decoding hexadecimal strings and byte buffers. public static class HexEncoding Inheritance object HexEncoding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BinToHex(ReadOnlySpan<byte>) Converts a byte buffer to a hexadecimal string in constant time for a given size. public static string BinToHex(ReadOnlySpan<byte> bin) Parameters bin ReadOnlySpan<byte> The byte buffer to convert. Returns string A hexadecimal string representation of the byte buffer. BinToHex(ReadOnlySpan<byte>, Span<char>) Converts a byte buffer to a hexadecimal string using a provided character span. public static Span<char> BinToHex(ReadOnlySpan<byte> bin, Span<char> hex) Parameters bin ReadOnlySpan<byte> The byte buffer to convert. hex Span<char> The span to write the hexadecimal string into. Returns Span<char> A span containing the hexadecimal string representation. HexToBin(ReadOnlySpan<char>, Span<byte>, string?) Converts a span of characters representing a hexadecimal string to a byte buffer. public static Span<byte> HexToBin(ReadOnlySpan<char> hex, Span<byte> bin, string? ignore = null) Parameters hex ReadOnlySpan<char> The span of characters representing the hexadecimal string. bin Span<byte> The span to write the byte buffer into. ignore string Optional characters to ignore during conversion. Returns Span<byte> A span containing the converted byte buffer. HexToBin(string, Span<byte>, string?) Converts a hexadecimal string to a byte buffer. public static Span<byte> HexToBin(string hex, Span<byte> bin, string? ignore = null) Parameters hex string The hexadecimal string to convert. bin Span<byte> The span to write the byte buffer into. ignore string Optional characters to ignore during conversion. Returns Span<byte> A span containing the converted byte buffer."
  },
  "api/LibSodium.LibSodiumException.html": {
    "href": "api/LibSodium.LibSodiumException.html",
    "title": "Class LibSodiumException | LibSodium.Net",
    "summary": "Class LibSodiumException Namespace LibSodium Assembly LibSodium.Net.dll Represents errors that occur during Sodium operations. [Serializable] public class LibSodiumException : CryptographicException, ISerializable Inheritance object Exception SystemException CryptographicException LibSodiumException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors LibSodiumException() Initializes a new instance of the LibSodiumException class. public LibSodiumException() LibSodiumException(string?) Initializes a new instance of the LibSodiumException class with a specified error message. public LibSodiumException(string? message) Parameters message string The error message that explains the reason for the exception. LibSodiumException(string?, Exception?) Initializes a new instance of the LibSodiumException class with a specified error message and a reference to the inner exception that is the cause of this exception. public LibSodiumException(string? message, Exception? innerException) Parameters message string The error message that explains the reason for the exception. innerException Exception The exception that is the cause of the current exception, or a null reference if no inner exception is specified."
  },
  "api/LibSodium.LibraryInitializer.html": {
    "href": "api/LibSodium.LibraryInitializer.html",
    "title": "Class LibraryInitializer | LibSodium.Net",
    "summary": "Class LibraryInitializer Namespace LibSodium Assembly LibSodium.Net.dll Static class that manages the initialization and configuration of libsodium. public static class LibraryInitializer Inheritance object LibraryInitializer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsInitialized Gets a value indicating whether the library has been initialized public static bool IsInitialized { get; } Property Value bool Methods EnsureInitialized() Ensures that the libsodium library is initialized. public static void EnsureInitialized()"
  },
  "api/LibSodium.LibraryVersion.html": {
    "href": "api/LibSodium.LibraryVersion.html",
    "title": "Class LibraryVersion | LibSodium.Net",
    "summary": "Class LibraryVersion Namespace LibSodium Assembly LibSodium.Net.dll Provides methods to retrieve the version information of the Sodium library. public static class LibraryVersion Inheritance object LibraryVersion Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetMajor() Gets the major version number of the Sodium library. public static int GetMajor() Returns int The major version number as an integer. GetMinor() Gets the minor version number of the Sodium library. public static int GetMinor() Returns int The minor version number as an integer. GetString() Gets the version string of the Sodium library. public static string? GetString() Returns string The version string as a string, or null if the string could not be retrieved."
  },
  "api/LibSodium.PasswordHashAlgorithm.html": {
    "href": "api/LibSodium.PasswordHashAlgorithm.html",
    "title": "Enum PasswordHashAlgorithm | LibSodium.Net",
    "summary": "Enum PasswordHashAlgorithm Namespace LibSodium Assembly LibSodium.Net.dll Supported password hashing algorithms. public enum PasswordHashAlgorithm Fields Argon2i13 = 1 Argon2i version 1.3 — optimized for side-channel resistance. Argon2id13 = 2 Argon2id version 1.3 — hybrid mode (default and recommended)."
  },
  "api/LibSodium.RandomGenerator.html": {
    "href": "api/LibSodium.RandomGenerator.html",
    "title": "Class RandomGenerator | LibSodium.Net",
    "summary": "Class RandomGenerator Namespace LibSodium Assembly LibSodium.Net.dll Static class for random number generation. public static class RandomGenerator Inheritance object RandomGenerator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields SeedLen The length of the seed used for deterministic random byte generation. public const int SeedLen = 32 Field Value int Methods Close() Closes the random number generator. public static void Close() Exceptions LibSodiumException Thrown when randombytes_close() fails. Fill(Span<byte>) Fills the specified buffer with random bytes. public static void Fill(Span<byte> buffer) Parameters buffer Span<byte> The buffer to fill with random bytes. FillDeterministic(Span<byte>, ReadOnlySpan<byte>) Fills the specified buffer with deterministic random bytes based on the provided seed. It produces the same sequence of random bytes for the same seed. public static void FillDeterministic(Span<byte> buffer, ReadOnlySpan<byte> seed) Parameters buffer Span<byte> The buffer to fill with deterministic random bytes. seed ReadOnlySpan<byte> The seed used for deterministic random byte generation. Exceptions ArgumentException Thrown when the seed length is not equal to SeedLen. GetUInt32() Gets a random unsigned 32-bit integer. public static uint GetUInt32() Returns uint A random unsigned 32-bit integer. GetUInt32(uint) Gets a random unsigned 32-bit integer less than the specified upper bound. public static uint GetUInt32(uint upperBound) Parameters upperBound uint The upper bound (exclusive) for the random number. Returns uint A random unsigned 32-bit integer less than upperBound. Stir() Stirs the random number generator to ensure randomness. public static void Stir()"
  },
  "api/LibSodium.SecretBox.html": {
    "href": "api/LibSodium.SecretBox.html",
    "title": "Class SecretBox | LibSodium.Net",
    "summary": "Class SecretBox Namespace LibSodium Assembly LibSodium.Net.dll Provides static methods for authenticated symmetric encryption and decryption using the Sodium secretbox primitives, specifically the XSalsa20 stream cipher and Poly1305 MAC for authentication. These methods offer combined encryption/authentication and detached encryption/authentication, with variations for handling nonces and Message Authentication Codes (MACs) within or separate from the ciphertext. public static class SecretBox Inheritance object SecretBox Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields KeyLen Represents the length of the encryption key in bytes. public const int KeyLen = 32 Field Value int MacLen represents the length of the Message Authentication Code (MAC) in bytes public const int MacLen = 16 Field Value int NonceLen Represents the length of the nonce (number used once) in bytes. public const int NonceLen = 24 Field Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using XSalsa20-Poly1305. Supports combined and detached modes, with optional manual nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer to receive the decrypted message. Must be at least ciphertext length minus MAC and/or nonce depending on mode. It can be longer than needed. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and/or nonce depending on the mode. key ReadOnlySpan<byte> The secret key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode using this MAC. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, it is extracted from the ciphertext (auto-nonce mode). Returns Span<byte> The span representing the recovered plaintext. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>) Encrypts a message using XSalsa20-Poly1305. Supports combined and detached modes, with optional manual nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The output buffer. In combined mode, it must include space for the MAC and, if auto-nonce is used, also for the nonce. In detached mode with auto-nonce, the nonce is prepended. It can be longer than needed. plaintext ReadOnlySpan<byte> The plaintext to encrypt. key ReadOnlySpan<byte> The secret key (32 bytes). mac Span<byte> Optional. If provided, encryption is done in detached mode and the MAC is written to this buffer. Otherwise, combined mode is used. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended to the ciphertext. Returns Span<byte> The span representing the encrypted ciphertext, which may include MAC and nonce depending on the mode."
  },
  "api/LibSodium.SecretStream.html": {
    "href": "api/LibSodium.SecretStream.html",
    "title": "Class SecretStream | LibSodium.Net",
    "summary": "Class SecretStream Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level, stream-based authenticated encryption and decryption using the XChaCha20-Poly1305 algorithm. This class abstracts the complexity of securely processing large data streams, including chunking, authentication, and cryptographic state management. public static class SecretStream Inheritance object SecretStream Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class is built on LibSodium’s crypto_secretstream_xchacha20poly1305 API, using XChaCha20 for encryption and Poly1305 for message authentication. The large 192-bit nonce (24 bytes) virtually eliminates the risk of nonce reuse when generated randomly. The stream is processed in fixed-size chunks (64 KB), each individually encrypted and authenticated. A randomly generated header (nonce and metadata) is prepended to the stream and required for successful decryption. Security Considerations: Key Management: Keys must be generated securely and stored safely. Compromise of the key invalidates confidentiality and integrity guarantees. Nonce Handling: Nonces are generated internally. Do not reuse headers or keys manually unless you know what you're doing. Integrity: Poly1305 tags ensure tampering is detected during decryption. Any modification will result in decryption failure. Fields PlainChunkSize The size of each plaintext chunk processed during encryption (64KB). This chunk size is used to divide the input stream into manageable blocks. public const int PlainChunkSize = 65536 Field Value int Methods Decrypt(Stream, Stream, SecureMemory<byte>) Synchronously decrypts data from the input stream using a key stored in secure memory, and writes the plaintext to the output stream. public static void Decrypt(Stream input, Stream output, SecureMemory<byte> key) Parameters input Stream The stream containing encrypted data. It must begin with the secret stream header written during encryption. output Stream The stream where decrypted plaintext will be written. key SecureMemory<byte> A SecureMemory<T> buffer containing the decryption key. This key must match the one used to encrypt the stream. Remarks This method behaves identically to Decrypt(Stream, Stream, ReadOnlySpan<byte>), but uses a secure memory buffer for enhanced key confidentiality. The decryption header is consumed automatically at the beginning of the stream. Chunks are processed sequentially, and any failure in tag verification will cause decryption to halt with an exception. Internal buffers are cleared and returned to the pool after use. The input and output streams remain open. Exceptions ArgumentNullException Thrown if input, output, or key is null. ObjectDisposedException Thrown if the secure memory key has already been disposed. EndOfStreamException Thrown if the stream ends before the Final tag is encountered. LibSodiumException Thrown if the authentication of a chunk fails, which indicates tampering or a mismatched key. Decrypt(Stream, Stream, ReadOnlySpan<byte>) Synchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying each chunk's authenticity using XChaCha20-Poly1305. public static void Decrypt(Stream input, Stream output, ReadOnlySpan<byte> key) Parameters input Stream The readable stream containing encrypted data. The stream must begin with the encryption header produced during the corresponding encryption process. output Stream The writable stream where decrypted plaintext will be written. key ReadOnlySpan<byte> The secret decryption key. It must match the key used to encrypt the stream and be exactly 32 bytes long. Remarks This method processes the encrypted stream in chunks, validating each chunk before decrypting it. If authentication fails, a LibSodiumException is thrown and the decrypted output is invalidated. The stream must start with a header containing the nonce and metadata necessary for decryption. This header is automatically consumed at the beginning of the stream. All internal buffers are zeroed after use. The input and output streams are not closed automatically. Exceptions ArgumentException Thrown if the key is invalid. EndOfStreamException Thrown if the stream ends before the Final tag is reached, indicating an incomplete or truncated stream. LibSodiumException Thrown if authentication fails, indicating the ciphertext has been tampered with or the wrong key was used. DecryptAsync(Stream, Stream, SecureMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream using a key stored in SecureMemory<T>, and writes the plaintext to the output stream. public static Task DecryptAsync(Stream input, Stream output, SecureMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing the encrypted data. The stream must begin with the encryption header. output Stream The writable stream where the decrypted plaintext will be written. key SecureMemory<byte> A secure memory buffer containing the decryption key. This must match the key used to encrypt the stream. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks This overload behaves identically to DecryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken), but uses a SecureMemory<T> buffer for enhanced runtime key protection. The key is securely wiped from memory once decryption is complete. Stream lifetime is not managed automatically. Exceptions ArgumentNullException Thrown if any argument is null. ObjectDisposedException Thrown if the secure key has already been disposed. EndOfStreamException Thrown if the stream ends before the final tag is reached. LibSodiumException Thrown if the integrity check fails (e.g., if the ciphertext has been tampered with). OperationCanceledException Thrown if the operation is canceled. DecryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously decrypts data from the input stream and writes the plaintext to the output stream, verifying integrity using XChaCha20-Poly1305. public static Task DecryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream A readable stream containing encrypted data. The stream must begin with the header produced during encryption. output Stream The writable stream where decrypted plaintext will be written. key ReadOnlyMemory<byte> The secret key used for decryption. It must match the key used during encryption. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous decryption process. Remarks The decryption process begins by reading the stream header, which includes a nonce required to initialize the decryption state. Each encrypted chunk is then read, authenticated, and decrypted in order. If any chunk fails authentication, a LibSodiumException is thrown and no plaintext is written for that chunk. If the stream ends before encountering a chunk tagged as Final, an EndOfStreamException is thrown. This method uses pooled buffers and zeroes out internal state after use to reduce memory leakage risks. Input and output streams are not closed automatically. Exceptions ArgumentNullException Thrown if any argument is null. EndOfStreamException Thrown if the stream ends unexpectedly or the final tag is never reached. LibSodiumException Thrown if the integrity check fails on any chunk (i.e., authentication tag mismatch). OperationCanceledException Thrown if the operation is canceled. Encrypt(Stream, Stream, SecureMemory<byte>) Synchronously encrypts data from the input stream using a secure key, and writes the ciphertext to the output stream. public static void Encrypt(Stream input, Stream output, SecureMemory<byte> key) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key SecureMemory<byte> A SecureMemory<T> buffer containing the encryption key. It must be 32 bytes in size, and will be securely wiped from memory after use. Remarks This method is functionally equivalent to Encrypt(Stream, Stream, ReadOnlySpan<byte>), but accepts the encryption key wrapped in SecureMemory<T> for added in-memory protection. This improves resistance to key leakage through memory inspection, especially in long-lived processes. Exceptions ArgumentNullException Thrown if key, input, or output is null. ObjectDisposedException Thrown if the key has already been disposed. ArgumentException Thrown if the key is invalid (wrong length). Encrypt(Stream, Stream, ReadOnlySpan<byte>) Synchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static void Encrypt(Stream input, Stream output, ReadOnlySpan<byte> key) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key ReadOnlySpan<byte> The encryption key. Must be securely generated and exactly 32 bytes long for XChaCha20-Poly1305. Remarks This method performs stream encryption in-place and blocks the calling thread until completion. It is suitable for scenarios where asynchronous patterns are not required or not supported. The input is processed in chunks of PlainChunkSize bytes. Each chunk is encrypted and authenticated before being written to the output stream. A cryptographic header is written at the beginning, and a final tag is written after the last chunk. All internal buffers are zeroed after use, and pooled memory is returned. The input and output streams are not closed or disposed automatically. Exceptions ArgumentException Thrown if the key is invalid. EndOfStreamException Thrown if the input stream ends unexpectedly. EncryptAsync(Stream, Stream, SecureMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream using a key stored in SecureMemory<T> and writes the ciphertext to the output stream. public static Task EncryptAsync(Stream input, Stream output, SecureMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key SecureMemory<byte> A secure memory buffer containing the secret key. It is critical that this buffer is disposed properly to ensure the key is wiped from memory. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks This overload offers identical functionality to EncryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken), but uses a SecureMemory<T> buffer to enhance key security during runtime. Using secure memory reduces the risk of sensitive data being captured in memory dumps or accessed by unauthorized code. Exceptions ArgumentNullException Thrown if any argument is null. ObjectDisposedException Thrown if the secure key has already been disposed. OperationCanceledException Thrown if the operation is canceled. EncryptAsync(Stream, Stream, ReadOnlyMemory<byte>, CancellationToken) Asynchronously encrypts data from the input stream and writes the ciphertext to the output stream using the XChaCha20-Poly1305 algorithm. public static Task EncryptAsync(Stream input, Stream output, ReadOnlyMemory<byte> key, CancellationToken cancellationToken = default) Parameters input Stream The readable stream containing plaintext to encrypt. output Stream The writable stream where ciphertext will be written. key ReadOnlyMemory<byte> The secret key for encryption. Must be securely generated and kept confidential. Typically 32 bytes in length for XChaCha20-Poly1305. cancellationToken CancellationToken Optional token to cancel the asynchronous operation. Returns Task A task representing the asynchronous encryption process. Remarks The input stream is read in PlainChunkSize blocks. Each block is encrypted and written to the output stream with an authentication tag to ensure integrity. A cryptographic header (including a randomly generated nonce) is prepended to the output. This header is required for successful decryption. The encryption state is maintained internally and finalized when the last chunk is written with the Final tag. Note: The caller is responsible for managing the lifetime of the input/output streams. They are not closed or disposed automatically. Exceptions ArgumentNullException Thrown if any argument is null. OperationCanceledException Thrown if the operation is canceled."
  },
  "api/LibSodium.SecureBigUnsignedInteger.html": {
    "href": "api/LibSodium.SecureBigUnsignedInteger.html",
    "title": "Class SecureBigUnsignedInteger | LibSodium.Net",
    "summary": "Class SecureBigUnsignedInteger Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for working with arbitrary large little endian big unsigned integers in a secure way (constant time for a given length) public static class SecureBigUnsignedInteger Inheritance object SecureBigUnsignedInteger Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Add(Span<byte>, ReadOnlySpan<byte>) Adds two byte buffers representing big unsigned integers in constant time, storing the result in the second buffer public static void Add(Span<byte> a, ReadOnlySpan<byte> b) Parameters a Span<byte> The first byte buffer representing a big unsigned integer. b ReadOnlySpan<byte> The second byte buffer representing a big unsigned integer. It receives the result. Compare(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers representing big unsigned integers. public static int Compare(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> The first byte buffer. b2 ReadOnlySpan<byte> The second byte buffer. Returns int A negative number if b1 is less than b2, zero if they are equal, and a positive number if b1 is greater than b2. Equals(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers for equality in constant time. public static bool Equals(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> First buffer to compare. b2 ReadOnlySpan<byte> Second buffer to compare. Returns bool True if the buffers are equal, false otherwise. Increment(Span<byte>) Increments the given byte buffer representing a big unsigned integer by 1. public static void Increment(Span<byte> number) Parameters number Span<byte> The byte buffer to increment. Increment(Span<byte>, ulong) Increments the given byte buffer representing a big unsigned integer by a specified value. public static void Increment(Span<byte> number, ulong increment) Parameters number Span<byte> The byte buffer representing a big unsigned integer to increment. increment ulong The value to increment by. IsZero(ReadOnlySpan<byte>) Checks if the given byte buffer is zero. public static bool IsZero(ReadOnlySpan<byte> b) Parameters b ReadOnlySpan<byte> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Subtract(Span<byte>, ReadOnlySpan<byte>) Subtracts one byte buffer from another representing big unsigned integers. public static void Subtract(Span<byte> subtrahend, ReadOnlySpan<byte> minuend) Parameters subtrahend Span<byte> The byte buffer to subtract from. minuend ReadOnlySpan<byte> The byte buffer to subtract."
  },
  "api/LibSodium.SecureMemory-1.html": {
    "href": "api/LibSodium.SecureMemory-1.html",
    "title": "Class SecureMemory<T> | LibSodium.Net",
    "summary": "Class SecureMemory<T> Namespace LibSodium Assembly LibSodium.Net.dll Provides a secure unmanaged memory buffer for unmanaged types, using libsodium for memory protection. This class encapsulates secure memory allocation, read-only protection, and zeroing. public sealed class SecureMemory<T> : IDisposable where T : unmanaged Type Parameters T The unmanaged type of elements in the secure memory buffer. Inheritance object SecureMemory<T> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SecureMemory(int) Initializes a new instance of the SecureMemory<T> class with the specified length. public SecureMemory(int length) Parameters length int The number of elements of type T to allocate. Exceptions LibSodiumException Thrown if memory allocation fails. Properties IsDisposed Gets a value indicating whether the object has been disposed. public bool IsDisposed { get; } Property Value bool IsReadOnly Gets a value indicating whether the memory region is read-only. public bool IsReadOnly { get; } Property Value bool Length Gets the length of the secure unmanaged memory buffer, in number of elements of type T. public int Length { get; } Property Value int Methods AsMemory() Gets a Memory<T> representing the secure unmanaged memory buffer. public Memory<T> AsMemory() Returns Memory<T> Exceptions InvalidOperationException AsReadOnlyMemory() Gets a ReadOnlyMemory<T> representing the secure unmanaged memory buffer. public ReadOnlyMemory<T> AsReadOnlyMemory() Returns ReadOnlyMemory<T> Exceptions ObjectDisposedException AsReadOnlySpan() Gets a ReadOnlySpan<T> representing the secure unmanaged memory buffer. public ReadOnlySpan<T> AsReadOnlySpan() Returns ReadOnlySpan<T> Remarks While this method returns a new ReadOnlySpan<T> instance on each call, all returned spans represent the same underlying memory region. Exceptions ObjectDisposedException Thrown if the object has been disposed. AsSpan() Gets a Span<T> representing the secure unmanaged memory buffer. public Span<T> AsSpan() Returns Span<T> Remarks While this method returns a new Span<T> instance on each call, all returned spans represent the same underlying memory region. Modifications made through one span will be visible through any other span obtained from this instance. Exceptions ObjectDisposedException Thrown if the object has been disposed. InvalidOperationException Thrown if the memory region is read-only. Dispose() Releases all resources used by the SecureMemory<T> object, including the allocated unmanaged secure memory. public void Dispose() ~SecureMemory() Finalizes an instance of the SecureMemory<T> class. protected ~SecureMemory() MemZero() Fills the secure unmanaged memory buffer with zeros, effectively erasing its contents. public void MemZero() Exceptions ObjectDisposedException Thrown if the object has been disposed. ProtectReadOnly() Marks the secure unmanaged memory buffer as read-only. public void ProtectReadOnly() Exceptions ObjectDisposedException Thrown if the object has been disposed. LibSodiumException Thrown if setting the memory to read-only fails. ProtectReadWrite() Marks the secure unmanaged memory buffer as read-write. public void ProtectReadWrite() Exceptions ObjectDisposedException Thrown if the object has been disposed. LibSodiumException Thrown if setting the memory to read-write fails."
  },
  "api/LibSodium.SecureMemory.html": {
    "href": "api/LibSodium.SecureMemory.html",
    "title": "Class SecureMemory | LibSodium.Net",
    "summary": "Class SecureMemory Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for secure memory management using libsodium. These methods help protect sensitive data from being swapped to disk or accessed by other processes. public static class SecureMemory Inheritance object SecureMemory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Create<T>(int) Creates a SecureMemory<T> holding the specified number of items of given type public static SecureMemory<T> Create<T>(int length) where T : unmanaged Parameters length int The number of items Returns SecureMemory<T> Type Parameters T The type of items Equals(ReadOnlySpan<byte>, ReadOnlySpan<byte>) Compares two byte buffers for equality in constant time. public static bool Equals(ReadOnlySpan<byte> b1, ReadOnlySpan<byte> b2) Parameters b1 ReadOnlySpan<byte> First buffer to compare. b2 ReadOnlySpan<byte> Second buffer to compare. Returns bool True if the buffers are equal, false otherwise. IsZero(ReadOnlySpan<byte>) Checks if the given byte buffer is zero. public static bool IsZero(ReadOnlySpan<byte> b) Parameters b ReadOnlySpan<byte> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. IsZero<T>(ReadOnlySpan<T>) Checks if the given buffer is zero. public static bool IsZero<T>(ReadOnlySpan<T> b) where T : unmanaged Parameters b ReadOnlySpan<T> The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Type Parameters T IsZero<T>(T[]) Checks if the given buffer is zero. public static bool IsZero<T>(T[] b) where T : unmanaged Parameters b T[] The byte buffer to check. Returns bool True if the byte buffer is zero, false otherwise. Type Parameters T MemLock(ReadOnlySpan<byte>) Locks an unmanaged memory buffer, preventing it from being swapped to disk. public static void MemLock(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The span representing the unmanaged memory to lock. Exceptions LibSodiumException Thrown if locking the memory fails. MemLock<T>(ReadOnlySpan<T>) Locks an unmanaged memory buffer, preventing it from being swapped to disk. public static void MemLock<T>(ReadOnlySpan<T> buffer) where T : unmanaged Parameters buffer ReadOnlySpan<T> The span representing the unmanaged memory to lock. Type Parameters T Exceptions LibSodiumException Thrown if locking the memory fails. MemUnlock(ReadOnlySpan<byte>) Unlocks an unmanaged memory buffer, allowing it to be swapped to disk if necessary. public static void MemUnlock(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The span of bytes to unlock. Exceptions LibSodiumException Thrown if unlocking the memory fails. MemUnlock<T>(ReadOnlySpan<T>) Unlocks an unmanaged memory buffer, allowing it to be swapped to disk if necessary. public static void MemUnlock<T>(ReadOnlySpan<T> buffer) where T : unmanaged Parameters buffer ReadOnlySpan<T> The span of bytes to unlock. Type Parameters T Exceptions LibSodiumException Thrown if unlocking the memory fails. MemZero(byte[]) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero(byte[] buffer) Parameters buffer byte[] The span of bytes to zero out. MemZero(Span<byte>) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero(Span<byte> buffer) Parameters buffer Span<byte> The span of bytes to zero out. MemZero<T>(Span<T>) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero<T>(Span<T> buffer) where T : unmanaged Parameters buffer Span<T> The span of bytes to zero out. Type Parameters T MemZero<T>(T[]) Fills a buffer with zeros, effectively erasing its contents. public static void MemZero<T>(T[] buffer) where T : unmanaged Parameters buffer T[] The span of bytes to zero out. Type Parameters T"
  },
  "api/LibSodium.SecurePadding.html": {
    "href": "api/LibSodium.SecurePadding.html",
    "title": "Class SecurePadding | LibSodium.Net",
    "summary": "Class SecurePadding Namespace LibSodium Assembly LibSodium.Net.dll Provides methods for padding and unpadding byte buffers to ensure they meet specified block sizes. public static class SecurePadding Inheritance object SecurePadding Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pad(Span<byte>, int, int) Pads the given buffer to the specified block size. public static Span<byte> Pad(Span<byte> buffer, int unpaddedLen, int blockSize) Parameters buffer Span<byte> The buffer to pad. unpaddedLen int The length of the data before padding. blockSize int The block size to pad to. Returns Span<byte> A span of the padded buffer. Exceptions ArgumentException Thrown when blockSize is less than or equal to 0 or unpaddedLen is greater than buffer length. Unpad(Span<byte>, int) Unpads the given buffer that was padded to a specified block size. public static Span<byte> Unpad(Span<byte> buffer, int blockSize) Parameters buffer Span<byte> The buffer to unpad. blockSize int The block size that was used for padding. Returns Span<byte> A span of the unpadded buffer. Exceptions ArgumentException Thrown when blockSize is less than or equal to 0. LibSodiumException Thrown when unpadding fails."
  },
  "api/LibSodium.UnmanagedMemorySpanHolder-1.html": {
    "href": "api/LibSodium.UnmanagedMemorySpanHolder-1.html",
    "title": "Class UnmanagedMemorySpanHolder<T> | LibSodium.Net",
    "summary": "Class UnmanagedMemorySpanHolder<T> Namespace LibSodium Assembly LibSodium.Net.dll Holds the pointer and length of an unmanaged memory span for later recreation. Use only with unmanaged memory. public class UnmanagedMemorySpanHolder<T> where T : unmanaged Type Parameters T The unmanaged type of the span elements. Inheritance object UnmanagedMemorySpanHolder<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class stores the pointer and length of an unmanaged memory span, allowing for its later reconstruction. It is critical to use this class only with spans pointing to unmanaged memory. Using it with managed or stack-allocated spans will result in undefined behavior and potential memory corruption. This holder is particularly useful when a span needs to be accessed in asynchronous operations, lambda expressions, anonymous methods or other contexts with limited scope, such as after awaiting a task. Constructors UnmanagedMemorySpanHolder(ReadOnlySpan<T>) Initializes a new instance of the UnmanagedMemorySpanHolder<T> class from a read-only span. Use only with unmanaged memory. public UnmanagedMemorySpanHolder(ReadOnlySpan<T> span) Parameters span ReadOnlySpan<T> The read-only span pointing to unmanaged memory. Exceptions ArgumentException Thrown when the span is empty. UnmanagedMemorySpanHolder(Span<T>) Initializes a new instance of the UnmanagedMemorySpanHolder<T> class from a writable span. Use only with unmanaged memory. public UnmanagedMemorySpanHolder(Span<T> span) Parameters span Span<T> The read-only span pointing to unmanaged memory. Exceptions ArgumentException Thrown when the span is empty. Methods GetOriginalReadOnlySpan() Creates a new ReadOnlySpan<T> from the held unmanaged memory representing the original ReadOnlySpan<T>. public ReadOnlySpan<T> GetOriginalReadOnlySpan() Returns ReadOnlySpan<T> A ReadOnlySpan<T> representing the original ReadOnlySpan<T> GetOriginalSpan() Creates a new Span<T> from the held unmanaged memory representing the original Span<T> public Span<T> GetOriginalSpan() Returns Span<T> A Span<T> representing the original Span<T> Exceptions InvalidOperationException The original span was read-only, you cannot get a writable span."
  },
  "api/LibSodium.XChaCha20Poly1305.html": {
    "href": "api/LibSodium.XChaCha20Poly1305.html",
    "title": "Class XChaCha20Poly1305 | LibSodium.Net",
    "summary": "Class XChaCha20Poly1305 Namespace LibSodium Assembly LibSodium.Net.dll Provides high-level access to the XChaCha20-Poly1305 AEAD construction from Libsodium. public static class XChaCha20Poly1305 Inheritance object XChaCha20Poly1305 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class supports both combined and detached modes of authenticated encryption. It also supports automatic nonce generation when not provided explicitly. Properties KeyLen Key length in bytes (32). public static int KeyLen { get; } Property Value int MacLen MAC length in bytes (16). public static int MacLen { get; } Property Value int NonceLen Nonce length in bytes (24). public static int NonceLen { get; } Property Value int Methods Decrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Decrypts a message using XChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Decrypt(Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters plaintext Span<byte> The buffer where the decrypted message will be written. ciphertext ReadOnlySpan<byte> The encrypted message. May include MAC and nonce (combined) or exclude them (detached). key ReadOnlySpan<byte> The secret decryption key (32 bytes). mac ReadOnlySpan<byte> Optional. If provided, decryption is done in detached mode. Otherwise, combined mode is used.. aad ReadOnlySpan<byte> Optional additional authenticated data. Must match what was used for encryption. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). Required for manual nonce mode. Returns Span<byte> The span representing the decrypted plaintext. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when MAC verification fails or decryption fails. Encrypt(Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>, Span<byte>, ReadOnlySpan<byte>, ReadOnlySpan<byte>) Encrypts a message using XChaCha20-Poly1305. Supports combined and detached modes, with optional AAD and nonce. public static Span<byte> Encrypt(Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) Parameters ciphertext Span<byte> The buffer where the ciphertext will be written. It can be longer than needed. plaintext ReadOnlySpan<byte> The message to encrypt. key ReadOnlySpan<byte> The secret encryption key (32 bytes). mac Span<byte> Optional. If provided, the encryption is done in detached mode and the MAC (16 bytes) is written here. Otherwise, combined mode is used. aad ReadOnlySpan<byte> Optional additional authenticated data. Not encrypted, but authenticated. nonce ReadOnlySpan<byte> Optional nonce (24 bytes). If not provided, a random nonce is generated and prepended. Returns Span<byte> The span representing the full ciphertext, including MAC and possibly nonce. Exceptions ArgumentException Thrown when buffer sizes are incorrect or parameters are invalid. LibSodiumException Thrown when encryption fails."
  },
  "api/LibSodium.html": {
    "href": "api/LibSodium.html",
    "title": "Namespace LibSodium | LibSodium.Net",
    "summary": "Namespace LibSodium Classes Aegis128L Provides high-level access to the AEGIS-128L AEAD construction from Libsodium. Aegis256 Provides high-level access to the AEGIS-256 AEAD construction from Libsodium. Aes256Gcm Provides high-level access to the AES256-GCM AEAD construction from Libsodium. Base64Encoding Provides methods for Base64 encoding and decoding. ChaCha20Poly1305 Provides high-level access to the ChaCha20-Poly1305 AEAD construction from Libsodium. ChaCha20Poly1305Ietf Provides high-level access to the IETF variant of the ChaCha20-Poly1305 AEAD construction from Libsodium. CryptoAuth Provides methods for message authentication using the crypto_auth API from libsodium. CryptoBox Provides high-level access to the Curve25519-based public-key authenticated encryption (crypto_box) from Libsodium. CryptoGenericHash Provides a high-level interface to the libsodium generic hash function, based on BLAKE2b. CryptoPasswordHash Provides password hashing and key derivation using Argon2. CryptoSecretStream The CryptoSecretStream class provides methods for performing authenticated encryption and decryption of data streams, with optional additional authenticated data. It is based on the XChaCha20-Poly1305 algorithm. CryptoShortHash Provides a high-level interface to the libsodium short-input hash function, based on SipHash-2-4. CryptoSign Provides digital signature functionality using Ed25519, as implemented by libsodium. HexEncoding Provides methods for encoding and decoding hexadecimal strings and byte buffers. LibSodiumException Represents errors that occur during Sodium operations. LibraryInitializer Static class that manages the initialization and configuration of libsodium. LibraryVersion Provides methods to retrieve the version information of the Sodium library. RandomGenerator Static class for random number generation. SecretBox Provides static methods for authenticated symmetric encryption and decryption using the Sodium secretbox primitives, specifically the XSalsa20 stream cipher and Poly1305 MAC for authentication. These methods offer combined encryption/authentication and detached encryption/authentication, with variations for handling nonces and Message Authentication Codes (MACs) within or separate from the ciphertext. SecretStream Provides high-level, stream-based authenticated encryption and decryption using the XChaCha20-Poly1305 algorithm. This class abstracts the complexity of securely processing large data streams, including chunking, authentication, and cryptographic state management. SecureBigUnsignedInteger Provides methods for working with arbitrary large little endian big unsigned integers in a secure way (constant time for a given length) SecureMemory Provides methods for secure memory management using libsodium. These methods help protect sensitive data from being swapped to disk or accessed by other processes. SecureMemory<T> Provides a secure unmanaged memory buffer for unmanaged types, using libsodium for memory protection. This class encapsulates secure memory allocation, read-only protection, and zeroing. SecurePadding Provides methods for padding and unpadding byte buffers to ensure they meet specified block sizes. UnmanagedMemorySpanHolder<T> Holds the pointer and length of an unmanaged memory span for later recreation. Use only with unmanaged memory. XChaCha20Poly1305 Provides high-level access to the XChaCha20-Poly1305 AEAD construction from Libsodium. Enums Base64Variant Represents Base64 encoding variants. CryptoSecretStreamTag The tags used in the secret stream. PasswordHashAlgorithm Supported password hashing algorithms."
  },
  "features.html": {
    "href": "features.html",
    "title": "Features | LibSodium.Net",
    "summary": "Features LibSodium.Bindings.Net is designed to eventually support all of libsodium’s features while offering a modern and efficient approach to cryptographic operations Modern and Efficient Utilizes Span<T> instead of arrays for enhanced performance. Supports Ahead-of-Time (AOT) compilation by leveraging LibraryImport rather than DllImport. Implemented Features Helpers Constant-time equality testing Hexadecimal encoding and decoding. Base64 encoding and decoding Operations for arbitrary-length unsigned numbers. Testing for all-zero values. Pading Pad and unpad data using the ISO/IEC 7816-4 padding algorithm Secure Memory Zeroing memory Locking memory Guarded heap allocations. Generating random data Random UInt32 , including uniform with upper bound. Random buffer generation, including deterministic option. Closing and stirring the random generator Secret-Key Cryptography Authenticated encryption (SecretBox) Encrypted streams and file encryption Additional Features Coming soon"
  },
  "guide.html": {
    "href": "guide.html",
    "title": "\uD83D\uDD10 Introduction to LibSodium.Net | LibSodium.Net",
    "summary": "\uD83D\uDD10 Introduction to LibSodium.Net LibSodium.Net provides .NET developers with easy-to-use bindings for libsodium, a powerful, modern cryptography library widely recognized for its simplicity and security. This makes it straightforward to add robust cryptographic functionality to your .NET applications. ✨ Why LibSodium.Net? Cross-platform: Seamless support across Windows, Linux, and macOS. Modern Cryptography: Includes authenticated encryption, public-key cryptography, hashing, key derivation, and digital signatures. Simple and Secure API: Designed to reduce complexity, helping you implement cryptography correctly and securely. Secure Memory Handling: Sensitive data management to minimize risks like memory leaks or data exposure. Span over Arrays : Optimized for performance and memory efficiency by using Span<T> instead of heap-allocated arrays. AOT Compatible: Uses LibraryImport (source-generated P/Invoke) instead of DllImport, making it fully compatible with AOT compilation environments. \uD83D\uDE80 Getting Started with LibSodium.Net Here's how you can quickly integrate LibSodium.Net into your .NET projects. \uD83D\uDCE6 Install via NuGet You can easily install LibSodium.Net using the NuGet package manager: CLI Using the .NET CLI: dotnet add package LibSodium.Net Visual Studio Right-click your project in Solution Explorer. Choose Manage NuGet Packages. Search for LibSodium.Net and click Install. Package Manager Console Install-Package LibSodium.Net \uD83E\uDDF1 SecretBox The SecretBox API in LibSodium.Net provides a simple and secure way to perform symmetric authenticated encryption using the XSalsa20 stream cipher and Poly1305 MAC. It supports both combined and detached encryption modes. \uD83D\uDD10 SecretBox Features Symmetric authenticated encryption using XSalsa20-Poly1305 Support for combined and detached modes Automatic or manual nonce handling Tamper-proof via MAC verification \uD83D\uDD12 Encrypting and Decrypting Messages ✅ Combined Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Hello, secure world!\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen]; // Encrypt var result = SecretBox.EncryptCombined(ciphertext, plaintext, key, nonce); // Decrypt Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, result, key, nonce); Console.WriteLine(Encoding.UTF8.GetString(recovered)); ✅ Combined Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce mode test\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen + SecretBox.NonceLen]; var encrypted = SecretBox.EncryptCombined(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var recovered = SecretBox.DecryptCombined(decrypted, encrypted, key); Console.WriteLine(Encoding.UTF8.GetString(recovered)); \uD83E\uDDE9 Detached Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached mode message\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key, nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac, nonce); Console.WriteLine(Encoding.UTF8.GetString(output)); \uD83E\uDDE9 Detached Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto-nonce detached mode\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.NonceLen]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.EncryptDetached(ciphertext, mac, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; var output = SecretBox.DecryptDetached(decrypted, ciphertext, key, mac); Console.WriteLine(Encoding.UTF8.GetString(output)); ⚠️ Error Handling SecretBox methods throw: ArgumentException — if inputs are the wrong size. LibSodiumException — if decryption fails due to tampering or incorrect keys. \uD83D\uDCCC Notes Always use a new random nonce for each encryption. Decryption verifies the MAC before returning plaintext. Use RandomGenerator.Fill() to securely fill nonces and keys. SecretStream The SecretStream class in LibSodium.Net provides secure, authenticated stream-based encryption and decryption using the XChaCha20-Poly1305 algorithm. It's designed to handle large streams of data efficiently and securely. Key Features Authenticated encryption ensures data integrity. Automatic chunking and handling of large data streams. Secure random key generation. Protection against nonce reuse. Basic Usage 1. Generating a Secret Key A secret key must be securely generated and managed: byte[] key = new byte[CryptoSecretStream.KeyLen]; CryptoSecretStream.GenerateKey(key); 2. Encrypting Data Encrypting data streams: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); await SecretStream.EncryptAsync(inputFile, encryptedFile, key); Synchronous Encryption: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); SecretStream.Encrypt(inputFile, encryptedFile, key); 3. Decrypting Data Decrypting the encrypted data back to plaintext: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); await SecretStream.DecryptAsync(encryptedFile, decryptedFile, key); Synchronous Decryption: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); SecretStream.Decrypt(encryptedFile, decryptedFile, key); Security Considerations Secure Key Management: Protect your keys; losing them or exposing them compromises security. Nonce Management: Handled internally by SecretStream; avoid manual nonce reuse. Integrity Checks: Automatic using Poly1305 tags; any tampering results in exceptions. Error Handling Encryption and decryption throw specific exceptions for error conditions: ArgumentException: Invalid arguments (wrong key length, null streams). LibSodiumException: Authentication failed, typically from tampered data. Performance Considerations SecretStream processes data in chunks (default: 64KB) for optimal balance between memory usage and performance. Utilize asynchronous methods (EncryptAsync/DecryptAsync) for IO-bound scenarios for better scalability. \uD83D\uDEE1️ SecureMemory When working with cryptographic data, it's essential to ensure that sensitive information doesn't get leaked through memory dumps, swapping, or garbage collection. LibSodium.Net provides SecureMemory and SecureMemory<T> as robust tools to manage sensitive data safely in unmanaged memory. These APIs leverage libsodium's sodium_malloc, sodium_mlock, and related memory protection functions to offer secure, optionally read-only memory regions that are wiped on disposal. \uD83E\uDDE9 SecureMemory<T> SecureMemory<T> is a managed wrapper around unmanaged memory that stores a span of unmanaged type T. It ensures: Memory is allocated using sodium_allocarray. Memory is wiped with sodium_memzero on disposal. Optional read-only protection using ProtectReadOnly(). Optional read-write toggle with ProtectReadWrite(). Safe access through Span<T>, Memory<T>, ReadOnlySpan<T>, and ReadOnlyMemory<T>. ✅ Basic Usage using var secure = SecureMemory.Create<byte>(32); // Allocate secure memory var span = secure.AsSpan(); // Write access RandomGenerator.Fill(span); // Fill with sensitive data secure.ProtectReadOnly(); // Make it read-only var readOnly = secure.AsReadOnlySpan(); // Safe read-only view secure.ProtectReadWrite(); // Allow writing again \uD83D\uDD12 Safety Features Accessing a SecureMemory<T> object after disposal throws ObjectDisposedException. Accessing writable span when read-only throws InvalidOperationException. Any span or memory obtained prior to disposal becomes invalid. Using it after the object is disposed may result in AccessViolationException. Writing through a span obtained before marking the memory as read-only will throw an AccessViolationException. Memory is finalized and securely freed if not explicitly disposed. \uD83D\uDD27 SecureMemory Utilities SecureMemory also provides utility methods for working with unmanaged memory spans directly: \uD83D\uDD10 Allocate Secure Buffers var span = SecureMemory.Allocate<byte>(64); // Use span... SecureMemory.Free(span); // Free when done All allocations are initialized with 0xDB for predictable testing. \uD83D\uDD10 Zeroing Buffers byte[] buffer = { 1, 2, 3 }; SecureMemory.MemZero(buffer); // Zeros array securely \uD83D\uDD10 Lock/Unlock Memory var span = SecureMemory.Allocate<byte>(128); SecureMemory.MemLock(span); // Prevents swapping to disk SecureMemory.MemUnlock(span); SecureMemory.Free(span); \uD83D\uDD10 Read-Only & Read-Write Protections var span = SecureMemory.Allocate<long>(4); var readOnlySpan = SecureMemory.ProtectReadOnly(span); var writableSpan = SecureMemory.ProtectReadWrite(readOnlySpan); ⚠️ Security Considerations Do not pass managed memory (e.g., new byte[1024]) to Free(). Doing so can corrupt memory. Secure memory functions work only with unmanaged memory allocated by SecureMemory.Allocate(). Avoid using spans or memory references after the backing SecureMemory<T> has been disposed; doing so can cause undefined behavior or AccessViolationException. Writing to memory through a previously obtained span after calling ProtectReadOnly() will throw an AccessViolationException. Always dispose SecureMemory<T> when done, or use using to ensure cleanup. ✅ Unit-Tested Reliability The implementation is backed by comprehensive tests ensuring: Memory is initialized to 0xDB for testing predictability Read-only enforcement and write protection Exception safety on misuse Proper finalization and disposal semantics SecureMemory APIs are essential for handling secrets like keys, passwords, or tokens securely. They give you granular control over how and when memory is allocated, accessed, and cleared—adding another layer of defense in your cryptographic applications."
  },
  "guide/AEAD.html": {
    "href": "guide/AEAD.html",
    "title": "\uD83D\uDD10 AEAD Algorithms | LibSodium.Net",
    "summary": "\uD83D\uDD10 AEAD Algorithms LibSodium.Net provides a unified API for all AEAD (Authenticated Encryption with Associated Data) constructions available in libsodium. These algorithms offer both confidentiality and authenticity, and support optional additional data (AAD) for contextual authentication. Each algorithm supports both combined mode (MAC is part of the ciphertext) and detached mode (MAC is separate), and allows automatic or manual nonce handling. \uD83E\uDDC2 Based on libsodium's AEAD constructions ⚖️ Algorithm Comparison (len in bytes) Algorithm KeyLen NonceLen MacLen XChaCha20-Poly1305 32 24 16 ChaCha20-Poly1305-IETF 32 12 16 ChaCha20-Poly1305 32 8 16 AES256-GCM 32 12 16 AEGIS-256 32 32 32 AEGIS-128L 32 16 32 \uD83D\uDDDD️ Encrypting and Decrypting Use the Encrypt and Decrypt methods from any LibSodium.<Algorithm> class. The API automatically chooses combined or detached mode based on the presence of the optional mac parameter. All AEAD algorithms share the same API: public static Span<byte> Encrypt( Span<byte> ciphertext, ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> key, Span<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) public static Span<byte> Decrypt( Span<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> key, ReadOnlySpan<byte> mac = default, ReadOnlySpan<byte> aad = default, ReadOnlySpan<byte> nonce = default) \uD83D\uDCCB Example 1: AEGIS-256 (Combined mode with auto nonce and AAD) Span<byte> key = stackalloc byte[Aegis256.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Secret message\"); var aad = Encoding.UTF8.GetBytes(\"authenticated context\"); var ciphertext = new byte[plaintext.Length + Aegis256.MacLen + Aegis256.NonceLen]; Aegis256.Encrypt(ciphertext, plaintext, key, aad: aad); var decrypted = new byte[plaintext.Length]; Aegis256.Decrypt(decrypted, ciphertext, key, aad: aad); SecureMemory.MemZero(key); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Example 2: ChaCha20-Poly1305 (Combined mode with AAD, incrementing manual nonce to prevent reuse) Span<byte> key = stackalloc byte[ChaCha20Poly1305.KeyLen]; Span<byte> nonce = stackalloc byte[ChaCha20Poly1305.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var aad = Encoding.UTF8.GetBytes(\"v1\"); var message1 = Encoding.UTF8.GetBytes(\"First message\"); var ciphertext1 = new byte[message1.Length + ChaCha20Poly1305.MacLen]; ChaCha20Poly1305.Encrypt(ciphertext1, message1, key, aad: aad, nonce: nonce); SecureBigUnsignedInteger.Increment(nonce); // increment to prevent reuse (nonce is only 8 bytes) var message2 = Encoding.UTF8.GetBytes(\"Second message\"); var ciphertext2 = new byte[message2.Length + ChaCha20Poly1305.MacLen]; ChaCha20Poly1305.Encrypt(ciphertext2, message2, key, aad: aad, nonce: nonce); SecureMemory.MemZero(key); ⚠️ Error Handling ArgumentException — invalid input lengths or buffer sizes. LibSodiumException — authentication failure (e.g., tampered data). \uD83D\uDCDD Notes All optional parameters (mac, aad, nonce) should be passed using named arguments for clarity and safety (e.g., aad: data). Nonces must match the algorithm's required length. If omitted, a random nonce is generated automatically and prepended to the ciphertext. Buffers must be large enough to hold output. AAD is optional, but highly recommended. Combined mode includes the MAC within the ciphertext. \uD83D\uDC40 See Also libsodium AEAD constructions API Reference"
  },
  "guide/CryptoAuth.html": {
    "href": "guide/CryptoAuth.html",
    "title": "\uD83D\uDCDC CryptoAuth | LibSodium.Net",
    "summary": "\uD83D\uDCDC CryptoAuth The CryptoAuth API in LibSodium.Net provides secure message authentication using HMAC-SHA-512-256. This is useful for ensuring that a message was not altered and comes from a trusted sender who knows the secret key. \uD83E\uDDC2 Based on libsodium’s Secret Key Authentication crypto_auth API ℹ️ See also: API Reference for CryptoAuth \uD83C\uDF1F Features Message authentication using HMAC-SHA-512-256. Fixed-length secret keys and MACs. Strong tampering detection. Safe and efficient API using Span<T>. Fully interoperable with libsodium's crypto_auth functions. \uD83D\uDD0D What is Message Authentication? Unlike encryption, authentication doesn't hide the contents of a message. It ensures that the message has not been tampered with and was created by someone who knows the shared secret key. This is useful for protocols that need to validate integrity and authenticity but don't require confidentiality. CryptoAuth uses: HMAC-SHA-512-256: a strong MAC algorithm with 32-byte output. A 32-byte key shared between sender and receiver. ✨Usage Examples \uD83D\uDCCB Key Generation Span<byte> key = stackalloc byte[CryptoAuth.KeyLen]; CryptoAuth.GenerateKey(key); \uD83D\uDCCB MAC Generation Span<byte> mac = stackalloc byte[CryptoAuth.MacLen]; ReadOnlySpan<byte> message = Encoding.UTF8.GetBytes(\"Message to authenticate\"); CryptoAuth.ComputeMac(mac, message, key); \uD83D\uDCCB MAC Verification bool isValid = CryptoAuth.TryVerifyMac(mac, message, key); if (isValid) { Console.WriteLine(\"MAC is valid.\"); } else { Console.WriteLine(\"MAC is invalid!\"); } \uD83D\uDCCB Strict Verification (throws on failure) CryptoAuth.VerifyMac(mac, message, key); // Throws LibSodiumException if verification fails ⚠️ Error Handling ArgumentException — input buffers are incorrect length. LibSodiumException — MAC computation or verification failed unexpectedly. \uD83D\uDCDD Notes The MAC is 32 bytes (CryptoAuth.MacLen). The secret key must be exactly 32 bytes (CryptoAuth.KeyLen). This API does not encrypt your message, only authenticates it. Use RandomGenerator.Fill() or CryptoAuth.GenerateKey() to create secure keys. Never reuse keys across different algorithms or protocols."
  },
  "guide/CryptoBox.html": {
    "href": "guide/CryptoBox.html",
    "title": "\uD83D\uDEE1️ Public-Key Authenticated Encryption with CryptoBox | LibSodium.Net",
    "summary": "\uD83D\uDEE1️ Public-Key Authenticated Encryption with CryptoBox The CryptoBox API securely encrypts messages between two parties using public-key cryptography. The sender and the recipient each have a key pair, and the message is both encrypted and authenticated. Internally, it uses Curve25519 for key exchange, XSalsa20 for encryption, and Poly1305 for authentication. It supports both combined and detached modes, encryption using either a keypair or a precomputed shared key, and offers automatic or manual nonce handling — all through a unified, ergonomic API. \uD83E\uDDC2Based on libsodium's Authenticated encryption using crypto_box ℹ️ See also: API Reference for CryptoBox \uD83C\uDF1F Features Authenticated encryption with public-key cryptography. Curve25519 key exchange + XSalsa20-Poly1305 encryption. Combined and detached modes. Keypair or shared-key based encryption. Manual or automatic nonce handling. Unified API with optional parameters. Fully Span<T>-based, safe and efficient. \uD83D\uDCCF Constants Name Value Description PublicKeyLen 32 Length of a Curve25519 public key PrivateKeyLen 32 Length of a Curve25519 private key SharedKeyLen 32 Length of a precomputed shared key NonceLen 24 Length of the nonce MacLen 16 Length of the authentication tag SeedLen 32 Length of a deterministic seed \uD83D\uDDDD️ Key Management \uD83D\uDCCB Generate Keypair Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(publicKey, privateKey); \uD83D\uDCCB Deterministic Keypair from Seed Span<byte> seed = stackalloc byte[CryptoBox.SeedLen]; Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypairDeterministically(publicKey, privateKey, seed); \uD83D\uDCCB Precompute Shared Key Span<byte> sharedKey = stackalloc byte[CryptoBox.SharedKeyLen]; CryptoBox.CalculateSharedKey(sharedKey, peerPublicKey, myPrivateKey); ✨ Encrypting and Decrypting Messages The API provides two symmetric pairs: EncryptWithKeypair(...) uses the recipient's public key and sender's private key, while DecryptWithKeypair(...) uses the sender's public key and recipient's private key. EncryptWithSharedKey(...) / DecryptWithSharedKey(...) — use a precomputed shared key. Each pair supports combined and detached modes, and optional manual nonce input. \uD83D\uDCCB Combined Mode (Keypair, Auto Nonce) Span<byte> recipientPk = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> recipientSk = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(recipientPk, recipientSk); Span<byte> senderPk = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> senderSk = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(senderPk, senderSk); var message = Encoding.UTF8.GetBytes(\"Hello, world!\"); Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPk, senderSk); Span<byte> decrypted = stackalloc byte[message.Length]; CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPk, recipientSk); \uD83D\uDCCB Detached Mode (Keypair, Manual Nonce) Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPk, senderSk, mac, nonce); CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPk, recipientPk, mac, nonce); \uD83D\uDCCB Combined Mode (Shared Key, Auto Nonce) Span<byte> sharedKey = stackalloc byte[CryptoBox.SharedKeyLen]; // usually calculated with CalculateSharedKey() Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey); \uD83D\uDCCB Detached Mode (Shared Key, Manual Nonce) Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey, mac, nonce); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey, mac, nonce); ⚠️ Error Handling ArgumentException — invalid input sizes. LibSodiumException — authentication failed or encryption/decryption error. \uD83D\uDCDD Notes In combined mode, the MAC is prepended to the ciphertext. In detached mode, the MAC is returned separately. If you omit the nonce, a secure random one is generated and prepended to the ciphertext. Use EncryptWithKeypair / DecryptWithKeypair for sender-recipient encryption. Use EncryptWithSharedKey / DecryptWithSharedKey when a shared key has been derived beforehand. Always check decrypted data — authentication failure throws. \uD83D\uDC40 See Also libsodium crypto_box documentation API Reference"
  },
  "guide/DesignPhilosophy.html": {
    "href": "guide/DesignPhilosophy.html",
    "title": "\uD83E\uDDED Design Philosophy | LibSodium.Net",
    "summary": "\uD83E\uDDED Design Philosophy LibSodium.Net is built around a simple but powerful idea: Expose all of libsodium’s capabilities exactly as they are, without hiding anything, while making them ergonomic for .NET developers. \uD83D\uDD0D Transparent We don’t reinvent cryptographic primitives. We expose them as they are implemented in libsodium, preserving their guarantees, formats, and conventions. ⚙️ Ergonomic Our API is intuitive and natural in .NET: Full support for Span<byte> and ReadOnlySpan<byte> Combined and detached modes Optional automatic nonce generation Additional authenticated data (AAD) Clear exceptions and strict input validation \uD83D\uDD13 No unnecessary abstractions We don’t force you to wrap keys into opaque classes like Key. You decide how to handle secrets: stackalloc, byte[], derived keys, externally injected material, etc. If you need a higher-level abstraction, you’re free to build one on top of our minimal, consistent API. \uD83C\uDFAF Unopinionated by design LibSodium.Net is not opinionated. It doesn’t tell you how to structure your cryptography — it simply gives you the tools to do it right. \uD83E\uDDEA Built for Developers who want to understand and control what’s happening under the hood. Projects that need to interoperate with other libsodium implementations (in C, Rust, Go, etc.). Systems with flexible key management (e.g. key derivation, ephemeral keys, external sources). Teams who value an API that’s simple, secure, and predictable."
  },
  "guide/Encoding.html": {
    "href": "guide/Encoding.html",
    "title": "✏️ Encoding | LibSodium.Net",
    "summary": "✏️ Encoding LibSodium.Net provides high-performance, secure encoding utilities to convert binary data to and from human-readable formats. The library currently supports two types of encoding: Hexadecimal via HexEncoding Base64 via Base64Encoding These classes are wrappers around libsodium's encoding utilities, providing constant-time and safe operations using spans. \uD83E\uDDC2 Based on libsodium’s Hexadecimal encoding/decoding and Base64 encoding/decoding ℹ️ See also: API Reference for HexEncoding, API Reference for Base64Encoding \uD83D\uDD10 Security Considerations These encoding functions are implemented in constant time with respect to input size, which means they avoid data-dependent branching and timing variations. This makes them resistant to side-channel attacks, such as timing attacks, which can leak information through observable differences in computation time. LibSodium.Net ensures that these security properties are preserved in its managed API by: Using Span<T> and avoiding intermediate heap allocations. Delegating directly to libsodium’s hardened, constant-time implementations. These properties make HexEncoding and Base64Encoding suitable for encoding sensitive data like cryptographic keys, hashes, tokens, and other secrets. ✨ HexEncoding HexEncoding provides methods to encode a byte array into a lowercase hexadecimal string and decode from hexadecimal back into binary. All operations are span-based for performance and safety. \uD83D\uDCCB Encode to hex Span<byte> bin = stackalloc byte[] { 0x01, 0x23, 0x45 }; string hex = HexEncoding.BinToHex(bin); // \"012345\" You can also write the hex into a preallocated Span<char>: Span<char> hexBuffer = stackalloc char[bin.Length * 2]; HexEncoding.BinToHex(bin, hexBuffer); \uD83D\uDCCB Decode from hex string hex = \"0123456789abcdef\"; Span<byte> buffer = stackalloc byte[hex.Length / 2]; HexEncoding.HexToBin(hex, buffer); You can also ignore separators such as colons: string formatted = \"01:23:45:67\"; HexEncoding.HexToBin(formatted, buffer, \":\"); ⚠️ Exceptions ArgumentException: when hex buffer is too small. LibSodiumException: on malformed hex input or destination buffer too small. ✨ Base64Encoding Base64Encoding supports multiple Base64 variants, including URL-safe and no-padding modes. \uD83D\uDCD8 Base64 variants public enum Base64Variant { Original, OriginalNoPadding, UrlSafe, UrlSafeNoPadding } These map directly to sodium_base64_VARIANT_* in libsodium. \uD83D\uDCCB Encode to Base64 Span<byte> bin = stackalloc byte[] { 1, 2, 3, 4 }; string b64 = Base64Encoding.BinToBase64(bin, Base64Variant.Original); You can also write the result into a Span<char>: Span<char> buffer = stackalloc char[Base64Encoding.GetBase64EncodedLen(bin.Length, Base64Variant.Original)]; Base64Encoding.BinToBase64(bin, buffer, Base64Variant.Original); \uD83D\uDCCB Decode from Base64 string b64 = \"AQIDBA==\"; Span<byte> output = stackalloc byte[Base64Encoding.GetBase64DecodedMaxLen(b64.Length)]; Base64Encoding.Base64ToBin(b64, output, Base64Variant.Original); Optional ignored characters (e.g., formatting spaces): Base64Encoding.Base64ToBin(\" AQ ID BA == \", output, Base64Variant.Original, \" \"); ⚠️ Exceptions ArgumentException: buffer too small. LibSodiumException: invalid Base64 input or mismatched variant. These encoding utilities are highly optimized, secure, and suitable for cryptographic applications where constant-time guarantees and low-level memory control are essential."
  },
  "guide/Hashing.V0.html": {
    "href": "guide/Hashing.V0.html",
    "title": "\uD83D\uDD00 Hashing | LibSodium.Net",
    "summary": "\uD83D\uDD00 Hashing LibSodium.Net provides two high-level APIs for hashing: GenericHash — a flexible cryptographic hash function based on BLAKE2b ShortHash — a fast keyed hash function based on SipHash-2-4 Both are designed for different purposes: Use GenericHash for cryptographic hashing tasks such as content integrity, MAC derivation, or generating deterministic fingerprints. It is not suitable for password hashing Use ShortHash to protect hash tables against collision-based DoS attacks, using a secret key known only to the application \uD83E\uDDC2 Based on libsodium's Hashing ℹ️ API Reference: CryptoGenericHash ℹ️ API Reference: CryptoShortHash \uD83C\uDF1F Features Cryptographic hashing with variable output length (GenericHash) SipHash-based keyed hash for short inputs (ShortHash) All methods are allocation-free, Span-based, and deterministic Stream and async support for large input hashing (GenericHash) ✨ GenericHash — BLAKE2b A secure, cryptographic hash function. \uD83D\uDCCF Constants Name Value Description HashLen 32 Default output length MinHashLen 16 Minimum output length MaxHashLen 64 Maximum output length KeyLen 32 Default key length MinKeyLen 16 Minimum key length MaxKeyLen 64 Maximum key length \uD83D\uDCCB Hash with optional key Span<byte> hash = stackalloc byte[CryptoGenericHash.HashLen]; CryptoGenericHash.ComputeHash(hash, message); // unkeyed CryptoGenericHash.ComputeHash(hash, message, key); // keyed \uD83D\uDCCB Hash from a stream using var stream = File.OpenRead(\"large-input.dat\"); CryptoGenericHash.ComputeHash(hash, stream); \uD83D\uDCCB Async stream support using var stream = File.OpenRead(\"large-input.dat\"); await CryptoGenericHash.ComputeHashAsync(hash, stream); ✨ ShortHash — SipHash-2-4 Fast, fixed-size keyed hash designed for short messages. Ideal for protecting hash tables. \uD83D\uDCCF Constants Name Value Description HashLen 8 Output length (8 bytes) KeyLen 16 Key length (16 bytes) \uD83D\uDCCB Hash with key Span<byte> hash = stackalloc byte[CryptoShortHash.HashLen]; CryptoShortHash.ComputeHash(hash, message, key); ⚠️ Error Handling ArgumentException — when input or key lengths are invalid LibSodiumException — if the underlying native function fails \uD83D\uDCDD Notes GenericHash is based on BLAKE2b and supports variable-length output and optional keys ShortHash is based on SipHash-2-4 — not a cryptographic hash function, but a keyed primitive appropriate for protecting hash tables against collision-based attacks. All hash functions are deterministic: same input and key produce same output Use ShortHash only when you can keep the key secret \uD83D\uDC40 See Also API Reference: CryptoGenericHash API Reference: CryptoShortHash libsodium.org Hashing"
  },
  "guide/Hashing.html": {
    "href": "guide/Hashing.html",
    "title": "\uD83D\uDD00 Hashing | LibSodium.Net",
    "summary": "\uD83D\uDD00 Hashing LibSodium.Net provides multiple hashing APIs for different use cases: API Algorithm Use Case GenericHash BLAKE2b Cryptographic hash with optional key. Use for MAC, PRF, fingerprints. ShortHash SipHash-2-4 Keyed hash designed to prevent collisions in hash tables. Fast for short inputs. CryptoPasswordHash Argon2id/i13 Password hashing and key derivation (slow & memory hard) \uD83E\uDDC2 Based on libsodium's Hashing and Password Hashing ℹ️ API Reference: CryptoGenericHash ℹ️ API Reference: CryptoShortHash ℹ️ API Reference: CryptoPasswordHash \uD83C\uDF1F Features Cryptographic hashing with variable output length (GenericHash) SipHash-based keyed hash for short inputs (ShortHash) Password hashing and key derivation using Argon2 (CryptoPasswordHash) All methods are allocation-free, Span-based, and deterministic (except password hash, which is randomized) Stream and async support for large input hashing (GenericHash) ✨ GenericHash — BLAKE2b BLAKE2b is a cryptographic hash function designed as a faster and safer alternative to SHA-2. It provides high-performance hashing with optional key support, making it suitable for: Cryptographic checksums (fingerprints) Message authentication codes (MACs) Deriving identifiers or integrity tags Hashing files or streams of arbitrary size Unique deterministic identifiers Pseudorandom functions (PRF) when keyed By default, it produces 32-byte output, but can be configured to return between 16 and 64 bytes. It supports keyed hashing for MAC-like behavior, or unkeyed hashing for general-purpose hashing. \uD83D\uDCCF Constants Name Value Description HashLen 32 Default output length MinHashLen 16 Minimum output length MaxHashLen 64 Maximum output length KeyLen 32 Default key length MinKeyLen 16 Minimum key length MaxKeyLen 64 Maximum key length \uD83D\uDCCB Hash with optional key Span<byte> hash = stackalloc byte[CryptoGenericHash.HashLen]; CryptoGenericHash.ComputeHash(hash, message); // unkeyed CryptoGenericHash.ComputeHash(hash, message, key); // keyed (MAC or PRF) \uD83D\uDCCB Hash from a stream using var stream = File.OpenRead(\"large-input.dat\"); CryptoGenericHash.ComputeHash(hash, stream); \uD83D\uDCCB Async stream support using var stream = File.OpenRead(\"large-input.dat\"); await CryptoGenericHash.ComputeHashAsync(hash, stream); ✨ ShortHash — SipHash-2-4 ⚠️ ShortHash is not a cryptographic hash. Do not use it for fingerprinting, content integrity, password hashing, or digital signatures. SipHash is a fast keyed hash function optimized for short inputs. It is designed to mitigate hash-flooding attacks in hash tables and similar data structures where untrusted input might lead to performance degradation. It should be used for: Hash table key protection Fast authentication of short data Use cases where speed and DoS-resistance are more important than collision resistance SipHash is always keyed, and its output is always 8 bytes. \uD83D\uDCCF Constants Name Value Description HashLen 8 Output length (8 bytes) KeyLen 16 Key length (16 bytes) \uD83D\uDCCB Hash with key Span<byte> hash = stackalloc byte[CryptoShortHash.HashLen]; CryptoShortHash.ComputeHash(hash, message, key); ✨ PasswordHash — Argon2id / Argon2i13 Secure password hashing and key derivation using Argon2. This algorithm is specifically designed to defend against brute-force attacks by requiring significant computational work and memory. It is ideal for storing passwords, deriving keys from passphrases, or implementing authentication mechanisms. Unlike fast cryptographic hash functions (like SHA-256 or BLAKE2b), Argon2 is deliberately slow and memory-intensive, which drastically increases the cost of large-scale password cracking (e.g., GPU attacks). LibSodium.Net exposes both Argon2id (recommended) and Argon2i. The cost parameters (iterations and memory) can be tuned to balance security and performance depending on the context: Interactive: suitable for login forms. Moderate: for higher value secrets. Sensitive: for long-term or critical secrets. \uD83D\uDCCF Constants Name Value Description SaltLen 16 Length of the salt in bytes MinKeyLen 16 Minimum key length for derivation EncodedLen 128 Length of the encoded hash string Prefix \"$argon2id$\" Prefix for Argon2id encoded hash InteractiveIterations 2 Iteration count for interactive targets InteractiveMemoryLen 64 MB Memory usage for interactive targets SensitiveIterations 4 Iteration count for sensitive targets SensitiveMemoryLen 1 GB Memory usage for sensitive targets MinMemoryLen 8 KB Minimum acceptable memory for hashing \uD83D\uDCCB Hash a password (encoded, random salt) string hash = CryptoPasswordHash.HashPassword(\"my password\"); \uD83D\uDCCB Verify a password bool valid = CryptoPasswordHash.VerifyPassword(hash, \"my password\"); \uD83D\uDCCB Derive a secret key from a password (e.g. for encryption) Span<byte> key = stackalloc byte[32]; Span<byte> salt = stackalloc byte[CryptoPasswordHash.SaltLen]; RandomGenerator.Fill(salt); CryptoPasswordHash.DeriveKey(key, \"password\", salt); You can customize the computational cost: CryptoPasswordHash.DeriveKey( key, \"password\", salt, iterations: CryptoPasswordHash.SensitiveIterations, requiredMemoryLen: CryptoPasswordHash.SensitiveMemoryLen); ⚠️ Error Handling ArgumentException — when input or key lengths are invalid ArgumentOutOfRangeException — when iterations or memory limits are too low LibSodiumException — if the underlying native function fails \uD83D\uDCDD Notes GenericHash is based on BLAKE2b and supports variable-length output and optional keys. It is suitable for both fingerprinting, MACs, PRFs, and unique identifier generation. ShortHash is based on SipHash-2-4 — not a cryptographic hash function, but a keyed primitive appropriate for protecting hash tables against collision-based attacks. CryptoPasswordHash uses Argon2id/Argon2i13, with computational and memory hardness All hash functions are deterministic: same input and key produce same output — except for CryptoPasswordHash.HashPassword, which includes a random salt and produces a different hash each time. Use ShortHash only when you can keep the key secret \uD83E\uDDED Choosing the Right Hash API Scenario Recommended API Content integrity (files, blobs) GenericHash (unkeyed) MAC or PRF GenericHash (keyed) Hashing short keys in tables ShortHash Password storage CryptoPasswordHash Key derivation from passphrase CryptoPasswordHash \uD83D\uDC40 See Also API Reference: CryptoGenericHash API Reference: CryptoShortHash API Reference: CryptoPasswordHash libsodium.org Hashing libsodium Password Hashing"
  },
  "guide/PublicKeyCrypto.html": {
    "href": "guide/PublicKeyCrypto.html",
    "title": "\uD83D\uDD11 Public Key Cryptography | LibSodium.Net",
    "summary": "\uD83D\uDD11 Public Key Cryptography LibSodium.Net provides high-level APIs for public-key cryptography based on Curve25519 and Ed25519. This includes secure encryption between peers (CryptoBox), anonymous encryption (Sealed Boxes), and digital signatures (CryptoSign). \uD83E\uDDC2 Based on libsodium's Public-Key Cryptography ℹ️ API Reference: CryptoBox ℹ️ API Reference: CryptoSign \uD83C\uDF1F Features Public-key authenticated encryption (CryptoBox) Anonymous encryption for messages (Sealed Boxes) Digital signatures with Ed25519 (CryptoSign) Span-based APIs for efficient, allocation-free usage ✨ CryptoBox — Authenticated Encryption The CryptoBox API securely encrypts messages between two parties using public-key cryptography. The sender and the recipient each have a key pair, and the message is both encrypted and authenticated. It also supports Sealed Boxes for anonymous encryption, allowing anyone to encrypt a message to a recipient without revealing their identity. Internally, it uses Curve25519 for key exchange, XSalsa20 for encryption, and Poly1305 for authentication. It supports both combined and detached modes, encryption using either a keypair or a precomputed shared key, and offers automatic or manual nonce handling — all through a unified, ergonomic API. \uD83E\uDDC2 Based on libsodium's Authenticated encryption using crypto_box \uD83D\uDC40 API Reference for CryptoBox \uD83D\uDCCF Constants Name Value Description PublicKeyLen 32 Curve25519 public key length PrivateKeyLen 32 Curve25519 private key length SharedKeyLen 32 Precomputed shared key length NonceLen 24 Nonce length MacLen 16 Authentication tag length SealOverheadLen 48 Overhead added by EncryptWithPublicKey \uD83D\uDDDD️ Key Management \uD83D\uDCCB Generate Keypair Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypair(publicKey, privateKey); \uD83D\uDCCB Deterministic Keypair from Seed Span<byte> seed = stackalloc byte[CryptoBox.SeedLen]; Span<byte> publicKey = stackalloc byte[CryptoBox.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoBox.PrivateKeyLen]; CryptoBox.GenerateKeypairDeterministically(publicKey, privateKey, seed); \uD83D\uDCCB Precompute Shared Key Span<byte> sharedKey = stackalloc byte[CryptoBox.SharedKeyLen]; CryptoBox.CalculateSharedKey(sharedKey, otherPartyPublicKey, myPrivateKey); ✨ Encryption Modes \uD83D\uDCCB Encrypt / Decrypt with Keypair (Combined, Auto Nonce) var message = Encoding.UTF8.GetBytes(\"Hello, world!\"); Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPublicKey, senderPrivateKey); Span<byte> decrypted = stackalloc byte[message.Length]; CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPublicKey, recipientPrivateKey); AssertLite.True(decrypted.SequenceEqual(message)); \uD83D\uDCCB Encrypt / Decrypt with Keypair (Detached, Manual Nonce) Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithKeypair(ciphertext, message, recipientPublicKey, senderPrivateKey, mac, nonce); CryptoBox.DecryptWithKeypair(decrypted, ciphertext, senderPublicKey, recipientPublicKey, mac, nonce); \uD83D\uDCCB Encrypt / Decrypt with Shared Key (Combined, Auto Nonce) Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.MacLen + CryptoBox.NonceLen]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey); AssertLite.True(decrypted.SequenceEqual(message)); \uD83D\uDCCB Encrypt / Decrypt with Shared Key (Detached, Manual Nonce) Span<byte> nonce = stackalloc byte[CryptoBox.NonceLen]; Span<byte> mac = stackalloc byte[CryptoBox.MacLen]; Span<byte> ciphertext = stackalloc byte[message.Length]; CryptoBox.EncryptWithSharedKey(ciphertext, message, sharedKey, mac, nonce); CryptoBox.DecryptWithSharedKey(decrypted, ciphertext, sharedKey, mac, nonce); \uD83D\uDCCB Sealed Boxes — Anonymous Encryption Sealed boxes enable anonymous encryption: anyone can encrypt a message to a recipient’s public key without revealing their identity. Internally, a random ephemeral keypair is generated and embedded in the ciphertext. Span<byte> ciphertext = stackalloc byte[message.Length + CryptoBox.SealOverheadLen]; CryptoBox.EncryptWithPublicKey(ciphertext, message, recipientPublicKey); Span<byte> decrypted = stackalloc byte[message.Length]; CryptoBox.DecryptWithPrivateKey(decrypted, ciphertext, recipientPrivateKey); AssertLite.True(decrypted.SequenceEqual(message)); ✨ CryptoSign — Digital Signatures Uses Ed25519 to sign and verify messages. Produces 64-byte signatures. This is useful for verifying authenticity without encryption. \uD83E\uDDC2 See: libsodium crypto_sign \uD83D\uDC40 API Reference for CryptoSign \uD83D\uDCCF Constants Name Value Description PublicKeyLen 32 Ed25519 public key length PrivateKeyLen 64 Ed25519 private key length SignatureLen 64 Signature length SeedLen 32 Seed length for deterministic key \uD83D\uDCCB Generate Keypair Span<byte> publicKey = stackalloc byte[CryptoSign.PublicKeyLen]; Span<byte> privateKey = stackalloc byte[CryptoSign.PrivateKeyLen]; CryptoSign.GenerateKeyPair(publicKey, privateKey); \uD83D\uDCCB Sign and Verify Span<byte> signature = stackalloc byte[CryptoSign.SignatureLen]; CryptoSign.Sign(message, signature, privateKey); bool ok = CryptoSign.TryVerify(message, signature, publicKey); CryptoSign.Verify(message, signature, publicKey); // throws LibSodiumException if the signature is invalid ⚠️ Error Handling ArgumentException — when input buffers have incorrect lengths or invalid parameters. LibSodiumException — when authentication fails or a crypto operation cannot complete. \uD83D\uDCDD Notes Sealed boxes are anonymous: the recipient cannot identify the sender. CryptoBox uses crypto_box_easy internally; CryptoSign uses crypto_sign_detached. All APIs are Span-friendly and do not allocate memory internally. EncryptWithPublicKey prepends a 32-byte ephemeral public key and 16-byte MAC. Use CryptoSign when authentication is required without encryption. \uD83D\uDC40 See Also API Reference: CryptoBox API Reference: CryptoSign libsodium.org Public-Key Crypto"
  },
  "guide/RandomGenerator.html": {
    "href": "guide/RandomGenerator.html",
    "title": "\uD83C\uDFB2 RandomGenerator | LibSodium.Net",
    "summary": "\uD83C\uDFB2 RandomGenerator The RandomGenerator class in LibSodium.Net provides access to cryptographically secure random values. It wraps several functions from libsodium's randombytes API and ensures correct initialization and exception safety. \uD83E\uDDC2Based on libsodium's Generating random data ℹ️ See also: API Reference for RandomGenerator \uD83C\uDF1F Features Generate random 32-bit unsigned integers. Generate bounded random integers. Fill buffers with secure random bytes. Generate deterministic random bytes using a seed. Stir or close the RNG engine as needed. ✨ Getting Random Values \uD83D\uDCCB Get a random 32-bit unsigned integer uint value = RandomGenerator.GetUInt32(); Returns a cryptographically secure, uniformly distributed value. \uD83D\uDCCB Get a random value less than an upper bound uint lessThan100 = RandomGenerator.GetUInt32(100); Returns a value in the range [0, upperBound). Uses a rejection sampling method to ensure uniform distribution. ✨ Filling Buffers \uD83D\uDCCB Fill a buffer with random bytes Span<byte> buffer = stackalloc byte[32]; RandomGenerator.Fill(buffer); This fills the buffer with unpredictable cryptographic random bytes. \uD83D\uDCCB Fill a buffer with deterministic random bytes Span<byte> seed = stackalloc byte[RandomGenerator.SeedLen]; RandomGenerator.Fill(seed); // Generate a secure seed Span<byte> buffer = stackalloc byte[32]; RandomGenerator.FillDeterministic(buffer, seed); The same seed and length will always produce the same output. ⚠️ Seed must be exactly RandomGenerator.SeedLen bytes long. Otherwise, ArgumentException is thrown. ✨ Stirring and Closing the RNG \uD83D\uDCCB Stir the RNG RandomGenerator.Stir(); This reseeds the RNG, recommended after forking a process or when explicitly needed. \uD83D\uDCCB Close the RNG RandomGenerator.Close(); Closes the randombytes subsystem. This may be needed in long-running processes or to release resources. Calling it more than once will throw LibSodiumException. ⚠️ Error Handling ArgumentException — thrown when FillDeterministic receives an invalid seed length. LibSodiumException — thrown when Close() fails (e.g., called twice). The RandomGenerator API is well-suited for cryptographic use cases and follows safe defaults. It gives you access to high-quality random data and control over deterministic randomness when reproducibility is required."
  },
  "guide/SecretBox.html": {
    "href": "guide/SecretBox.html",
    "title": "\uD83D\uDD12 Symmetric Authenticated Encryption with SecretBox | LibSodium.Net",
    "summary": "\uD83D\uDD12 Symmetric Authenticated Encryption with SecretBox The SecretBox API in LibSodium.Net provides a simple and secure way to perform symmetric authenticated encryption using the XSalsa20 stream cipher and Poly1305 MAC. It supports both combined and detached encryption modes, as well as manual or automatic nonce handling — all from a single, unified API. \uD83E\uDDC2Based on libsodium's Authenticated encryption using crypto_secretbox ℹ️ See also: API Reference for SecretBox \uD83C\uDF1F Features Symmetric authenticated encryption using XSalsa20-Poly1305. Combined mode and detached mode support. Automatic or manual nonce handling. Built-in MAC verification (tamper detection). Unified Encrypt / Decrypt API with optional parameters. Safe and efficient Span<T>-based implementation. ✨ Encrypting and Decrypting Messages Use the Encrypt and Decrypt methods. The behavior depends on whether you pass a mac buffer (detached) and/or a nonce (manual). \uD83D\uDCCB Combined Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Hello, auto-nonce world!\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen + SecretBox.NonceLen]; SecretBox.Encrypt(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Combined Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Manual nonce combined\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.MacLen]; SecretBox.Encrypt(ciphertext, plaintext, key, nonce: nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key, nonce: nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Detached Mode (Auto Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Detached + auto nonce\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + SecretBox.NonceLen]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.Encrypt(ciphertext, plaintext, key, mac); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key, mac); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Detached Mode (Manual Nonce) Span<byte> key = stackalloc byte[SecretBox.KeyLen]; Span<byte> nonce = stackalloc byte[SecretBox.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached with nonce\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[SecretBox.MacLen]; SecretBox.Encrypt(ciphertext, plaintext, key, mac, nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; SecretBox.Decrypt(decrypted, ciphertext, key, mac, nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); ⚠️ Error Handling ArgumentException — invalid input sizes. LibSodiumException — authentication failed. \uD83D\uDCDD Notes Nonce must be exactly SecretBox.NonceLen bytes when passed manually. Auto-nonce is prepended to the ciphertext when not specified. Combined mode outputs ciphertext + MAC (+ optional nonce). Detached mode separates MAC from ciphertext. Buffers can be larger than required. Always use RandomGenerator.Fill() for secure key and nonce generation. \uD83D\uDC40 See Also libsodium secretbox documentation API Reference"
  },
  "guide/SecretStream.html": {
    "href": "guide/SecretStream.html",
    "title": "\uD83D\uDD12 Authenticated Stream Encryption with SecretStream | LibSodium.Net",
    "summary": "\uD83D\uDD12 Authenticated Stream Encryption with SecretStream The SecretStream class in LibSodium.Net provides secure, authenticated stream-based encryption and decryption using the XChaCha20-Poly1305 algorithm. It's designed to handle large streams of data efficiently and securely. \uD83E\uDDC2 Based on libsodium's Encrypted streams and file encryption ℹ️ See also: API Reference for SecretStream ✨ Key Features Authenticated encryption ensures data integrity. Automatic chunking and handling of large data streams. Secure random key generation. Protection against nonce reuse. ✨ Basic Usage \uD83D\uDCCB Generating a Secret Key A secret key must be securely generated and managed: byte[] key = new byte[CryptoSecretStream.KeyLen]; CryptoSecretStream.GenerateKey(key); \uD83D\uDCCB Encrypting Data Encrypting data streams asynchronously: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); await SecretStream.EncryptAsync(inputFile, encryptedFile, key); Synchronous Encryption: using var inputFile = File.OpenRead(\"plaintext.dat\"); using var encryptedFile = File.Create(\"encrypted.dat\"); SecretStream.Encrypt(inputFile, encryptedFile, key); \uD83D\uDCCB Decrypting Data Decrypting asynchronously the encrypted data back to plaintext: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); await SecretStream.DecryptAsync(encryptedFile, decryptedFile, key); Synchronous Decryption: using var encryptedFile = File.OpenRead(\"encrypted.dat\"); using var decryptedFile = File.Create(\"decrypted.dat\"); SecretStream.Decrypt(encryptedFile, decryptedFile, key); ⚠️ Security Considerations Secure Key Management: Protect your keys; losing them or exposing them compromises security. Nonce Management: Handled internally by SecretStream; avoid manual nonce reuse. Integrity Checks: Automatic using Poly1305 tags; any tampering results in exceptions. ⚠️ Error Handling Encryption and decryption throw specific exceptions for error conditions: ArgumentException: Invalid arguments (wrong key length, null streams). LibSodiumException: Authentication failed, typically from tampered data. \uD83D\uDD52 Performance Considerations SecretStream processes data in chunks (default: 64KB) for optimal balance between memory usage and performance. Utilize asynchronous methods (EncryptAsync/DecryptAsync) for IO-bound scenarios for better scalability."
  },
  "guide/SecureBigUnsignedInteger.html": {
    "href": "guide/SecureBigUnsignedInteger.html",
    "title": "\uD83D\uDD22 SecureBigUnsignedInteger | LibSodium.Net",
    "summary": "\uD83D\uDD22 SecureBigUnsignedInteger The SecureBigUnsignedInteger class provides constant-time operations for working with large, little-endian, unsigned integers represented as Span<byte>. It wraps several low-level functions from libsodium that are specifically designed to be safe against side-channel attacks. \uD83E\uDDC2 Based on libsodium’s Integer manipulation helpers ℹ️ See also: API Reference for SecureBigUnsignedInteger \uD83D\uDD10 Security Considerations All operations in this class are evaluated in constant time with respect to buffer size, which helps prevent timing-based side-channel attacks. These methods are suitable for cryptographic contexts where comparisons, additions, or manipulations of secrets must not leak information through execution timing. \uD83C\uDF1F Features Constant-time comparison, equality, addition, and subtraction. Increment by 1 or arbitrary 64-bit value. Zero-checking. Supports arbitrary-sized numbers (as long as both operands have the same length). Uses spans to avoid heap allocations. ✨ Usage Examples \uD83D\uDCCB Constant-Time Equality Check Span<byte> a = stackalloc byte[] { 1, 2, 3 }; Span<byte> b = stackalloc byte[] { 1, 2, 3 }; bool areEqual = SecureBigUnsignedInteger.Equals(a, b); // true \uD83D\uDCCB Constant-Time Compare int cmp = SecureBigUnsignedInteger.Compare(a, b); // 0 if equal, <0 if a < b, >0 if a > b \uD83D\uDCCB Increment Span<byte> number = stackalloc byte[4]; SecureBigUnsignedInteger.Increment(number); // adds 1 SecureBigUnsignedInteger.Increment(number, 42); // adds 42 \uD83D\uDCCB Addition and Subtraction Span<byte> a = stackalloc byte[] { 5, 0, 0 }; ReadOnlySpan<byte> b = stackalloc byte[] { 3, 0, 0 }; SecureBigUnsignedInteger.Add(a, b); // a = a + b SecureBigUnsignedInteger.Subtract(a, b); // a = a - b ⚠️ Both operands must have the same length. Otherwise, ArgumentException is thrown. \uD83D\uDCCB Zero Check Span<byte> n = stackalloc byte[] { 0, 0, 0 }; bool isZero = SecureBigUnsignedInteger.IsZero(n); // true This API is ideal for low-level cryptographic arithmetic where performance, determinism, and side-channel resistance are essential."
  },
  "guide/SecureMemory.html": {
    "href": "guide/SecureMemory.html",
    "title": "\uD83D\uDEE1️ SecureMemory | LibSodium.Net",
    "summary": "\uD83D\uDEE1️ SecureMemory When working with cryptographic data, it's essential to ensure that sensitive information doesn't get leaked through memory dumps, swapping, or garbage collection. LibSodium.Net provides SecureMemory and SecureMemory<T> as robust tools to manage sensitive data safely in unmanaged memory. \uD83E\uDDC2 Backed by libsodium's Secure memory. ℹ️ See also: API Reference for SecureMemory<T> These APIs leverage libsodium’s sodium_malloc, sodium_mlock, and related memory protection functions to offer secure, optionally read-only memory regions that are wiped on disposal. ✨ SecureMemory<T> SecureMemory<T> is a managed wrapper around unmanaged memory that stores a buffer of unmanaged type T items. It ensures: Memory is allocated using sodium_allocarray. Memory is wiped with sodium_free on disposal. Optional read-only protection using ProtectReadOnly(). Optional read-write toggle with ProtectReadWrite(). Safe access through Span<T>, Memory<T>, ReadOnlySpan<T>, and ReadOnlyMemory<T>. \uD83D\uDCCB Basic Usage using var secure = SecureMemory.Create<byte>(32); // Allocate secure memory var span = secure.AsSpan(); // Write access RandomGenerator.Fill(span); // Fill with sensitive data secure.ProtectReadOnly(); // Make it read-only var readOnly = secure.AsReadOnlySpan(); // Safe read-only view ✨ Safety Features Accessing the SecureMemory<T> object after disposal throws ObjectDisposedException. Writing to memory after calling ProtectReadOnly() throws an AccessViolationException. Writing through a Span<T> previously obtained before calling ProtectReadOnly() also throws AccessViolationException. Memory is automatically zeroed out upon disposal using sodium_memzero. ✨ SecureMemory<T> Utilities \uD83D\uDCCB Allocate Secure Buffers using var buffer = SecureMemory.Create<byte>(64); \uD83D\uDCCB Zeroing Buffers buffer.MemZero(); // Overwrites memory with zeroes \uD83D\uDCCB Protect Memory buffer.ProtectReadOnly(); buffer.ProtectReadWrite(); \uD83D\uDCCB Read-Only & Read-Write Access Use .AsSpan() to get mutable access. Use .AsReadOnlySpan() to get immutable view. ⚠️ Security Considerations Unmanaged memory isn't GC-tracked — make sure to dispose properly. AccessViolationException is a sign that read/write protections are working as intended. Avoid exposing memory unnecessarily — always limit visibility."
  },
  "guide/XChaCha20-Poly1305.html": {
    "href": "guide/XChaCha20-Poly1305.html",
    "title": "\uD83D\uDD10 XChaCha20-Poly1305 | LibSodium.Net",
    "summary": "\uD83D\uDD10 XChaCha20-Poly1305 The XChaCha20Poly1305 API in LibSodium.Net provides authenticated encryption with associated data (AEAD) and extended nonce support (192-bit), making it safer for use in systems where nonce reuse is a concern. It supports both combined and detached encryption modes, and allows manual or automatic nonce handling through a unified API. \uD83E\uDDC2 Based on libsodium's XChaCha20-Poly1305 construction ℹ️ See also: API Reference for XChaCha20Poly1305 \uD83C\uDF1F Features Authenticated encryption with associated data (AEAD). 24-byte nonce (192-bit) minimizes risk of nonce reuse. Combined and detached mode support through a single API. Optional additionalData for protocol-level authentication. Manual or automatic nonce handling. Span<T>-based API for high performance and low allocations. ✨ Encrypting and Decrypting Messages Use the Encrypt and Decrypt methods to perform authenticated encryption. The mode is determined by the presence of the optional mac parameter. \uD83D\uDCCB Combined Mode (Auto Nonce, No AAD) Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen]; RandomGenerator.Fill(key); var plaintext = Encoding.UTF8.GetBytes(\"Auto nonce test\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + XChaCha20Poly1305.MacLen + XChaCha20Poly1305.NonceLen]; XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key); Span<byte> decrypted = stackalloc byte[plaintext.Length]; XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Combined Mode (Manual Nonce with AAD) Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen]; Span<byte> nonce = stackalloc byte[XChaCha20Poly1305.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"With AAD and nonce\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length + XChaCha20Poly1305.MacLen]; Span<byte> aad = Encoding.UTF8.GetBytes(\"metadata\"); XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, aad: aad, nonce: nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, aad: aad, nonce: nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); \uD83D\uDCCB Detached Mode (Manual Nonce) Span<byte> key = stackalloc byte[XChaCha20Poly1305.KeyLen]; Span<byte> nonce = stackalloc byte[XChaCha20Poly1305.NonceLen]; RandomGenerator.Fill(key); RandomGenerator.Fill(nonce); var plaintext = Encoding.UTF8.GetBytes(\"Detached encryption\"); Span<byte> ciphertext = stackalloc byte[plaintext.Length]; Span<byte> mac = stackalloc byte[XChaCha20Poly1305.MacLen]; XChaCha20Poly1305.Encrypt(ciphertext, plaintext, key, mac, nonce: nonce); Span<byte> decrypted = stackalloc byte[plaintext.Length]; XChaCha20Poly1305.Decrypt(decrypted, ciphertext, key, mac, nonce: nonce); Console.WriteLine(Encoding.UTF8.GetString(decrypted)); ⚠️ Error Handling ArgumentException — invalid input sizes. LibSodiumException — authentication failed (tampered data). \uD83D\uDCDD Notes Nonce must be exactly 24 bytes. Auto-nonce is prepended to ciphertext for easy reuse. Buffers must have space for output (e.g., ciphertext includes MAC and possibly nonce). It can be longer than needed. Encrypt and Decrypt automatically choose combined or detached mode depending on the presence of the mac parameter. Use RandomGenerator.Fill() to safely generate keys and nonces. AAD is optional but recommended for additional authentication context. \uD83D\uDC40 See Also libsodium AEAD documentation RFC 8439 - ChaCha20 and Poly1305 for IETF Protocols API Reference"
  },
  "guide/index.html": {
    "href": "guide/index.html",
    "title": "\uD83D\uDD10 Introduction to LibSodium.Net | LibSodium.Net",
    "summary": "\uD83D\uDD10 Introduction to LibSodium.Net LibSodium.Net provides .NET developers with easy-to-use bindings for libsodium, a powerful, modern cryptography library widely recognized for its simplicity and security. This makes it straightforward to add robust cryptographic functionality to your .NET applications. ✨ Why LibSodium.Net? Cross-platform: Seamless support across Windows, Linux, and macOS. Modern Cryptography: Includes authenticated encryption, public-key cryptography, hashing, key derivation, and digital signatures. Simple and Secure API: Designed to reduce complexity, helping you implement cryptography correctly and securely. Secure Memory Handling: Sensitive data management to minimize risks like memory leaks or data exposure. Span over Arrays : Optimized for performance and memory efficiency by using Span<T> instead of heap-allocated arrays. AOT Compatible: Uses LibraryImport (source-generated P/Invoke) instead of DllImport, making it fully compatible with AOT compilation environments. \uD83D\uDE80 Getting Started with LibSodium.Net Here's how you can quickly integrate LibSodium.Net into your .NET projects. ✨ Install via NuGet You can easily install LibSodium.Net using the NuGet package manager: CLI dotnet add package LibSodium.Net Visual Studio Right-click your project in Solution Explorer. Choose Manage NuGet Packages. Search for LibSodium.Net and click Install. Package Manager Console Install-Package LibSodium.Net"
  },
  "index.html": {
    "href": "index.html",
    "title": "LibSodium.Net | LibSodium.Net",
    "summary": "LibSodium.Net Modern Cryptography for .NET Welcome to LibSodium.Net, the secure and developer-friendly .NET bindings for libsodium — a battle-tested, modern cryptographic library used around the world. Whether you're building web services, desktop apps, IoT devices, or cross-platform tools, LibSodium.Net helps you add robust, efficient, and secure cryptographic functionality with confidence. ✨ Simple, Powerful, and Secure Built on the trusted libsodium C library. Designed for modern .NET: efficient memory handling via Span<T>, support for AOT via LibraryImport. Safe-by-default APIs that help you do cryptography right. Includes secure memory utilities, symmetric and asymmetric encryption, hashing, key derivation, and more. \uD83C\uDF0A First-Class Streaming Encryption LibSodium.Net provides idiomatic support for large file and streaming authenticated encryption using libsodium’s XChaCha20-Poly1305. Powered by the SecretStream API, you can securely encrypt and decrypt files of any size with tamper-detection and zero nonce reuse risk — all in a few lines of code. \uD83D\uDE80 Get Started Install the NuGet package: dotnet add package LibSodium.Net Then head over to our Guide to learn how to: Encrypt and decrypt data securely Generate cryptographic keys Work with secure memory Handle errors properly and safely \uD83D\uDCC4 Reference Documentation Need details on specific APIs? Browse the full Reference Documentation to explore everything from SecretBox and SecureMemory<T> to stream encryption and key generation helpers."
  }
}