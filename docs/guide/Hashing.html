<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>&#128256; Hashing | LibSodium.Net </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="&#128256; Hashing | LibSodium.Net ">
      
      
      <link rel="icon" href="../images/Na.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/LibSodium-Net/LibSodium.Net/blob/main/docfx/guide/Hashing.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="Home">
            Home
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="-hashing">🔀 Hashing</h1>

<p>LibSodium.Net provides multiple hashing APIs for different use cases:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Algorithm</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GenericHash</code></td>
<td>BLAKE2b</td>
<td>Cryptographic hash with optional key. Use for MAC, PRF, fingerprints.</td>
</tr>
<tr>
<td><code>ShortHash</code></td>
<td>SipHash‑2‑4</td>
<td>Keyed hash designed to prevent collisions in hash tables. Fast for short inputs.</td>
</tr>
<tr>
<td><code>CryptoSha256</code></td>
<td>SHA‑256</td>
<td>Fast fixed‑length (32‑byte) hash for integrity checks, digital signatures, checksums.</td>
</tr>
<tr>
<td><code>CryptoSha512</code></td>
<td>SHA‑512</td>
<td>Fast fixed‑length (64‑byte) hash for high‑strength integrity and digital signatures.</td>
</tr>
<tr>
<td><code>CryptoPasswordHashArgon</code></td>
<td>Argon2id/i13</td>
<td>Password hashing and key derivation (slow &amp; memory‑hard)</td>
</tr>
<tr>
<td><code>CryptoPasswordHashScrypt</code></td>
<td>Scrypt</td>
<td>Password hashing and key derivation (slow &amp; memory‑hard, legacy)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>📝 SHA‑2 functions are <strong>not suitable</strong> for password hashing or key derivation. Use Argon2 or scrypt instead.</p>
</blockquote>
<blockquote>
<p>🧂 Based on <a href="https://doc.libsodium.org/hashing">libsodium’s Hashing</a><br>
🧂 Based on <a href="https://doc.libsodium.org/password_hashing">Password Hashing</a><br>
🧂 Based on <a href="https://doc.libsodium.org/advanced/sha-2_hash_function">SHA-2</a><br>
ℹ️ <a href="../api/LibSodium.CryptoGenericHash.html">API Reference: CryptoGenericHash</a><br>
ℹ️ <a href="../api/LibSodium.CryptoSha256.html">API Reference: CryptoSha256</a><br>
ℹ️ <a href="../api/LibSodium.CryptoSha512.html">API Reference: CryptoSha512</a>
ℹ️ <a href="../api/LibSodium.CryptoShortHash.html">API Reference: CryptoShortHash</a><br>
ℹ️ <a href="../api/LibSodium.CryptoPasswordHashArgon.html">API Reference: CryptoPasswordHashArgon</a><br>
ℹ️ <a href="../api/LibSodium.CryptoPasswordHashScrypt.html">API Reference: CryptoPasswordHashScrypt</a><br></p>
</blockquote>
<hr>
<h2 id="-features">🌟 Features</h2>
<ul>
<li>Cryptographic hashing with variable output length (GenericHash)</li>
<li>Fast fixed‑length hashing (CryptoSha256 &amp; CryptoSha512)</li>
<li>SipHash‑based keyed hash for short inputs (ShortHash)</li>
<li>Password hashing and key derivation using Argon2 (CryptoPasswordHash)</li>
<li>All methods are allocation‑free, <code>Span</code>‑based, and deterministic (except password hash, which is randomized)</li>
<li>Stream and async support for large input hashing (GenericHash, CryptoSha256, CryptoSha512)</li>
<li>Incremental (multi-part) hashing  (GenericHash, CryptoSha256, CryptoSha512)</li>
</ul>
<hr>
<h2 id="-key-management">🗝️ Key Management</h2>
<p>Some hash functions accept a key (e.g., GenericHash, ShortHash), while others produce one as output (e.g., Argon2, Scrypt). This section explains how to pass and store keys safely.</p>
<p>Keys can be provided or stored using the following types:</p>
<ul>
<li><code>SecureMemory&lt;byte&gt;</code> — most secure option, with memory protection and automatic zeroing.</li>
<li><code>Span&lt;byte&gt;</code> / <code>ReadOnlySpan&lt;byte&gt;</code> — fast and stack-allocated. Ideal for synchronous use.</li>
<li><code>byte[]</code> — interoperable and usable in both sync and async contexts.</li>
<li><code>Memory&lt;byte&gt;</code> / <code>ReadOnlyMemory&lt;byte&gt;</code> — for use with async methods.</li>
</ul>
<blockquote>
<p>📝 Use <code>Span&lt;T&gt;</code> for high-performance local operations, and <code>SecureMemory&lt;byte&gt;</code> to protect secrets in memory.</p>
</blockquote>
<p>When using key derivation functions (e.g., Argon2, Scrypt):</p>
<p><strong>Examples</strong>:</p>
<pre><code class="lang-csharp">// SecureMemory&lt;byte&gt;
using var key = new SecureMemory&lt;byte&gt;(GenericHash.KeyLen);
RandomGenerator.Fill(key);
key.ProtectReadOnly();
</code></pre>
<pre><code class="lang-csharp">// Span&lt;byte&gt;
Span&lt;byte&gt; key = stackalloc byte[GenericHash.KeyLen];
RandomGenerator.Fill(key);
</code></pre>
<pre><code class="lang-csharp">// byte[]
var key = new byte[GenericHash.KeyLen];
RandomGenerator.Fill(key);
</code></pre>
<p><strong>Tips:</strong></p>
<ul>
<li>Store the derived key in <code>SecureMemory&lt;byte&gt;</code>, mark it as read-only using <code>.ProtectReadOnly()</code>, and dispose it properly.</li>
<li>Never reuse keys across different algorithms or protocols. Even if the key size is compatible, doing so weakens isolation and security boundaries.</li>
<li>Use a strong, random salt and a context-specific derivation strategy.</li>
<li>Generate a fresh random key with <code>RandomGenerator.Fill()</code> and store it securely (e.g., Azure Key Vault, environment variable, HSM).</li>
<li>Rotate keys periodically.</li>
</ul>
<h2 id="-generichashblake2b">✨ GenericHash — BLAKE2b</h2>
<p>BLAKE2b is a cryptographic hash function designed as a faster and safer alternative to SHA‑2. It provides high‑performance hashing with optional key support, making it suitable for:</p>
<ul>
<li>Cryptographic checksums (fingerprints)</li>
<li>Message authentication codes (MACs)</li>
<li>Deriving identifiers or integrity tags</li>
<li>Hashing files or streams of arbitrary size</li>
<li>Unique deterministic identifiers</li>
<li>Pseudorandom functions (PRF) when keyed</li>
</ul>
<p>By default, it produces 32‑byte output, but can be configured to return between 16 and 64 bytes. It supports <em>keyed hashing</em> for MAC‑like or PRF behavior, using a key of 32 bytes by default (configurable between 16 and 64 bytes), or <em>unkeyed hashing</em> for general‑purpose use.</p>
<h3 id="-constants">📏 Constants</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HashLen</code></td>
<td>32</td>
<td>Default output length</td>
</tr>
<tr>
<td><code>MinHashLen</code></td>
<td>16</td>
<td>Minimum output length</td>
</tr>
<tr>
<td><code>MaxHashLen</code></td>
<td>64</td>
<td>Maximum output length</td>
</tr>
<tr>
<td><code>KeyLen</code></td>
<td>32</td>
<td>Default key length</td>
</tr>
<tr>
<td><code>MinKeyLen</code></td>
<td>16</td>
<td>Minimum key length</td>
</tr>
<tr>
<td><code>MaxKeyLen</code></td>
<td>64</td>
<td>Maximum key length</td>
</tr>
</tbody>
</table>
<h3 id="-hashing-with-generichash">📋 Hashing with GenericHash</h3>
<p><strong>With optional key:</strong></p>
<pre><code class="lang-csharp">Span&lt;byte&gt; hash = stackalloc byte[CryptoGenericHash.HashLen];
CryptoGenericHash.ComputeHash(hash, message);              // unkeyed
CryptoGenericHash.ComputeHash(hash, message, key);         // keyed
</code></pre>
<p><strong>from a stream:</strong></p>
<pre><code class="lang-csharp">using var stream = File.OpenRead(&quot;large-input.dat&quot;);
CryptoGenericHash.ComputeHash(hash, stream);
</code></pre>
<p><strong>Async stream support:</strong></p>
<pre><code class="lang-csharp">using var stream = File.OpenRead(&quot;large-input.dat&quot;);
await CryptoGenericHash.ComputeHashAsync(hash, stream, key);
</code></pre>
<hr>
<h2 id="-cryptosha256sha256">✨ CryptoSha256 — SHA‑256</h2>
<p><code>CryptoSha256</code> offers a high‑speed, fixed‑length (32‑byte) SHA‑256 implementation built directly on libsodium’s <code>crypto_hash_sha256</code> API. Use it when you need interoperability with existing SHA‑256 digests (e.g., digital signatures, blockchain, TLS certificate fingerprints) or whenever a fixed 32‑byte checksum is required.</p>
<h3 id="-constants-1">📏 Constants</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HashLen</code></td>
<td>32</td>
<td>Output length (32 bytes)</td>
</tr>
</tbody>
</table>
<h3 id="-hashing-with-cryptosha256">📋 Hashing with CryptoSha256</h3>
<p><strong>Hash a byte array:</strong></p>
<pre><code class="lang-csharp">Span&lt;byte&gt; hash = stackalloc byte[CryptoSha256.HashLen];
CryptoSha256.ComputeHash(hash, message);
</code></pre>
<p><strong>Hash a stream (buffered, sync):</strong></p>
<pre><code class="lang-csharp">using var stream = File.OpenRead(&quot;video.mp4&quot;);
CryptoSha256.ComputeHash(hash, stream);
</code></pre>
<p><strong>Async stream hashing:</strong></p>
<pre><code class="lang-csharp">await CryptoSha256.ComputeHashAsync(hash, stream);
</code></pre>
<hr>
<h2 id="-cryptosha512sha512">✨ CryptoSha512 — SHA‑512</h2>
<p><code>CryptoSha512</code> is a fixed‑length (64‑byte) implementation of SHA‑512 via libsodium’s <code>crypto_hash_sha512</code>. It is usually faster than SHA‑256 on modern 64‑bit CPUs and provides a larger security margin.</p>
<h3 id="-constants-2">📏 Constants</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HashLen</code></td>
<td>64</td>
<td>Output length (64 bytes)</td>
</tr>
</tbody>
</table>
<h3 id="-hashing-with-cryptosha512">📋 Hashing with CryptoSha512</h3>
<p><strong>Hash a Span<byte>:</byte></strong></p>
<pre><code class="lang-csharp">Span&lt;byte&gt; hash = stackalloc byte[CryptoSha512.HashLen];
CryptoSha512.ComputeHash(hash, message);
</code></pre>
<p><strong>Hash a stream (buffered, sync):</strong></p>
<pre><code class="lang-csharp">using var stream = File.OpenRead(&quot;backup.tar&quot;);
CryptoSha512.ComputeHash(hash, stream);
</code></pre>
<p><strong>Async stream hashing:</strong></p>
<pre><code class="lang-csharp">await CryptoSha512.ComputeHashAsync(hash, stream);
</code></pre>
<hr>
<h2 id="-incremental-hashing">✨ Incremental Hashing</h2>
<p>In some scenarios, data to be hashed is not available as a single contiguous buffer — for example, when you want to compute <code>hash(a || b || c)</code> from multiple inputs. LibSodium.Net offers <strong>incremental hashing</strong> for this purpose.</p>
<p>The following classes support incremental hashing:</p>
<ul>
<li><code>CryptoGenericHash</code> (BLAKE2b, optionally keyed)</li>
<li><code>CryptoSha256</code> (SHA-256)</li>
<li><code>CryptoSha512</code> (SHA-512)</li>
</ul>
<p>These types expose an incremental API via the <code>ICryptoIncrementalHash</code> interface.</p>
<p><strong>Compute hash from multiple parts:</strong></p>
<pre><code class="lang-csharp">Span&lt;byte&gt; hash = stackalloc byte[CryptoSha256.HashLen];
using var hasher = CryptoSha256.CreateIncrementalHash();

hasher.Update(Encoding.UTF8.GetBytes(&quot;header&quot;));
hasher.Update(Encoding.UTF8.GetBytes(&quot;payload&quot;));
hasher.Update(Encoding.UTF8.GetBytes(&quot;footer&quot;));
hasher.Final(hash);
</code></pre>
<p>This pattern ensures correctness and efficiency when you want to hash logically grouped inputs without allocating or copying them into a single buffer.</p>
<p><strong>With a keyed BLAKE2b hash</strong></p>
<pre><code class="lang-csharp">Span&lt;byte&gt; key = stackalloc byte[CryptoGenericHash.KeyLen];
RandomGenerator.Fill(key);

Span&lt;byte&gt; hash = stackalloc byte[32];
var part1 = Encoding.UTF8.GetBytes(&quot;hello&quot;);
var part2 = Encoding.UTF8.GetBytes(&quot;world&quot;);

using var hasher = CryptoGenericHash.CreateIncrementalHash(key, hash.Length);

hasher.Update(part1);
hasher.Update(part2);
hasher.Final(hash);
</code></pre>
<blockquote>
<p>ℹ️ The <code>Final()</code> method may only be called once per hash instance. You must create a new instance for each new computation.</p>
</blockquote>
<hr>
<h2 id="-shorthashsiphash24">✨ ShortHash — SipHash‑2‑4</h2>
<blockquote>
<p>⚠️ ShortHash is <strong>not</strong> a cryptographic hash. Do not use it for fingerprinting, content integrity, password hashing, or digital signatures.</p>
</blockquote>
<p>SipHash is a fast keyed hash function optimized for short inputs. It is designed to mitigate hash‑flooding attacks in hash tables and similar data structures where untrusted input might lead to performance degradation.</p>
<p>It should be used for:</p>
<ul>
<li>Hash table key protection</li>
<li>Fast authentication of short data</li>
<li>Use cases where speed and DoS‑resistance are more important than collision resistance</li>
</ul>
<p>SipHash is always keyed, and its output is always 8 bytes.</p>
<h3 id="-constants-3">📏 Constants</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HashLen</code></td>
<td>8</td>
<td>Output length (8 bytes)</td>
</tr>
<tr>
<td><code>KeyLen</code></td>
<td>16</td>
<td>Key length (16 bytes)</td>
</tr>
</tbody>
</table>
<h3 id="-hashing-with-shorthash">📋 Hashing with ShortHash</h3>
<blockquote>
<p>ℹ️ key is required</p>
</blockquote>
<pre><code class="lang-csharp">Span&lt;byte&gt; hash = stackalloc byte[CryptoShortHash.HashLen];
CryptoShortHash.ComputeHash(hash, message, key);
</code></pre>
<hr>
<h2 id="-passwordhashargon">✨ PasswordHashArgon</h2>
<p>Secure password hashing and key derivation using Argon2 (Argon2id / Argon2i13). This algorithm is specifically designed to defend against brute‑force attacks by requiring significant computational work and memory. It is ideal for storing passwords, deriving keys from passphrases, or implementing authentication mechanisms.</p>
<p>Unlike fast cryptographic hash functions (like SHA‑256 or BLAKE2b), Argon2 is <em>deliberately slow</em> and <em>memory‑intensive</em>, which drastically increases the cost of large‑scale password cracking (e.g., GPU attacks). LibSodium.Net exposes both Argon2id (recommended) and Argon2i.</p>
<p>The cost parameters (iterations and memory) can be tuned to balance security and performance depending on the context:</p>
<ul>
<li><strong>Interactive</strong> – suitable for login forms.</li>
<li><strong>Moderate</strong> – for higher‑value secrets.</li>
<li><strong>Sensitive</strong> – for long‑term or critical secrets.</li>
</ul>
<h3 id="-constants-4">📏 Constants</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SaltLen</code></td>
<td>16</td>
<td>Length of the salt in bytes</td>
</tr>
<tr>
<td><code>MinKeyLen</code></td>
<td>16</td>
<td>Minimum key length for derivation</td>
</tr>
<tr>
<td><code>EncodedLen</code></td>
<td>128</td>
<td>Length of the encoded hash string</td>
</tr>
<tr>
<td><code>Prefix</code></td>
<td>&quot;$argon2id$&quot;</td>
<td>Prefix for Argon2id encoded hash</td>
</tr>
<tr>
<td><code>MinMemoryLen</code></td>
<td>8 KiB</td>
<td>Minimum acceptable memory for hashing</td>
</tr>
<tr>
<td><code>MinIterations</code></td>
<td>1</td>
<td>Minimum acceptable iterations</td>
</tr>
<tr>
<td><code>InteractiveIterations</code></td>
<td>2</td>
<td>Iteration count for interactive targets</td>
</tr>
<tr>
<td><code>InteractiveMemoryLen</code></td>
<td>64 MiB</td>
<td>Memory usage for interactive targets</td>
</tr>
<tr>
<td><code>ModerateIterations</code></td>
<td>3</td>
<td>For app secrets or backup keys</td>
</tr>
<tr>
<td><code>ModerateMemoryLen</code></td>
<td>256 MiB</td>
<td>For app secrets or backup keys</td>
</tr>
<tr>
<td><code>SensitiveIterations</code></td>
<td>4</td>
<td>Iteration count for sensitive targets</td>
</tr>
<tr>
<td><code>SensitiveMemoryLen</code></td>
<td>1 GiB</td>
<td>Memory usage for sensitive targets</td>
</tr>
</tbody>
</table>
<h3 id="-working-with-passwordhashargon">📋 Working with PasswordHashArgon</h3>
<p><strong>Hash a password (encoded, random salt):</strong></p>
<pre><code class="lang-csharp">string hash = CryptoPasswordHash.HashPassword(&quot;my password&quot;);
</code></pre>
<p><strong>Verify a password:</strong></p>
<pre><code class="lang-csharp">bool valid = CryptoPasswordHash.VerifyPassword(hash, &quot;my password&quot;);
</code></pre>
<p><strong>Derive a secret key from a password (e.g., for encryption):</strong></p>
<pre><code class="lang-csharp">using var key = new SecureMemory(32);
Span&lt;byte&gt; salt = stackalloc byte[CryptoPasswordHash.SaltLen];
RandomGenerator.Fill(salt);
CryptoPasswordHash.DeriveKey(key, &quot;password&quot;, salt);
</code></pre>
<p>You can customise the computational cost:</p>
<pre><code class="lang-csharp">CryptoPasswordHash.DeriveKey(
    key, &quot;password&quot;, salt,
    iterations: CryptoPasswordHash.SensitiveIterations,
    requiredMemoryLen: CryptoPasswordHash.SensitiveMemoryLen);
</code></pre>
<hr>
<h2 id="-passwordhashscrypt">✨ PasswordHashScrypt</h2>
<p>Password hashing and key derivation using <code>scrypt</code>, a memory-hard function introduced before Argon2. Though not side-channel resistant, it is still widely used and interoperable.</p>
<p>LibSodium.Net improves over libsodium by offering consistent tuning options (<code>Min</code>, <code>Interactive</code>, <code>Moderate</code>, <code>Sensitive</code>) and full validation coverage.</p>
<h3 id="-constants-5">📏 Constants</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SaltLen</code></td>
<td>32</td>
<td>Length of the salt in bytes</td>
</tr>
<tr>
<td><code>MinKeyLen</code></td>
<td>16</td>
<td>Minimum key length for derivation</td>
</tr>
<tr>
<td><code>EncodedLen</code></td>
<td>102</td>
<td>Length of the encoded hash string</td>
</tr>
<tr>
<td><code>Prefix</code></td>
<td>&quot;$7$&quot;</td>
<td>Prefix for scrypt encoded hash</td>
</tr>
<tr>
<td><code>MinIterations</code></td>
<td>1024 (2^10)</td>
<td>Minimum recommended iterations</td>
</tr>
<tr>
<td><code>MinMemoryLen</code></td>
<td>32 KiB (2^15)</td>
<td>Minimum recommended memory</td>
</tr>
<tr>
<td><code>InteractiveIterations</code></td>
<td>524288 (2^19)</td>
<td>For login/password use</td>
</tr>
<tr>
<td><code>InteractiveMemoryLen</code></td>
<td>16 MiB (2^24)</td>
<td>For login/password use</td>
</tr>
<tr>
<td><code>ModerateIterations</code></td>
<td>4194304 (2^22)</td>
<td>For app secrets or backup keys</td>
</tr>
<tr>
<td><code>ModerateMemoryLen</code></td>
<td>128 MiB (2^27)</td>
<td>For app secrets or backup keys</td>
</tr>
<tr>
<td><code>SensitiveIterations</code></td>
<td>33554432 (2^25)</td>
<td>For long-term or high-value secrets</td>
</tr>
<tr>
<td><code>SensitiveMemoryLen</code></td>
<td>1 GiB (2^30)</td>
<td>For long-term or high-value secrets</td>
</tr>
</tbody>
</table>
<h3 id="-working-with-passwordhashscrypt">📋 Working with PasswordHashScrypt</h3>
<p><strong>Hash and verify:</strong></p>
<pre><code class="lang-csharp">string hash = CryptoPasswordHashScrypt.HashPassword(&quot;my password&quot;);
bool valid = CryptoPasswordHashScrypt.VerifyPassword(hash, &quot;my password&quot;);
</code></pre>
<p><strong>Deriving a key from a password:</strong></p>
<pre><code class="lang-csharp">using var key = new SecureMemory&lt;byte&gt;(32);
Span&lt;byte&gt; salt = stackalloc byte[CryptoPasswordHashScrypt.SaltLen];
RandomGenerator.Fill(salt);
CryptoPasswordHashScrypt.DeriveKey(key, &quot;password&quot;, salt,
    iterations: CryptoPasswordHashScrypt.ModerateIterations,
    requiredMemoryLen: CryptoPasswordHashScrypt.ModerateMemoryLen);
</code></pre>
<hr>
<h2 id="-error-handling">⚠️ Error Handling</h2>
<ul>
<li><code>ArgumentException</code> — when input or key lengths are invalid</li>
<li><code>ArgumentOutOfRangeException</code> — when iterations or memory limits are too low</li>
<li><code>LibSodiumException</code> — if the underlying native function fails</li>
</ul>
<hr>
<h2 id="-notes">📝 Notes</h2>
<ul>
<li><code>GenericHash</code> is based on BLAKE2b and supports variable‑length output and optional keys.</li>
<li><code>CryptoSha256</code> and <code>CryptoSha512</code> provide interoperable SHA‑2 digests and are the best choice when you need a <em>fixed‑length</em> checksum or compatibility with external systems.</li>
<li><code>ShortHash</code> is based on SipHash‑2‑4 — <em>not</em> a general‑purpose cryptographic hash, but a keyed primitive for protecting hash tables.</li>
<li><code>CryptoPasswordHashArgon</code> uses Argon2id/Argon2i13 with computational and memory hardness.</li>
<li>All hash functions are deterministic: same input and key produce same output — <strong>except</strong> <code>CryptoPasswordHash.HashPassword</code>, which includes a random salt and produces a different hash each time.</li>
<li><code>Scrypt</code> is <strong>not side-channel resistant</strong>. Use <code>Argon2i13</code> or <code>Argon2id13</code> for high-security or shared-host scenarios.</li>
<li>Use <code>ShortHash</code> only when you can keep the key secret.</li>
</ul>
<hr>
<h2 id="-choosing-the-right-hash-api">🧭 Choosing the Right Hash API</h2>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Recommended API</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable‑length cryptographic checksum</td>
<td><code>GenericHash</code></td>
</tr>
<tr>
<td>Fixed‑length 32‑byte digest (e.g., TLS cert fingerprint)</td>
<td><code>CryptoSha256</code></td>
</tr>
<tr>
<td>Fixed‑length 64‑byte digest, higher speed on x64</td>
<td><code>CryptoSha512</code></td>
</tr>
<tr>
<td>MAC (Message Authentication Code) or PRF (Pseudo Random Function)</td>
<td><code>GenericHash</code> (with key)</td>
</tr>
<tr>
<td>Hashing short keys in tables</td>
<td><code>ShortHash</code></td>
</tr>
<tr>
<td>Password storage / passphrase‑derived keys</td>
<td><code>CryptoPasswordHashArgon</code></td>
</tr>
<tr>
<td>Legacy Password storage / passphrase‑derived keys</td>
<td><code>CryptoPasswordHashScrypt</code></td>
</tr>
</tbody>
</table>
<h2 id="-see-also">👀 See Also</h2>
<ul>
<li>ℹ️ <a href="../api/LibSodium.CryptoGenericHash.html">API Reference: CryptoGenericHash</a></li>
<li>ℹ️ <a href="../api/LibSodium.CryptoSha256.html">API Reference: CryptoSha256</a></li>
<li>ℹ️ <a href="../api/LibSodium.CryptoSha512.html">API Reference: CryptoSha512</a></li>
<li>ℹ️ <a href="../api/LibSodium.CryptoShortHash.html">API Reference: CryptoShortHash</a></li>
<li>ℹ️ <a href="../api/LibSodium.CryptoPasswordHashArgon.html">API Reference: CryptoPasswordHashArgon</a></li>
<li>ℹ️ <a href="../api/LibSodium.CryptoPasswordHashScrypt.html">API Reference: CryptoPasswordHashScrypt</a></li>
<li>🧂 <a href="https://doc.libsodium.org/hashing">libsodium Hashing</a></li>
<li>🧂 <a href="https://doc.libsodium.org/password_hashing">libsodium Password Hashing</a></li>
<li>🧂 <a href="https://doc.libsodium.org/advanced/sha-2_hash_function">libsodium SHA-2</a><br></li>
</ul>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <p align="center" style="font-size: 0.9rem; color: #666;">Made with ❤️ by Jesús López for the community — LibSodium.Net: secure cryptography for .NET</p>
        </div>
      </div>
    </footer>
  </body>
</html>
